<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Algorithm</title>
    <url>/2025/03/22/algorithm/</url>
    <content><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><blockquote>
<ul>
<li><a href="https://blog.csdn.net/u011614717/article/details/82624095">时间复杂度</a><ul>
<li>O(1) 表示一次操作即可直接取得目标元素（比如字典或哈希表）</li>
<li>O(n) 意味着先要检查 n 个元素来搜索目标</li>
<li>二分搜索最好情况下的时间复杂度是 O(1)，最坏情况（平均情况）下 O(log(n))</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li><p><a href="http://www.cnblogs.com/shangyu/archive/2012/07/28/2612832.html">运算符</a></p>
<ul>
<li><p>按位与 “&amp;”</p>
<ul>
<li>清零指定位<br>  将十进制整数 “257”（转换成二进制为 “00000001 00000001”）的高八位清零，结果应为十进制整数 “1”（转换成二进制为 “00000000 00000001”<br>  <code>console.assert((257 &amp; 0xff) == 1);</code></li>
<li>取某数中指定位<br>  判断十进制整数 “225”（转换成二进制为 “11100001”）的第七位是否为 “1”<br>  <code>console.assert((225 &amp; 0x40) == 0x40);</code></li>
</ul>
</li>
<li><p>按位或 “|”</p>
<ul>
<li>将指定位置 “1”<br>  将十进制整数 “225”（转换成二进制为 “11100001”）的第四位置 “1”，结果应为十进制整数 “233”（转换成二进制为 “11101001”<br>  <code>console.assert((225 | 0x08) == 0xE9);</code></li>
</ul>
</li>
<li><p>按位取反 “~”</p>
</li>
<li><p>按位异或 “^”</p>
<ul>
<li>将指定位的值取反<br>  将十进制整数 “225”（转换成二进制为 “11100001”）的第七位取反，结果应为十进制整数 “161”（转换成二进制为 “10100001”<br>  <code>console.assert((225 ^ 0x40) == 0xA1);</code></li>
<li>不引入第三个变量，交换两个变量的值  <pre><code class="javascript">var arg1 = 12, arg2 = 35;
arg1 = arg1 ^ arg2;
arg2 = arg1 ^ arg2;
arg1 = arg1 ^ arg2;
console.assert(arg1 == 35);
console.assert(arg2 == 12);
</code></pre>
</li>
</ul>
</li>
<li><p>左移运算符 “&lt;&lt;”</p>
<ul>
<li>把运算符左边的运算数的各二进位全部左移 n 位，实现运算数乘以 2 的 n 次方<br>  将十进制整数 “225”（转换成二进制为 “00000000 11100001”）左移两位，结果应为十进制整数 “900”（转换成二进制为 “00000011 10000100”）<br>  <code>console.assert((225 &lt;&lt; 2) == 0x0384);</code></li>
</ul>
</li>
<li><p>右移运算符 “&gt;&gt;”</p>
<ul>
<li>把运算符左边的运算数的各二进位全部右移 n 位，实现运算数除以 2 的 n 次方<br>  将十进制整数 “225”（转换成二进制为 “11100001”）右移两位，结果应为十进制整数 “56”（转换成二进制为 “00111000”）<br>  <code>console.assert((225 &gt;&gt; 2) == 0x38);</code></li>
</ul>
</li>
<li><p>无符号右移 “&gt;&gt;&gt;”</p>
<ul>
<li>把运算符左边的运算数的各二进位全部右移 n 位，忽略符号位，空位都以 0 补齐</li>
</ul>
</li>
<li><p>其他</p>
<pre><code class="javascript">var x, y;

// 判断奇偶数
x &amp; 1 == 1

// 交换两个数
x = x ^ y; y = x ^ y; x = x ^ y;

// 两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身

// 将最右边的 1 设置为 0
x &amp; (x - 1)

// x 取反再与 x 相加，相当于把所有二进制位设为 1，其十进制结果为 -1
x + (~x) == -1

// 对于 int32 而言，使用 n &gt;&gt; 31 取得 n 的正负号。并且可以通过 (n ^ (n &gt;&gt; 31)) - (n &gt;&gt; 31) 来得到绝对值。（n 为正，n &gt;&gt; 31 的所有位等于 0。若 n 为负数，n &gt;&gt; 31 的所有位等于 1，其值等于 -1）

// 使用 (x ^ y) &gt;= 0 来判断符号是否相同。（如果两个数都是正数，则二进制的第一位均为 0，x ^ y = 0；如果两个数都是负数，则二进制的第一位均为 1；x ^ y = 0 如果两个数符号相反，则二进制的第一位相反，x ^ y = 1。有 0 的情况例外，^ 相同得 0，不同得 1）

// 异或是一个无进位加法，说白了就是把进位砍掉。比如 01 ^ 01 = 00

// 与可以用来获取进位，比如 01 &amp; 01 = 01，然后再把结果左移一位，就可以获取进位结果
</code></pre>
</li>
</ul>
</li>
<li><p><a href="http://www.cnblogs.com/tntboom/p/4096036.html">求平方根的倒数（出自《雷神之锤3》源码）</a></p>
<pre><code class="c">float Q_rsqrt( float number )
&#123;
    long i;
    float x2, y;
    const float threehalfs = 1.5F;

    x2 = number * 0.5F;
    y  = number;
    i  = * ( long * ) &amp;y;   // 将浮点数转化为整数
    i  = 0x5f3759df - ( i &gt;&gt; 1 );
    y  = * ( float * ) &amp;i;  // 将 i 表示成浮点数
    y  = y * ( threehalfs - ( x2 * y * y ) );   // 一次牛顿迭代
    // y  = y * ( threehalfs - ( x2 * y * y ) );   // 二次牛顿迭代，可以提升结果的精度

    return y;
&#125;
</code></pre>
</li>
<li><p>斐波拉契数列</p>
<ul>
<li><p>动态规划</p>
<pre><code class="javascript">(function (n) &#123;
    let dp = new Array(n &lt; 2 ? 2 : n);
    dp[0] = 1;
    dp[1] = 1;

    for (let i = 2; i &lt; n; i++) &#123;
        dp[i] = dp[i - 1] + dp[i - 2];
    &#125;

    return dp[n - 1];
&#125;)(50);
</code></pre>
</li>
<li><p><a href="https://www.cnblogs.com/iwiniwin/p/10798884.html">矩阵快速幂</a></p>
<pre><code class="javascript">(function (n) &#123;
    /**
    * 2x2 矩阵乘法
    * @param m 
    * @param n 
    */
    const matrix_dot = function (m, n) &#123;
        return [
            [m[0][0] * n[0][0] + m[0][1] * n[1][0], m[0][0] * n[0][1] + m[0][1] * n[1][1]],
            [m[1][0] * n[0][0] + m[1][1] * n[1][0], m[1][0] * n[0][1] + m[1][1] * n[1][1]]
        ];
    &#125;;
    /**
    * 矩阵快速幂
    * @param m 
    * @param n 
    */
    const matrix_pow = function (m, n) &#123;
        let ret = [
            [1, 0],
            [0, 1]
        ]; // 单位矩阵，作用相当于整数乘法中的 1
        while (n &gt; 0) &#123;
            if ((n &amp; 1) &gt; 0) &#123;
                ret = matrix_dot(m, ret);
            &#125;
            m = matrix_dot(m, m);
            n &gt;&gt;= 1;
        &#125;
        return ret;
    &#125;;

    let matrix = [
        [1, 1],
        [1, 0]
    ];

    // 这里的 F1 和 F0 矩阵多加了一列 0,0，不会影响最终结果，是因为 matrix_mul 只实现了 2*2 矩阵的乘法
    let unit = [
        [1, 0],
        [0, 0]
    ];
    let ret = matrix_dot(matrix_pow(matrix, n - 1), unit);
    return ret[0][0];
&#125;)(50);
</code></pre>
<p>  $$ \begin{bmatrix} f(n) \\ f(n - 1) \end{bmatrix} = \begin{bmatrix} f(n - 1) + f(n - 2) \\ f(n - 1) \end{bmatrix} = \begin{bmatrix} f(n - 1) * 1 + f(n - 2) * 1 \\ f(n - 1) * 1 + f(n - 2) * 0 \end{bmatrix} = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} \begin{bmatrix} f(n - 1) \\ f(n - 2) \end{bmatrix} = \begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} ^{n - 1} \begin{bmatrix} f(1) \\ f(0) \end{bmatrix} $$</p>
</li>
</ul>
</li>
<li><p>矩阵运算</p>
<ul>
<li><p>点乘</p>
<pre><code class="javascript">const matrix_dot = function (m, n) &#123;
    console.assert(m instanceof Array &amp;&amp; m[0] instanceof Array 
        &amp;&amp; n instanceof Array &amp;&amp; n[0] instanceof Array
        &amp;&amp; m.length == n[0].length &amp;&amp; m[0].length == n.length);

    let ret = new Array(m.length);
    for (let i = 0; i &lt; m.length; i++) &#123;
        let j = n[0].length;
        ret[i] = new Array(j);
        while (j--) &#123;
            ret[i][j] = 0;
        &#125;
    &#125;

    for (let x = 0; x &lt; m.length; x++) &#123;
        for (let y = 0; y &lt; n[0].length; y++) &#123;
            for (let k = 0; k &lt; m[0].length; k++) &#123;
                ret[x][y] += m[x][k] * n[k][y];
            &#125;
        &#125;
    &#125;

    return ret;
&#125;;

console.info(matrix_dot([
    [1, 2, 3],
    [4, 5, 6]
], [
    [1, 2],
    [3, 4],
    [5, 6]
])); // [[22, 28], [49, 64]]
</code></pre>
</li>
</ul>
</li>
<li><p>排列组合</p>
<pre><code class="javascript">/**
 * 排列
 */
const permutation = function (arr, str = &quot;&quot;, res = []) &#123;
    if (str.length === arr.length) &#123;
        res.push(str);
    &#125; else &#123;
        for (let i = 0; i &lt; arr.length; i++) &#123;
            if (str.indexOf(arr[i]) === -1) &#123;
                permutation(arr, str + arr[i], res);
            &#125;
        &#125;
    &#125;
    return res;
&#125;;

/**
 * 组合
 */
const combination = function (arr) &#123;
    let res = [];
    let count = 1 &lt;&lt; arr.length; // 全组合的个数为 2^n
    for (let i = 0; i &lt; count; i++) &#123;
        let str = &quot;&quot;;
        for (let j = 0; j &lt; arr.length; j++) &#123;
            if (((1 &lt;&lt; j) &amp; i) != 0) &#123;
                str += arr[j];
            &#125;
        &#125;
        res.push(str);
    &#125;
    return res;
&#125;;

let arr = &quot;abc&quot;.split(&quot;&quot;);
console.info(&quot;permutation of&quot;, arr, &quot;is&quot;, permutation(arr)); // [&quot;abc&quot;, &quot;acb&quot;, &quot;bac&quot;, &quot;bca&quot;, &quot;cab&quot;, &quot;cba&quot;]
console.info(&quot;combination of&quot;, arr, &quot;is&quot;, combination(arr)); // [&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;ab&quot;, &quot;c&quot;, &quot;ac&quot;, &quot;bc&quot;, &quot;abc&quot;]
</code></pre>
</li>
<li><p>进制转换</p>
<pre><code class="javascript">const CHARSET = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.split(&quot;&quot;);
const str = function (n) &#123;
    let radix = CHARSET.length,
        qutient = +n,
        arr = [];
    do &#123;
        mod = qutient % radix;
        qutient = (qutient - mod) / radix;
        arr.unshift(CHARSET[mod]);
    &#125; while (qutient);
    return arr.join(&quot;&quot;);
&#125;
const int = function (s) &#123;
    s = String(s);
    let radix = CHARSET.length,
        len = s.length,
        i = 0,
        n = 0;
    while (i &lt; len) &#123;
        n += Math.pow(radix, i++) * CHARSET.indexOf(s.charAt(len - i) || 0);
    &#125;
    return n;
&#125;
console.info(str(9999999)); // &quot;FXsj&quot;
console.info(int(&quot;FXsj&quot;)); // 9999999
</code></pre>
</li>
<li><p>最大公约数</p>
<pre><code class="javascript">function gcd(a, b) &#123; 
    if (b == 0) 
        return a; 
    return gcd(b, a % b); 
&#125;
</code></pre>
</li>
<li><p><a href="https://www.cnblogs.com/812-xiao-wen/p/10543023.html">快速乘</a></p>
<pre><code class="cpp">inline ll ksc(ll x, ll y, ll p) &#123;
    ll z = (ld)x / p * y;
    ll res = (ull)x * y - (ull)z * p;
    return (res + p) % p;
&#125;
// ll 表示 long long
// ld 表示 long double
// ull 表示 unsigned long long
// 一种自动溢出的数据类型（存满了就会自动变为 0）
</code></pre>
</li>
<li><p>B+ 树</p>
</li>
<li><p>贪心算法</p>
</li>
<li><p>卷积神经网络</p>
</li>
<li><p>迪杰斯特拉</p>
</li>
<li><p>盲水印</p>
</li>
<li><p>布隆过滤器</p>
<pre><code class="typescript">/**
 * 字节，8 位、有符号的，以二进制补码表示的整数
 */
export declare type byte = number;

/**
 * 布隆过滤器
 *
 * @see https://developer.aliyun.com/article/3607
 */
export class BloomFilter &#123;
    /**
     * 布隆过滤器位图映射变量
     */
    private bitMap: byte[];

    /**
     * 位图变量的长度
     */
    private bitSize: number;

    /**
     * 哈希数量
     */
    private hashCount: number;

    /**
     * 已加入元素数量
     */
    private keyCount: number;

    /**
     * Bloom Filter
     *
     * @param maxKeys 最多可放的数量
     * @param errorRate 错误率
     */
    constructor(maxKeys, errorRate) &#123;
        this.bitMap = [];
        this.bitSize = Math.ceil(maxKeys * (-Math.log(errorRate) / (Math.log(2) * Math.log(2)))); // 需要根据 maxKeys 和 errorRate 来计算
        this.hashCount = Math.ceil(Math.log(2) * (this.bitSize / maxKeys));
        this.keyCount = 0;
    &#125;

    /**
     * 新增
     *
     * @param key
     */
    public add(key) &#123;
        if (this.contain(key)) &#123;
            return -1;
        &#125;

        let hash1 = this.murmurhash(key, 0, 0),
            hash2 = this.murmurhash(key, 0, hash1);

        for (let i = 0; i &lt; this.hashCount; i++) &#123;
            // 设置位
            let bit = Math.abs(Math.floor((hash1 + i * hash2) % (this.bitSize)));
            let numArr = Math.floor(bit / 31),
            numBit = Math.floor(bit % 31);
            this.bitMap[numArr] |= (1 &lt;&lt; numBit);
        &#125;

        this.keyCount++;
    &#125;

    /**
     * 判断是否存在
     *
     * @param key
     */
    public contain(key): boolean &#123;
        let hash1 = this.murmurhash(key, 0, 0),
            hash2 = this.murmurhash(key, 0, hash1);

        for (let i = 0; i &lt; this.hashCount; i++) &#123;
            // 读取位
            let bit = Math.abs(Math.floor((hash1 + i * hash2) % (this.bitSize)));
            let numArr = Math.floor(bit / 31),
            numBit = Math.floor(bit % 31);
            if (!(this.bitMap[numArr] &amp;= (1 &lt;&lt; numBit))) &#123;
                return false;
            &#125;
        &#125;

        return true;
    &#125;

    /**
     * Murmur Hash
     * 
     * @param data 待哈希的值
     * @param offset
     * @param seed 种子集
     * @see http://murmurhash.googlepages.com/
     */
    private murmurhash(data: string, offset: number = 0, seed: number = 0): number &#123;
        let len = data.length,
            m = 0x5bd1e995,
            r = 24,
            h = seed ^ len,
            len_4 = len &gt;&gt; 2;

        for (let i = 0; i &lt; len_4; i++) &#123;
            let i_4 = (i &lt;&lt; 2) + offset,
                k = data.charCodeAt(i_4 + 3);

            k = k &lt;&lt; 8;
            k = k | (data.charCodeAt(i_4 + 2) &amp; 0xff);
            k = k &lt;&lt; 8;
            k = k | (data.charCodeAt(i_4 + 1) &amp; 0xff);
            k = k &lt;&lt; 8;
            k = k | (data.charCodeAt(i_4 + 0) &amp; 0xff);
            k *= m;
            k ^= k &gt;&gt;&gt; r;
            k *= m;
            h *= m;
            h ^= k;
        &#125;

        // avoid calculating modulo  
        let len_m = len_4 &lt;&lt; 2,
            left = len - len_m,
            i_m = len_m + offset;

        if (left != 0) &#123;
            if (left &gt;= 3) &#123;
                h ^= data.charCodeAt(i_m + 2) &lt;&lt; 16;
            &#125;
            if (left &gt;= 2) &#123;
                h ^= data.charCodeAt(i_m + 1) &lt;&lt; 8;
            &#125;
            if (left &gt;= 1) &#123;
                h ^= data.charCodeAt(i_m);
            &#125;

            h *= m;
        &#125;

        h ^= h &gt;&gt;&gt; 13;
        h *= m;
        h ^= h &gt;&gt;&gt; 15;

        return h;
    &#125;
&#125;

(() =&gt; &#123;
    let bf = new BloomFilter(100000000, 0.01);
    bf.add(&quot;hello, world&quot;);
    console.assert(bf.contain(&quot;hello, world&quot;));
&#125;)();
</code></pre>
</li>
<li><p>位图索引/Bitmap<br>  有 40 亿个不重复的无序的无符号整数，现给出一个无符号整数，如何快速判断这个数是否在这 40 亿个数中</p>
<pre><code>class Bitmap &#123;
    bytes = null;

    constructor(length) &#123;
        this.bytes = new Uint8Array((length &gt;&gt;&gt; 3) + 1);
    &#125;

    add(num) &#123;
        this.bytes[num &gt;&gt;&gt; 3] |= 1 &lt;&lt; num % 0x7;
    &#125;

    exist(num) &#123;
        return (this.bytes[num &gt;&gt;&gt; 3] &amp; 1 &lt;&lt; num % 0x7) != 0;
    &#125;

    remove(num) &#123;
        this.bytes[num &gt;&gt;&gt; 3] &amp;= ~(1 &lt;&lt; num % 0x7);
    &#125;
&#125;

let bitmap = new Bitmap(100);
bitmap.add(99);
bitmap.exist(99); // true
bitmap.remove(99);
bitmap.exist(99); // false
</code></pre>
</li>
<li><p>字符串匹配算法</p>
<ul>
<li><p>编辑距离（动态规划）</p>
<pre><code class="javascript">(function (a, b) &#123;
    let m = a.length,
        n = b.length;
    let dp = new Array(m + 1).fill(&quot;&quot;).map(d =&gt; new Array(n + 1).fill(0));
    for (let i = 1; i &lt; m + 1; i++) &#123;
        dp[i][0] = i;
    &#125;
    for (let j = 1; j &lt; n + 1; j++) &#123;
        dp[0][j] = j;
    &#125;
    for (let i = 1; i &lt; m + 1; i++) &#123;
        for (let j = 1; j &lt; n + 1; j++) &#123;
            if (a.charAt(i - 1) == b.charAt(j - 1)) &#123;
                dp[i][j] = dp[i - 1][j - 1];
            &#125; else &#123;
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
            &#125;
        &#125;
    &#125;
    return dp[m][n];
&#125;)(&quot;hello&quot;, &quot;hollow&quot;); // 2
</code></pre>
</li>
<li><p>余弦相似度</p>
<pre><code class="javascript">const CosineSimilarity = &#123;
    token: function (text) &#123; // 分词
        return text.split(/[^A-Za-z0-9]+/).map(word =&gt; &#123;
            return word.toLowerCase();
        &#125;);
    &#125;,
    frequence: function (words, dict) &#123; // 计算词频
        return dict.map(word =&gt; &#123;
            return words.reduce((f, element) =&gt; &#123;
                if (element == word)
                    return f += 1;
                else 
                    return f += 0;
            &#125;, 0);
        &#125;);
    &#125;,
    dot: function (a, b) &#123; // 计算向量点乘
        return a.reduce((sum, f, index) =&gt; &#123;
            return sum += (f * b[index]);
        &#125;, 0);
    &#125;,
    norm: function (vector) &#123; // 计算向量的模
        return Math.sqrt(vector.reduce((sum, f) =&gt; &#123;
            return sum += (f * f);
        &#125;, 0));
    &#125;,
    compare: function (a, b) &#123;
        let aw = this.token(a),
            bw = this.token(b);
    
        let dict = aw.concat(bw.filter(v =&gt; !aw.includes(v))); // 取 a, b 词的并集
    
        let av = this.frequence(aw, dict),
            bv = this.frequence(bw, dict);
    
        return this.dot(av, bv) / (this.norm(av) * this.norm(bv));
    &#125;
&#125;;

CosineSimilarity.compare(&quot;Julie loves me more than Linda loves me&quot;, &quot;Jane likes me more than Julie loves me&quot;); // 0.9302605094190635
</code></pre>
</li>
<li><p>Simhash</p>
</li>
</ul>
</li>
<li><p>排序算法</p>
<ul>
<li><p><a href="https://www.geeksforgeeks.org/quick-sort/">快速排序</a></p>
<pre><code class="javascript">(function (arr) &#123;
    const swap = function (nums, a, b) &#123;
        const temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    &#125;;
    const partition = function (arr, low, high) &#123;
        let pivot = arr[high], // pivot (Element to be placed at right position)
            i = low - 1; // Index of smaller element and indicates the right position of pivot found so far

        for (j = low; j &lt;= high- 1; j++) &#123;
            // If current element is smaller than the pivot
            if (arr[j] &lt; pivot) &#123;
                i++; // increment index of smaller element
                swap(arr, i, j);
            &#125;
        &#125;
        swap(arr, i + 1, high);
        return i + 1;
    &#125;;
    const sort = function (arr, low, high) &#123;
        if (low &lt; high) &#123;
            let pi = partition(arr, low, high); // pi is partitioning index, arr[pi] is now at right place
            sort(arr, low, pi - 1);  // before pi
            sort(arr, pi + 1, high); // after pi
        &#125;
        return arr;
    &#125;;
    return sort(arr, 0, arr.length - 1);
&#125;)([10, 80, 30, 90, 40, 50, 70]);
</code></pre>
<blockquote>
<p>时间复杂度：最好 O(nlog(n))，最差 O(n^2)，平均 O(nlog(n))</p>
</blockquote>
<ul>
<li>双基准快速排序</li>
</ul>
</li>
</ul>
</li>
<li><p>图片匹配算法</p>
<ul>
<li>感知哈希算法</li>
</ul>
</li>
<li><p>GeoHash</p>
<pre><code class="javascript">class GeoHash &#123;
    bits = [16, 8, 4, 2, 1];

    base32 = &quot;0123456789bcdefghjkmnpqrstuvwxyz&quot;;

    neighbors = &#123;
        right: &#123; even: &quot;bc01fg45238967deuvhjyznpkmstqrwx&quot; &#125;,
        left: &#123; even: &quot;238967debc01fg45kmstqrwxuvhjyznp&quot; &#125;,
        top: &#123; even: &quot;p0r21436x8zb9dcf5h7kjnmqesgutwvy&quot; &#125;,
        bottom: &#123; even: &quot;14365h7k9dcfesgujnmqp0r2twvyx8zb&quot; &#125;
    &#125;;

    borders = &#123;
        right: &#123; even: &quot;bcfguvyz&quot; &#125;,
        left: &#123; even: &quot;0145hjnp&quot; &#125;,
        top: &#123; even: &quot;prxz&quot; &#125;,
        bottom: &#123; even: &quot;028b&quot; &#125;
    &#125;;

    constructor() &#123;
        this.neighbors.bottom.odd = this.neighbors.left.even;
        this.neighbors.top.odd = this.neighbors.right.even;
        this.neighbors.left.odd = this.neighbors.bottom.even;
        this.neighbors.right.odd = this.neighbors.top.even;
        this.borders.bottom.odd = this.borders.left.even;
        this.borders.top.odd = this.borders.right.even;
        this.borders.left.odd = this.borders.bottom.even;
        this.borders.right.odd = this.borders.top.even;
    &#125;

    /**
     * 计算相邻
     * 
     * @param hash 
     * @param dir 
     * @returns 
     */
    adjacent(hash, dir) &#123;
        hash = hash.toLowerCase();
        var lastchr = hash.charAt(hash.length - 1);
        var type = (hash.length % 2) ? &quot;odd&quot; : &quot;even&quot;;
        var base = hash.substring(0, hash.length - 1);
        if (this.borders[dir][type].indexOf(lastchr) != -1)
            base = adjacent(base, dir);
        return base + this.base32[this.neighbors[dir][type].indexOf(lastchr)];
    &#125;

    /**
     * GeoHash 编码
     * 
     * @param latitude 
     * @param longitude 
     * @returns 
     */
    encode(latitude, longitude) &#123;
        var is_even = 1, // 是否是偶数
            lat = [-90.0, 90.0], lon = [-180.0, 180.0],
            bit = 0,
            ch = 0,
            precision = 12, // 精度，即 GeoHash 长度。这里为 12，误差为 ±0.0000186km
            hash = &quot;&quot;,
            mid = 0;

        while (hash.length &lt; precision) &#123;
            if (is_even) &#123;
                mid = (lon[0] + lon[1]) / 2;
                if (longitude &gt; mid) &#123;
                    ch |= this.bits[bit];
                    lon[0] = mid;
                &#125; else
                    lon[1] = mid;
            &#125; else &#123;
                mid = (lat[0] + lat[1]) / 2;
                if (latitude &gt; mid) &#123;
                    ch |= this.bits[bit];
                    lat[0] = mid;
                &#125; else
                    lat[1] = mid;
            &#125;

            is_even = !is_even;
            if (bit &lt; 4)
                bit++;
            else &#123;
                hash += this.base32[ch];
                bit = 0;
                ch = 0;
            &#125;
        &#125;
        return hash;
    &#125;

    /**
     * GeoHash 解码
     * 
     * @param hash 
     * @returns 
     */
    decode(hash) &#123;
        var is_even = 1,
            lat = [-90.0, 90.0], lon = [-180.0, 180.0],
            lat_err = 90.0, lon_err = 180.0;

        const refine_interval = function (interval, cd, mask) &#123;
            if (cd &amp; mask)
                interval[0] = (interval[0] + interval[1]) / 2;
            else
                interval[1] = (interval[0] + interval[1]) / 2;
        &#125;;

        for (let i = 0; i &lt; hash.length; i++) &#123;
            let c = hash[i],
                cd = this.base32.indexOf(c);
            for (let j = 0; j &lt; 5; j++) &#123;
                let mask = this.bits[j];
                if (is_even) &#123;
                    lon_err /= 2;
                    refine_interval(lon, cd, mask);
                &#125; else &#123;
                    lat_err /= 2;
                    refine_interval(lat, cd, mask);
                &#125;
                is_even = !is_even;
            &#125;
        &#125;
        lat[2] = (lat[0] + lat[1]) / 2;
        lon[2] = (lon[0] + lon[1]) / 2;

        return &#123; latitude: lat, longitude: lon &#125;;
    &#125;
&#125;

var hasher = new GeoHash();
hasher.encode(30.589297, 114.293488); // wt3q0b9gx638
// hasher.adjacent(&quot;wt3q0b9gx638&quot;, &quot;left&quot;); // wt3q0b9gx632
</code></pre>
</li>
<li><p>随机生成密码</p>
<pre><code class="javascript">function randpwd(len) &#123;
    // let dic = [&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;0123456789&quot;, &quot;~!@#$%^&amp;*()-+&quot;],
    let dic = [&quot;ABCDEFGHJKLMNPQRSTUVWXYZ&quot;, &quot;abcdefghijkmnpqrstuvwxyz&quot;, &quot;23456789&quot;, &quot;~!@#$%^&amp;*()-+&quot;], // 去除容易混淆的字符：大写字母 IO、小写字母 lo、数字 01
        dics = dic.join(&quot;&quot;);

    let arr = dic.map(d =&gt; d.charAt(Math.random() * d.length));
    arr.sort((a, b) =&gt; 0.5 - Math.random());

    for (let i = dic.length; i &lt; len; i++) &#123;
        arr.push(dics.charAt(Math.random() * dics.length));
    &#125;

    return arr.join(&quot;&quot;).substr(0, len);
&#125;

console.info(randpwd(8));
</code></pre>
</li>
<li><p><a href="https://leetcode-cn.com/problems/valid-square/">给定二维空间中四点的坐标，返回四点是否可以构造一个正方形</a></p>
<pre><code class="javascript">(function (p1, p2, p3, p4) &#123;
    // 从一个点出发，到达另外三个点的的三个向量
    let side12 = [p2[0] - p1[0], p2[1] - p1[1]],
        side13 = [p3[0] - p1[0], p3[1] - p1[1]],
        side14 = [p4[0] - p1[0], p4[1] - p1[1]];

    // 三个向量的两两点积（内积）
    let dotProduct1213 = (side12[0] * side13[0]) + (side12[1] * side13[1]),
        dotProduct1214 = (side12[0] * side14[0]) + (side12[1] * side14[1]),
        dotProduct1314 = (side13[0] * side14[0]) + (side13[1] * side14[1]);

    // 1. 判断从一个点出发的三个向量的两两相乘有一个点积为零，其余两个则不为零（内积为 0 的两个向量垂直）
    if (((dotProduct1213 === 0) + (dotProduct1214 === 0) + (dotProduct1314 === 0)) !== 1) &#123;
        return false;
    &#125;

    // 三个向量的两两叉积的绝对值
    let corssProduct1213 = Math.abs((side12[0] * side13[1]) - (side13[0] * side12[1])),
        corssProduct1214 = Math.abs((side12[0] * side14[1]) - (side14[0] * side12[1])),
        corssProduct1314 = Math.abs((side13[0] * side14[1]) - (side14[0] * side13[1]));

    // 2. 判断三个叉积的绝对值是否两两相等
    if (corssProduct1213 != corssProduct1214 || corssProduct1213 != corssProduct1314 || corssProduct1214 != corssProduct1314) &#123;
        return false;
    &#125;

    // 3. 叉积绝对值乘以 2 是否等于点积和
    if ((dotProduct1213 + dotProduct1214 + dotProduct1314) != (corssProduct1213 &lt;&lt; 1)) &#123;
        return false;
    &#125;

    return true;
&#125;)([0, 0], [1, 2], [3, 1], [2, -1]);
</code></pre>
</li>
<li><p>抽象语法树</p>
<pre><code class="typescript">// 参考在线解析 https://astexplorer.net/

type Token = &#123;
    type: &quot;name&quot; | &quot;comma&quot; | &quot;number&quot; | &quot;paren&quot; | &quot;string&quot;;
    value: string;
&#125;

class AbstractSyntaxTree &#123;
    public tokenizer(input: string): Token[] &#123;
        const REG_NUMBER = /[0-9]/, REG_LETTER_NUMBER = /[`a-z0-9_\.]/i;

        let current = 0,
            tokens: Token[] = [];

        while (current &lt; input.length) &#123;
            let char = input[current];

            if (char === &quot;(&quot; || char === &quot;)&quot;) &#123;
                tokens.push(&#123; type: &quot;paren&quot;, value: char &#125;);
                current++;
                continue;
            &#125;

            if (char === &quot;,&quot;) &#123;
                tokens.push(&#123; type: &quot;comma&quot;, value: char &#125;);
                current++;
                continue;
            &#125;

            if (REG_NUMBER.test(char)) &#123;
                let value = &quot;&quot;;
                while (char &amp;&amp; REG_NUMBER.test(char)) &#123;
                    value += char;
                    char = input[++current];
                &#125;
                tokens.push(&#123; type: &quot;number&quot;, value &#125;);
                continue;
            &#125;

            if (REG_LETTER_NUMBER.test(char)) &#123;
                let value = &quot;&quot;;
                while (char &amp;&amp; REG_LETTER_NUMBER.test(char)) &#123;
                    value += char;
                    char = input[++current];
                &#125;
                tokens.push(&#123; type: &quot;name&quot;, value: value.replace(/`/g, &quot;&quot;) &#125;);
                continue;
            &#125;

            if (char === &quot;&#39;&quot; || char === &quot;\&quot;&quot;) &#123;
                let value = &quot;&quot;;
                let s = char;
                char = input[++current];
                while (char !== s) &#123;
                    value += char;
                    char = input[++current];
                    if (char === s &amp;&amp; input[current - 1] === &quot;\\&quot;) &#123;
                        value += char;
                        char = input[++current];
                    &#125;
                &#125;
                char = input[++current];
                tokens.push(&#123; type: &quot;string&quot;, value &#125;);
                continue;
            &#125;
            current++;
        &#125;
        return tokens;
    &#125;

    public parser(tokens: Token[]): any &#123;
        let current = 0,
            statement: any = &#123;&#125;;

        while (current &lt; tokens.length) &#123;
            let token = tokens[current];

            if (token.type === &quot;name&quot;) &#123;
                if (token.value.toUpperCase() === &quot;SELECT&quot;) &#123;
                    statement = &#123; variant: &quot;select&quot;, result: [] &#125;;
                &#125; else if (token.value.toUpperCase() === &quot;FROM&quot;) &#123;
                    statement.from = &#123;&#125;;
                &#125; else if (typeof token.type === &quot;string&quot; || typeof token.type === &quot;number&quot;) &#123;
                    if (statement.from) &#123;
                        statement.from = &#123;
                            type: &quot;identifier&quot;,
                            variant: &quot;table&quot;,
                            name: token.value
                        &#125;;
                    &#125; else if (statement.result) &#123;
                        statement.result.push(&#123;
                            type: &quot;identifier&quot;,
                            variant: &quot;column&quot;,
                            name: token.value
                        &#125;);
                    &#125;
                &#125;
            &#125;
            current++;
        &#125;

        return statement;
    &#125;

    public compile(statement: any): string &#123;
        if (statement.variant === &quot;select&quot;) &#123;
            return [&quot;select&quot;, statement.result.map(this.compile).join(&quot;, &quot;), &quot;from&quot;, this.compile(statement.from)].join(&quot; &quot;);
        &#125;
        if (statement.type === &quot;identifier&quot;) &#123;
            return statement.name + (statement.alias ? ` as $&#123;statement.alias&#125;` : &quot;&quot;);
        &#125;
        throw new Error(&quot;Unknown&quot;);
    &#125;
&#125;

let tree = new AbstractSyntaxTree();
let tokens = tree.tokenizer(
    &quot;select id, name from user&quot;
);
let ast = tree.parser(tokens);
ast.result.forEach((currentValue: any, index: number, arr: any[]) =&gt; &#123;
    currentValue.alias = currentValue.name;
    currentValue.name = &quot;data0.field&quot; + index;
&#125;);
ast.from.name = &quot;data0&quot;;
let sql = tree.compile(ast);
console.log(sql);
</code></pre>
</li>
<li><p>BPMN 工作流引擎</p>
<pre><code class="typescript">import &#123; DB &#125; from &quot;https://deno.land/x/sqlite@v3.3.0/mod.ts&quot;;
import &#123; xml2js &#125; from &quot;https://deno.land/x/xml2js/mod.ts&quot;;

class BusinessProcessModelingNotation &#123;
    private db: DB;

    private id: string;

    private name: string;

    private documentation: string;

    private activities: &#123; [id: string]: &#123; id: string; name: string; type: string &#125; &amp; any; &#125;;

    private startends: string[] = [&quot;&quot;, &quot;&quot;];

    private sequenceflows: &#123; id: string; sourceRef: string; targetRef: string; conditionExpression?: &#123; value: string; &#125;; &#125;[];

    constructor(content: string) &#123;
        // 解析 bpmn xml 文件
        let process = &lt;any&gt;(&lt;any&gt;xml2js(content.replace(/activiti:/g, &quot;&quot;), &#123; compact: true &#125;)).definitions.process;

        this.id = process._attributes.id;
        this.name = process._attributes.namel
        this.documentation = process.documentation._text;

        this.activities = (&lt;any[]&gt;[]).concat.apply([],
            Object.keys(process).filter(type =&gt; [
                &quot;startEvent&quot;, &quot;endEvent&quot;,
                &quot;parallelGateway&quot;, &quot;exclusiveGateway&quot;, &quot;inclusiveGateway&quot;, &quot;eventGateway&quot;,
                &quot;userTask&quot;, &quot;scriptTask&quot;
            ].indexOf(type) !== -1).map(type =&gt; &#123;
                if (type === &quot;startEvent&quot;) &#123;
                    this.startends[0] = process[type]._attributes.id;
                &#125;
                if (type === &quot;endEvent&quot;) &#123;
                    this.startends[1] = process[type]._attributes.id;
                &#125;
                return (process[type] instanceof Array ? &lt;any[]&gt;process[type] : [&lt;any&gt;process[type]]).map(e =&gt; &#123;
                    return &#123;
                        ...e._attributes,
                        type
                    &#125;;
                &#125;);
            &#125;)
        ).reduce((p, c) =&gt; &#123; p[c.id] = c; return p; &#125;, &#123;&#125;);

        this.sequenceflows = (&lt;any[]&gt;process.sequenceFlow).map((&#123; _attributes, conditionExpression &#125;) =&gt; &#123;
            return &#123;
                ..._attributes,
                ...(conditionExpression &amp;&amp; &#123;
                    conditionExpression: &#123;
                        value: conditionExpression._cdata
                    &#125;
                &#125;)
            &#125;;
        &#125;);

        // 创建数据库连接
        this.db = new DB(&quot;bpmn.db&quot;);
        // 初始化数据库表
        this.db.execute(`
            create table if not exists process_instance (
                id integer primary key autoincrement,
                process_id text not null,
                status text not null default (&#39;Processing&#39;),
                variables text
            );
            create table if not exists process_activity_instance (
                id integer primary key autoincrement,
                activity_id text not null,
                process_instance_id integer not null,
                assignee text,
                user text,
                start_time integer not null,
                end_time integer
            );
        `);
    &#125;

    public start(variables: object): number &#123;
        // 保存流程实例
        this.db.query(&quot;insert into process_instance (process_id, variables) values (?, ?)&quot;, [
            this.id,
            JSON.stringify(variables)
        ]);
        let process_instance_id = this.db.lastInsertRowId;
        
        // 发起流程活动
        this.onCreateTask(this.startends[0], process_instance_id, variables);

        return process_instance_id;
    &#125;

    public tasks(assignee: string) &#123;
        return this.db.queryEntries&lt;&#123; id: number, activity_id: string, process_instance_id: number, assignee: string, user: string, start_time: number, end_time: number &#125;&gt;(&quot;select * from process_activity_instance where assignee = ? and end_time is null&quot;, [assignee]);
    &#125;

    public complete(process_activity_instance_id: number) &#123;
        let process_activity_instance = &lt;&#123; activity_id: string; process_instance_id: number; &#125;&gt;this.db.queryEntries&lt;&#123; activity_id: string, process_instance_id: number &#125;&gt;(&quot;select activity_id, process_instance_id from process_activity_instance where id = ?&quot;, [process_activity_instance_id]).pop();
        if (process_activity_instance == null) &#123;
            throw new Error(&quot;Task is not found.&quot;);
        &#125;

        let process_instance = &lt;&#123; id: number; variables: string; &#125;&gt;this.db.queryEntries&lt;&#123; id: number, variables: string &#125;&gt;(&quot;select id, variables from process_instance where id = ?&quot;, [process_activity_instance.process_instance_id]).pop();

        // 保存活动实例
        this.db.query(&quot;update process_activity_instance set end_time = ? where id = ?&quot;, [new Date().getTime(), process_activity_instance_id]);

        let variables = &lt;object&gt;JSON.parse(process_instance.variables);

        // 查找并执行下一步活动（集合）
        this.sequenceflows.filter(f =&gt; f.sourceRef === process_activity_instance.activity_id).map(f =&gt; f.targetRef).forEach(id =&gt; &#123;
            this.onCreateTask(id, process_instance.id, variables);
        &#125;);
    &#125;

    public history(process_instance_id: number) &#123;
        return this.db.queryEntries&lt;&#123; id: number, activity_id: string, process_instance_id: number, assignee: string, user: string, start_time: number, end_time: number &#125;&gt;(&quot;select * from process_activity_instance where process_instance_id = ? order by start_time desc&quot;, [process_instance_id]);
    &#125;

    /**
     * 发起流程活动
     */
    private onCreateTask(activity_id: string, process_instance_id: number, variables: object) &#123;
        let activity = this.activities[activity_id];
        if (activity == null) &#123;
            throw new Error(&quot;Can not find the activity.&quot;);
        &#125;

        switch (activity?.type) &#123;
            case &quot;startEvent&quot;: // 开始事件
                this.sequenceflows.filter(f =&gt; f.sourceRef === activity_id).map(f =&gt; f.targetRef).forEach(id =&gt; &#123;
                    this.onCreateTask(id, process_instance_id, variables);
                &#125;);
                break;
            case &quot;endEvent&quot;: // 结束事件
                this.db.query(&quot;update process_instance set status = &#39;Completed&#39; where id = ?&quot;, [process_instance_id]);
                break;
            case &quot;userTask&quot;: // 用户任务
                // 保存活动实例
                this.db.query(&quot;insert into process_activity_instance (activity_id, process_instance_id, assignee, start_time) values (?, ?, ?, ?)&quot;, [
                    activity_id,
                    process_instance_id,
                    this.resolve(variables, activity.assignee),
                    new Date().getTime()
                ]);
                break;
            case &quot;exclusiveGateway&quot;: // 排他网关
                this.sequenceflows.filter(f =&gt; f.sourceRef === activity_id)
                    .filter(f =&gt; this.resolve(variables, f?.conditionExpression?.value) === &quot;true&quot;) // 计算排他网关上的条件表达式
                    .forEach(f =&gt; this.onCreateTask(f.targetRef, process_instance_id, variables));
                break;
            case &quot;parallelGateway&quot;: // 平行网关
                // 如果上一步有并行执行的活动，需要等待这些活动同时执行结束后才能触发
                let &#123; unfinished_tasks_count &#125; = &lt;&#123; unfinished_tasks_count: number &#125;&gt;this.db.queryEntries(`select count(id) as unfinished_tasks_count from process_activity_instance where process_instance_id = ? and activity_id in (&#39;$&#123;this.sequenceflows.filter(f =&gt; f.targetRef === activity_id).map(f =&gt; f.sourceRef).join(&quot;&#39;, &#39;&quot;)&#125;&#39;) and end_time is null`, [process_instance_id]).pop();
                if (unfinished_tasks_count === 0) &#123;
                    this.sequenceflows.filter(f =&gt; f.sourceRef === activity_id)
                        .forEach(f =&gt; this.onCreateTask(f.targetRef, process_instance_id, variables));
                &#125;
                break;
            default:
                throw new Error(`The $&#123;activity?.type&#125; is not implemented.`);
        &#125;
    &#125;

    /**
     * 解析表达式
     */
    private resolve(variables: object, expression: string = &quot;&quot;): string &#123;
        return eval(&quot;`&quot; + Object.keys(variables).reduce((p, c) =&gt; &#123; p = p.replace(c, &quot;variables.&quot; + c); return p; &#125;, expression) + &quot;`&quot;);
    &#125;
&#125;

const expense = `&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;definitions
    xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
    xmlns:activiti=&quot;http://activiti.org/bpmn&quot;
    xmlns:bpmndi=&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;
    xmlns:omgdc=&quot;http://www.omg.org/spec/DD/20100524/DC&quot;
    xmlns:omgdi=&quot;http://www.omg.org/spec/DD/20100524/DI&quot;
    typeLanguage=&quot;http://www.w3.org/2001/XMLSchema&quot;
    expressionLanguage=&quot;http://www.w3.org/1999/XPath&quot;
    targetNamespace=&quot;http://www.activiti.org/test&quot;&gt;
    
    &lt;process id=&quot;expense&quot; name=&quot;expense&quot; isExecutable=&quot;true&quot;&gt;
        &lt;documentation&gt;报销流程&lt;/documentation&gt;
        &lt;startEvent id=&quot;startevent1&quot; name=&quot;Start&quot;&gt;&lt;/startEvent&gt;
        &lt;userTask id=&quot;usertask1&quot; name=&quot;填写报销单&quot; activiti:assignee=&quot;\$&#123;expense.username&#125;&quot;&gt;&lt;/userTask&gt;
        &lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;startevent1&quot; targetRef=&quot;usertask1&quot;&gt;&lt;/sequenceFlow&gt;
        &lt;userTask id=&quot;usertask2&quot; name=&quot;部门经理审批&quot; activiti:assignee=&quot;\$&#123;deptManager&#125;&quot;&gt;&lt;/userTask&gt;
        &lt;sequenceFlow id=&quot;flow2&quot; sourceRef=&quot;usertask1&quot; targetRef=&quot;usertask2&quot;&gt;&lt;/sequenceFlow&gt;
        &lt;exclusiveGateway id=&quot;exclusivegateway2&quot; name=&quot;Exclusive Gateway&quot;&gt;&lt;/exclusiveGateway&gt;
        &lt;sequenceFlow id=&quot;flow3&quot; sourceRef=&quot;usertask2&quot; targetRef=&quot;exclusivegateway2&quot;&gt;&lt;/sequenceFlow&gt;
        &lt;userTask id=&quot;usertask3&quot; name=&quot;人事审批&quot; activiti:assignee=&quot;\$&#123;cho&#125;&quot;&gt;&lt;/userTask&gt;
        &lt;sequenceFlow id=&quot;flow6&quot; sourceRef=&quot;exclusivegateway2&quot; targetRef=&quot;usertask3&quot;&gt;
            &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;&lt;![CDATA[\$&#123;expense.amount &lt;= 500&#125;]]&gt;&lt;/conditionExpression&gt;
        &lt;/sequenceFlow&gt;
        &lt;userTask id=&quot;usertask4&quot; name=&quot;总经理审批&quot; activiti:assignee=&quot;\$&#123;ceo&#125;&quot;&gt;&lt;/userTask&gt;
        &lt;sequenceFlow id=&quot;flow8&quot; sourceRef=&quot;usertask4&quot; targetRef=&quot;usertask3&quot;&gt;&lt;/sequenceFlow&gt;
        &lt;sequenceFlow id=&quot;flow10&quot; sourceRef=&quot;exclusivegateway2&quot; targetRef=&quot;usertask4&quot;&gt;
            &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;&lt;![CDATA[\$&#123;expense.amount &gt; 500&#125;]]&gt;&lt;/conditionExpression&gt;
        &lt;/sequenceFlow&gt;
        &lt;userTask id=&quot;usertask5&quot; name=&quot;打印申请单&quot; activiti:assignee=&quot;zhangsan&quot;&gt;&lt;/userTask&gt;
        &lt;userTask id=&quot;usertask6&quot; name=&quot;粘贴发票&quot; activiti:assignee=&quot;lisi&quot;&gt;&lt;/userTask&gt;
        &lt;parallelGateway id=&quot;parallelgateway1&quot; name=&quot;Parallel Gateway&quot;&gt;&lt;/parallelGateway&gt;
        &lt;sequenceFlow id=&quot;flow11&quot; sourceRef=&quot;usertask3&quot; targetRef=&quot;parallelgateway1&quot;&gt;&lt;/sequenceFlow&gt;
        &lt;sequenceFlow id=&quot;flow12&quot; sourceRef=&quot;parallelgateway1&quot; targetRef=&quot;usertask5&quot;&gt;&lt;/sequenceFlow&gt;
        &lt;sequenceFlow id=&quot;flow13&quot; sourceRef=&quot;parallelgateway1&quot; targetRef=&quot;usertask6&quot;&gt;&lt;/sequenceFlow&gt;
        &lt;parallelGateway id=&quot;parallelgateway2&quot; name=&quot;Parallel Gateway&quot;&gt;&lt;/parallelGateway&gt;
        &lt;sequenceFlow id=&quot;flow15&quot; sourceRef=&quot;usertask5&quot; targetRef=&quot;parallelgateway2&quot;&gt;&lt;/sequenceFlow&gt;
        &lt;sequenceFlow id=&quot;flow16&quot; sourceRef=&quot;usertask6&quot; targetRef=&quot;parallelgateway2&quot;&gt;&lt;/sequenceFlow&gt;
        &lt;userTask id=&quot;usertask7&quot; name=&quot;财务打款&quot; activiti:assignee=&quot;\$&#123;cfo&#125;&quot;&gt;&lt;/userTask&gt;
        &lt;sequenceFlow id=&quot;flow17&quot; sourceRef=&quot;parallelgateway2&quot; targetRef=&quot;usertask7&quot;&gt;&lt;/sequenceFlow&gt;
        &lt;endEvent id=&quot;endevent1&quot; name=&quot;End&quot;&gt;&lt;/endEvent&gt;
        &lt;sequenceFlow id=&quot;flow18&quot; sourceRef=&quot;usertask7&quot; targetRef=&quot;endevent1&quot;&gt;&lt;/sequenceFlow&gt;
    &lt;/process&gt;
&lt;/definitions&gt;`;
let bpmn = new BusinessProcessModelingNotation(expense); // 在线设计 https://bpmn.io/
let process_instance_id = bpmn.start(&#123;
    expense: &#123;
        username: &quot;luffy&quot;,
        amount: 100
    &#125;,
    deptManager: &quot;tom&quot;,
    ceo: &quot;jerry&quot;,
    cho: &quot;rose&quot;,
    cfo: &quot;jack&quot;
&#125;);
let task = bpmn.tasks(&quot;luffy&quot;).pop();
bpmn.complete(task?.id || 0);
task = bpmn.tasks(&quot;tom&quot;).pop();
bpmn.complete(task?.id || 0);
task = bpmn.tasks(&quot;rose&quot;).pop();
bpmn.complete(task?.id || 0);
task = bpmn.tasks(&quot;zhangsan&quot;).pop();
bpmn.complete(task?.id || 0);
task = bpmn.tasks(&quot;lisi&quot;).pop();
bpmn.complete(task?.id || 0);
task = bpmn.tasks(&quot;jack&quot;).pop();
bpmn.complete(task?.id || 0);
console.log(bpmn.history(process_instance_id));
</code></pre>
</li>
</ul>
<h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><ul>
<li><p>香农熵（信息熵）<br>  对于任意一个随机变量 X（比如得冠军的球队），它的熵定义如下：变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。  </p>
  <!-- ![](https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D220/sign=b531b5c5277f9e2f74351a0a2f31e962/0b46f21fbe096b63e29e59730c338744ebf8ac09.jpg)   -->
<p>  $$ H(x)=-\sum_{x}P(x)log_2[P(x)] $$</p>
<blockquote>
<p>P(x) 表示随机变量某个取值的概率</p>
</blockquote>
</li>
<li><p>凯利公式</p>
</li>
<li><p>圆周率</p>
<ul>
<li><a href="https://www.mk2048.com/blog/blog_h1c0k0ikkkk0j.html">使用泰勒级数公式计算圆周率</a><pre><code class="javascript">(function (num) &#123;
    let i = 1n,
        x = 3n * (10n ** (20n + num)),
        p = x;
    while (x &gt; 0) &#123;
        x = x * i / ((i + 1n) * 4n);
        p += x / (i + 2n);
        i += 2n;
    &#125;
    return p / (10n ** 20n);
&#125;)(1000n); // 计算包含 1000 位小数的圆周率：31415926...1989n
</code></pre>
</li>
<li>使用贝拉公式（衍生自 BBP 公式）计算圆周率 π 的第 n 位数</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2025/03/22/css/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h2><ul>
<li><p>故障风格按钮</p>
<pre><code class="html">&lt;button&gt;立即加入&lt;/button&gt;
</code></pre>
<pre><code class="css">button, button::after &#123;
    width: 300px;
    height: 86px;
    font-size: 40px;
    background: linear-gradient(45deg, transparent 5%, #FF013C 5%);
    border: 0;
    color: #fff;
    letter-spacing: 3px;
    line-height: 88px;
    box-shadow: 6px 0px 0px #00E6F6;
    outline: transparent;
    position: relative;
&#125;
button::after &#123;
    --slice-0: inset(50% 50% 50% 50%);
    --slice-1: inset(80% -6px 0 0);
    --slice-2: inset(50% -6px 30% 0);
    --slice-3: inset(10% -6px 85% 0);
    --slice-4: inset(40% -6px 43% 0);
    --slice-5: inset(80% -6px 5% 0);
    content: &#39;立即加入&#39;;
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, transparent 3%, #00E6F6 3%, #00E6F6 5%, #FF013C 5%);
    text-shadow: -3px -3px 0px #F8F005, 3px 3px 0px #00E6F6;
    clip-path: var(--slice-0);
&#125;
button:hover::after &#123;
    animation: 1s glitch;
    animation-timing-function: steps(2, end);
&#125;
@keyframes glitch &#123;
    0% &#123; clip-path: var(--slice-1); transform: translate(-20px, -10px); &#125;
    10% &#123; clip-path: var(--slice-3); transform: translate(10px, 10px); &#125;
    20% &#123; clip-path: var(--slice-1); transform: translate(-10px, 10px); &#125;
    30% &#123; clip-path: var(--slice-3); transform: translate(0px, 5px); &#125;
    40% &#123; clip-path: var(--slice-2); transform: translate(-5px, 0px); &#125;
    50% &#123; clip-path: var(--slice-3); transform: translate(5px, 0px); &#125;
    60% &#123; clip-path: var(--slice-4); transform: translate(5px, 10px); &#125;
    70% &#123; clip-path: var(--slice-2); transform: translate(-10px, 10px); &#125;
    80% &#123; clip-path: var(--slice-5); transform: translate(20px, -10px); &#125;
    90% &#123; clip-path: var(--slice-1); transform: translate(-10px, 0px); &#125;
    100% &#123; clip-path: var(--slice-1); transform: translate(0); &#125;
&#125;
</code></pre>
</li>
<li><p>金属质感</p>
<pre><code class="html">&lt;button class=&quot;gold&quot;&gt;gold 金&lt;/button&gt;
&lt;button class=&quot;silver&quot;&gt;silver 银&lt;/button&gt;
&lt;button class=&quot;bronze&quot;&gt;bronze 铜&lt;/button&gt;
&lt;button class=&quot;titanium&quot;&gt;titanium 钛&lt;/button&gt;
</code></pre>
<pre><code class="css">button &#123;
    padding: 2px;
    width: 250px;
    height: 250px;
    border-radius: 12px;
    border: groove 1px transparent;
&#125;
.gold &#123;
    box-shadow: inset 0 0 0 1px #eedc00, inset 0 1px 2px rgba(255, 255, 255, 0.5), inset 0 -1px 2px rgba(0, 0, 0, 0.5);
    background: conic-gradient(#edc800, #e3b600, #f3cf00, #ffe800, #ffe900, #ffeb00, #ffe000, #ebc500, #e0b100, #f1cc00, #fcdc00, #d4c005fb, #fad900, #eec200, #e7b900, #f7d300, #ffe800, #ffe300, #f5d100, #e6b900, #e3b600, #f4d000, #ffe400, #ebc600, #e3b600, #f6d500, #ffe900, #ffe90a, #edc800) content-box, linear-gradient(#f6d600, #f6d600) padding-box, radial-gradient(rgba(120, 120, 120, 0.9), rgba(120, 120, 120, 0) 70%) 50% bottom/80% 0.46875em no-repeat border-box;
&#125;
.silver &#123;
    box-shadow: inset 0 0 0 1px #c9c9c9, inset 0 1px 2px rgba(255, 255, 255, 0.5), inset 0 -1px 2px rgba(0, 0, 0, 0.5);
    background: conic-gradient(#d7d7d7, #c3c3c3, #cccccc, #c6c6c6, #d3d3d3, #d8d8d8, #d5d5d5, #d8d8d8, #d3d3d3, #c5c5c5, #c0c0c0, #bfbfbf, #d0d0d0, #d9d9d9, #d1d1d1, #c5c5c5, #c8c8c8, #d7d7d7, #d5d5d5, #cdcdcd, #c4c4c4, #d9d9d9, #cecece, #c5c5c5, #c5c5c5, #cdcdcd, #d8d8d8, #d9d9d9, #d7d7d7) content-box, linear-gradient(#d4d4d4, #d4d4d4) padding-box, radial-gradient(rgba(120, 120, 120, 0.9), rgba(120, 120, 120, 0) 70%) 50% bottom/80% 0.46875em no-repeat border-box;
&#125;
.bronze &#123;
    box-shadow: inset 0 0 0 1px #bc7e6b, inset 0 1px 2px rgba(255, 255, 255, 0.5), inset 0 -1px 2px rgba(0, 0, 0, 0.5);
    background: conic-gradient(#d95641, #b14439, #b2453a, #d25645, #d56847, #d05441, #b85137, #b2453a, #c34f40, #df4647, #a94338, #c94943, #c85442, #a4413c, #d9543a, #d1564e, #ab4338, #bb4a3c, #dc5843, #b94839, #aa4237, #c24e42, #ce523f, #ab4338, #dd5944, #ca4d33, #ab4338, #cb503e, #d95641) content-box, linear-gradient(#ad3b36, #ad3b36) padding-box, radial-gradient(rgba(120, 120, 120, 0.9), rgba(120, 120, 120, 0) 70%) 50% bottom/80% 0.46875em no-repeat border-box;
&#125;
.titanium &#123;
    box-shadow: inset 0 0 0 1px #c7aca0, inset 0 1px 2px rgba(255, 255, 255, 0.5), inset 0 -1px 2px rgba(0, 0, 0, 0.5);
    background: conic-gradient(#e6c9bf, #d2b5aa, #cbaea3, #d4b5ab, #e5c3bd, #d9c0b4, #d9bcb1, #c5a399, #e3c6bc, #e7cac0, #dec0b5, #d3b6ab, #cfada1, #d4b6ac, #e2c6c0, #e2c6c0, #d2b1a6, #d2b1a6, #d1b4a9, #e1c4ba, #e5c9be, #dec1b6, #d3b6ab, #ceb0a6, #cfada3, #d2b5aa, #dabdb2, #e5c9be, #e6c9bf) content-box, linear-gradient(#e5c9be, #e5c9be) padding-box, radial-gradient(rgba(120, 120, 120, 0.9), rgba(120, 120, 120, 0) 70%) 50% bottom/80% 0.46875em no-repeat border-box;
&#125;
</code></pre>
</li>
<li><p><a href="https://codepen.io/dragonir/full/oNZPLzo">故障风格图片</a></p>
<pre><code class="html">&lt;body&gt;
    &lt;div class=&quot;glitch&quot;&gt;&lt;!-- 图片展示容器主体 --&gt;
        &lt;div class=&quot;glitch__item&quot;&gt;&lt;/div&gt;&lt;!-- 故障条 --&gt;
        &lt;div class=&quot;glitch__item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;glitch__item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;glitch__item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;glitch__item&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<pre><code class="css">:root &#123;
    --gap-horizontal: 10px;
    --gap-vertical: 5px;
    --time-anim: 4s;
    --delay-anim: 2s;
    --blend-mode-1: none;
    --blend-mode-2: none;
    --blend-mode-3: none;
    --blend-mode-4: none;
    --blend-mode-5: overlay;
    --blend-color-1: transparent;
    --blend-color-2: transparent;
    --blend-color-3: transparent;
    --blend-color-4: transparent;
    --blend-color-5: transparent;
&#125;
body &#123;
    background: #FDEC0A;
    margin: 0;
    padding: 0;
&#125;
.glitch &#123;
    width: 1000px;
    height: 500px;
    position: relative;
    margin: 40px auto;
&#125;
.glitch .glitch__item &#123;
    background: url(&quot;https://www.cyberpunk.net/build/images/home-header/cover-1440-zh-cn-edd5d3b7.jpg&quot;) no-repeat 50% 50%/cover;
    height: 100%;
    width: 100%;
    top: 0;
    left: 0;
    position: absolute;
&#125;
.glitch .glitch__item:nth-child(n+2) &#123;
    opacity: 0;
    animation-duration: var(--time-anim);
    animation-delay: var(--delay-anim);
    animation-timing-function: linear;
    animation-iteration-count: infinite;
&#125;
.glitch .glitch__item:nth-child(2) &#123;
    background-color: var(--blend-color-2);
    background-blend-mode: var(--blend-mode-2);
    animation-name: glitch-anim-2;
&#125;
.glitch .glitch__item:nth-child(2) &#123;
    background-color: var(--blend-color-3);
    background-blend-mode: var(--blend-mode-3);
    animation-name: glitch-anim-3;
&#125;
.glitch .glitch__item:nth-child(4) &#123;
    background-color: var(--blend-color-4);
    background-blend-mode: var(--blend-mode-4);
    animation-name: glitch-anim-4;
&#125;
.glitch .glitch__item:nth-child(5) &#123;
    background-color: var(--blend-color-5);
    background-blend-mode: var(--blend-mode-5);
    animation-name: glitch-anim-flash;
&#125;
@keyframes glitch-anim-flash &#123;
    0%,
    5% &#123;
        opacity: 0.2;
        transform: translate3d(var(--glitch-horizontal), 500px, 0);
    &#125;
    5.5%,
    100% &#123;
        opacity: 0;
        transform: translate3d(0, 0, 0);
    &#125;
&#125;
@keyframes glitch-anim-2 &#123;
    0% &#123;
        opacity: 1;
        transform: translate3d(var(--gap-horizontal), 0, 0);
        -webkit-clip-path: polygon(0 2%, 100% 2%, 100% 5%, 0 5%);
        clip-path: polygon(0 2%, 100% 2%, 100% 5%, 0 5%);
    &#125;
    2% &#123;
        -webkit-clip-path: polygon(0 15%, 100% 15%, 100% 15%, 0 15%);
        clip-path: polygon(0 15%, 100% 15%, 100% 15%, 0 15%);
    &#125;
    4% &#123;
        -webkit-clip-path: polygon(0 10%, 100% 10%, 100% 20%, 0 20%);
        clip-path: polygon(0 10%, 100% 10%, 100% 20%, 0 20%);
    &#125;
    6% &#123;
        -webkit-clip-path: polygon(0 1%, 100% 1%, 100% 2%, 0 2%);
        clip-path: polygon(0 1%, 100% 1%, 100% 2%, 0 2%);
    &#125;
    8% &#123;
        -webkit-clip-path: polygon(0 33%, 100% 33%, 100% 33%, 0 33%);
        clip-path: polygon(0 33%, 100% 33%, 100% 33%, 0 33%);
    &#125;
    10% &#123;
        -webkit-clip-path: polygon(0 44%, 100% 44%, 100% 44%, 0 44%);
        clip-path: polygon(0 44%, 100% 44%, 100% 44%, 0 44%);
    &#125;
    12% &#123;
        -webkit-clip-path: polygon(0 50%, 100% 50%, 100% 20%, 0 20%);
        clip-path: polygon(0 50%, 100% 50%, 100% 20%, 0 20%);
    &#125;
    14% &#123;
        -webkit-clip-path: polygon(0 70%, 100% 70%, 100% 70%, 0 70%);
        clip-path: polygon(0 70%, 100% 70%, 100% 70%, 0 70%);
    &#125;
    16% &#123;
        -webkit-clip-path: polygon(0 80%, 100% 80%, 100% 80%, 0 80%);
        clip-path: polygon(0 80%, 100% 80%, 100% 80%, 0 80%);
    &#125;
    18% &#123;
        -webkit-clip-path: polygon(0 50%, 100% 50%, 100% 55%, 0 55%);
        clip-path: polygon(0 50%, 100% 50%, 100% 55%, 0 55%);
    &#125;
    20% &#123;
        -webkit-clip-path: polygon(0 70%, 100% 70%, 100% 80%, 0 80%);
        clip-path: polygon(0 70%, 100% 70%, 100% 80%, 0 80%);
    &#125;
    21.9% &#123;
        opacity: 1;
        transform: translate3d(var(--gap-horizontal), 0, 0);
    &#125;
    22%,
    100% &#123;
        opacity: 0;
        transform: translate3d(0, 0, 0);
        -webkit-clip-path: polygon(0 0, 0 0, 0 0, 0 0);
        clip-path: polygon(0 0, 0 0, 0 0, 0 0);
    &#125;
&#125;
@keyframes glitch-anim-3 &#123;
    0% &#123;
        opacity: 1;
        transform: translate3d(calc(-1 * var(--gap-horizontal)), 0, 0);
        -webkit-clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%);
        clip-path: polygon(0 25%, 100% 25%, 100% 30%, 0 30%);
    &#125;
    3% &#123;
        -webkit-clip-path: polygon(0 3%, 100% 3%, 100% 3%, 0 3%);
        clip-path: polygon(0 3%, 100% 3%, 100% 3%, 0 3%);
    &#125;
    5% &#123;
        -webkit-clip-path: polygon(0 5%, 100% 5%, 100% 20%, 0 20%);
        clip-path: polygon(0 5%, 100% 5%, 100% 20%, 0 20%);
    &#125;
    7% &#123;
        -webkit-clip-path: polygon(0 20%, 100% 20%, 100% 20%, 0 20%);
        clip-path: polygon(0 20%, 100% 20%, 100% 20%, 0 20%);
    &#125;
    9% &#123;
        -webkit-clip-path: polygon(0 40%, 100% 40%, 100% 40%, 0 40%);
        clip-path: polygon(0 40%, 100% 40%, 100% 40%, 0 40%);
    &#125;
    11% &#123;
        -webkit-clip-path: polygon(0 52%, 100% 52%, 100% 59%, 0 59%);
        clip-path: polygon(0 52%, 100% 52%, 100% 59%, 0 59%);
    &#125;
    13% &#123;
        -webkit-clip-path: polygon(0 60%, 100% 60%, 100% 60%, 0 60%);
        clip-path: polygon(0 60%, 100% 60%, 100% 60%, 0 60%);
    &#125;
    15% &#123;
        -webkit-clip-path: polygon(0 75%, 100% 75%, 100% 75%, 0 75%);
        clip-path: polygon(0 75%, 100% 75%, 100% 75%, 0 75%);
    &#125;
    17% &#123;
        -webkit-clip-path: polygon(0 65%, 100% 65%, 100% 40%, 0 40%);
        clip-path: polygon(0 65%, 100% 65%, 100% 40%, 0 40%);
    &#125;
    19% &#123;
        -webkit-clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%);
        clip-path: polygon(0 45%, 100% 45%, 100% 50%, 0 50%);
    &#125;
    20% &#123;
        -webkit-clip-path: polygon(0 14%, 100% 14%, 100% 33%, 0 33%);
        clip-path: polygon(0 14%, 100% 14%, 100% 33%, 0 33%);
    &#125;
    21.9% &#123;
        opacity: 1;
        transform: translate3d(calc(-1 * var(--gap-horizontal)), 0, 0);
    &#125;
    22%,
    100% &#123;
        opacity: 0;
        transform: translate3d(0, 0, 0);
        -webkit-clip-path: polygon(0 0, 0 0, 0 0, 0 0);
        clip-path: polygon(0 0, 0 0, 0 0, 0 0);
    &#125;
&#125;
@keyframes glitch-anim-4 &#123;
    0% &#123;
        opacity: 1;
        transform: translate3d(0, calc(-1 * var(--gap-vertical)), 0) scale3d(-1, -1, 1);
        -webkit-clip-path: polygon(0 1%, 100% 1%, 100% 3%, 0 3%);
        clip-path: polygon(0 1%, 100% 1%, 100% 3%, 0 3%);
    &#125;
    1.5% &#123;
        -webkit-clip-path: polygon(0 10%, 100% 10%, 100% 9%, 0 9%);
        clip-path: polygon(0 10%, 100% 10%, 100% 9%, 0 9%);
    &#125;
    2% &#123;
        -webkit-clip-path: polygon(0 5%, 100% 5%, 100% 6%, 0 6%);
        clip-path: polygon(0 5%, 100% 5%, 100% 6%, 0 6%);
    &#125;
    2.5% &#123;
        -webkit-clip-path: polygon(0 20%, 100% 20%, 100% 20%, 0 20%);
        clip-path: polygon(0 20%, 100% 20%, 100% 20%, 0 20%);
    &#125;
    3% &#123;
        -webkit-clip-path: polygon(0 10%, 100% 10%, 100% 10%, 0 10%);
        clip-path: polygon(0 10%, 100% 10%, 100% 10%, 0 10%);
    &#125;
    5% &#123;
        -webkit-clip-path: polygon(0 30%, 100% 30%, 100% 25%, 0 25%);
        clip-path: polygon(0 30%, 100% 30%, 100% 25%, 0 25%);
    &#125;
    5.5% &#123;
        -webkit-clip-path: polygon(0 15%, 100% 15%, 100% 16%, 0 16%);
        clip-path: polygon(0 15%, 100% 15%, 100% 16%, 0 16%);
    &#125;
    7% &#123;
        -webkit-clip-path: polygon(0 40%, 100% 40%, 100% 39%, 0 39%);
        clip-path: polygon(0 40%, 100% 40%, 100% 39%, 0 39%);
    &#125;
    8% &#123;
        -webkit-clip-path: polygon(0 20%, 100% 20%, 100% 21%, 0 21%);
        clip-path: polygon(0 20%, 100% 20%, 100% 21%, 0 21%);
    &#125;
    9% &#123;
        -webkit-clip-path: polygon(0 60%, 100% 60%, 100% 55%, 0 55%);
        clip-path: polygon(0 60%, 100% 60%, 100% 55%, 0 55%);
    &#125;
    10.5% &#123;
        -webkit-clip-path: polygon(0 30%, 100% 30%, 100% 31%, 0 31%);
        clip-path: polygon(0 30%, 100% 30%, 100% 31%, 0 31%);
    &#125;
    11% &#123;
        -webkit-clip-path: polygon(0 70%, 100% 70%, 100% 69%, 0 69%);
        clip-path: polygon(0 70%, 100% 70%, 100% 69%, 0 69%);
    &#125;
    13% &#123;
        -webkit-clip-path: polygon(0 40%, 100% 40%, 100% 41%, 0 41%);
        clip-path: polygon(0 40%, 100% 40%, 100% 41%, 0 41%);
    &#125;
    14% &#123;
        -webkit-clip-path: polygon(0 80%, 100% 80%, 100% 75%, 0 75%);
        clip-path: polygon(0 80%, 100% 80%, 100% 75%, 0 75%);
    &#125;
    14.5% &#123;
        -webkit-clip-path: polygon(0 50%, 100% 50%, 100% 51%, 0 51%);
        clip-path: polygon(0 50%, 100% 50%, 100% 51%, 0 51%);
    &#125;
    15% &#123;
        -webkit-clip-path: polygon(0 90%, 100% 90%, 100% 90%, 0 90%);
        clip-path: polygon(0 90%, 100% 90%, 100% 90%, 0 90%);
    &#125;
    16% &#123;
        -webkit-clip-path: polygon(0 60%, 100% 60%, 100% 60%, 0 60%);
        clip-path: polygon(0 60%, 100% 60%, 100% 60%, 0 60%);
    &#125;
    18% &#123;
        -webkit-clip-path: polygon(0 100%, 100% 100%, 100% 99%, 0 99%);
        clip-path: polygon(0 100%, 100% 100%, 100% 99%, 0 99%);
    &#125;
    20% &#123;
        -webkit-clip-path: polygon(0 70%, 100% 70%, 100% 71%, 0 71%);
        clip-path: polygon(0 70%, 100% 70%, 100% 71%, 0 71%);
    &#125;
    21.9% &#123;
        opacity: 1;
        transform: translate3d(0, calc(-1 * var(--gap-vertical)), 0) scale3d(-1, -1, 1);
    &#125;
    22%,
    100% &#123;
        opacity: 0;
        transform: translate3d(0, 0, 0);
        -webkit-clip-path: polygon(0 0, 0 0, 0 0, 0 0);
        clip-path: polygon(0 0, 0 0, 0 0, 0 0);
    &#125;
&#125;
</code></pre>
</li>
<li><p>loading</p>
<pre><code class="html">&lt;div class=&quot;showbox&quot;&gt;
    &lt;div class=&quot;loader&quot; style=&quot;width: 47px;&quot;&gt;&lt;!-- 设置 loader 大小为 47 x 47 --&gt;
        &lt;svg class=&quot;circular&quot; viewBox=&quot;25 25 50 50&quot;&gt;
            &lt;circle class=&quot;path&quot; cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;20&quot; fill=&quot;none&quot; stroke-width=&quot;2&quot; stroke-miterlimit=&quot;10&quot; /&gt;
        &lt;/svg&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="css">.loader &#123;
    position: relative;
    margin: 0 auto;
    width: 100px;
&#125;
.loader:before &#123;
    content: &#39;&#39;;
    display: block;
    padding-top: 100%;
&#125;
.circular &#123;
    animation: rotate 2s linear infinite;
    height: 100%;
    transform-origin: center center;
    width: 100%;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    margin: auto;
&#125;
.path &#123;
    stroke-dasharray: 1, 200;
    stroke-dashoffset: 0;
    animation: dash 1.5s ease-in-out infinite, color 6s ease-in-out infinite;
    stroke-linecap: round;
&#125;
@keyframes rotate &#123;
    100% &#123;
        transform: rotate(360deg);
    &#125;
&#125;
@keyframes dash &#123;
    0% &#123;
        stroke-dasharray: 1, 200;
        stroke-dashoffset: 0;
    &#125;
    50% &#123;
        stroke-dasharray: 89, 200;
        stroke-dashoffset: -35px;
    &#125;
    100% &#123;
        stroke-dasharray: 89, 200;
        stroke-dashoffset: -124px;
    &#125;
&#125;
@keyframes color &#123;
    100%,
    0% &#123;
        stroke: #d62d20;
    &#125;
    40% &#123;
        stroke: #0057e7;
    &#125;
    66% &#123;
        stroke: #008744;
    &#125;
    80%,
    90% &#123;
        stroke: #ffa700;
    &#125;
&#125;
body &#123;
    background-color: #eee;
&#125;
.showbox &#123;
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    padding: 5%;
&#125;
</code></pre>
</li>
<li><p>按钮的冷光效果</p>
<pre><code class="html">&lt;div&gt;
    &lt;button&gt;Button&lt;/button&gt;
    &lt;button&gt;Button&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="css">* &#123;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
&#125;
html, body &#123;
    display: grid;
    height: 100%;
    place-items: center;
    background: #000;
    overflow: hidden;
&#125;
button &#123;
    position: relative;
    height: 60px;
    width: 200px;
    margin: 0 35px;
    border-radius: 50px;
    border: none;
    outline: none;
    background: #111;
    color: #fff;
    font-size: 20px;
    letter-spacing: 2px;
    text-transform: uppercase;
    cursor: pointer;
&#125;
button:first-child:hover &#123;
    background: linear-gradient(90deg, #03a9f4, #f441a5, #ffeb3b, #03a9f4);
    background-size: 400%;
&#125;
button:last-child:hover &#123;
    background: linear-gradient(90deg, #fa7199, #f5ce62, #e43603, #fa7199);
    background-size: 400%;
&#125;
button:first-child:before,
button:last-child:before &#123;
    content: &#39;&#39;;
    position: absolute;
    background: inherit;
    top: -5px;
    right: -5px;
    bottom: -5px;
    left: -5px;
    border-radius: 50px;
    filter: blur(20px);
    opacity: 0;
    transform: opacity 0.5s;
&#125;
button:first-child:hover:before,
button:last-child:hover:before &#123;
    opacity: 1;
    z-index: -1;
&#125;
button:hover &#123;
    z-index: 1;
    animation: glow 8s linear infinite;
&#125;
@keyframes glow&#123;
    0% &#123;
        background-position: 0%;
    &#125;
    100% &#123;
        background-position: 400%;
    &#125;
&#125;
</code></pre>
</li>
<li><p><a href="https://coding.zhangbing.site/view.html?url=./list/slider-before-after-image.html">“前后”图像比较功能</a></p>
<pre><code class="html">&lt;div class=&#39;container&#39;&gt;
    &lt;div class=&#39;img background-img&#39;&gt;&lt;/div&gt;
    &lt;div class=&#39;img foreground-img&#39;&gt;&lt;/div&gt;
    &lt;input type=&quot;range&quot; min=&quot;1&quot; max=&quot;100&quot; value=&quot;50&quot; class=&quot;slider&quot; name=&#39;slider&#39; id=&quot;slider&quot;&gt;
    &lt;div class=&#39;slider-button&#39;&gt;&lt;/div&gt;
&lt;/div&gt;  
</code></pre>
<pre><code class="css">.container &#123;
    position: relative;
    width: 900px;
    height: 600px;
    border: 2px solid white;
&#125;
.img &#123;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: 900px 100%;
&#125;
.background-img &#123;
    background-image: url(&#39;https://i.loli.net/2020/12/28/1dGpFx3zJ9Pjcme.jpg&#39;);
&#125;
.foreground-img &#123;
    background-image: url(&#39;https://i.loli.net/2020/12/28/xIZmjtBR5VWoqiz.jpg&#39;);
    width: 50%;
&#125;
.slider &#123;
    display: flex;
    justify-content: center;
    align-items: center;
    position: absolute;
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 100%;
    background: rgba(242,242,241,.3);
    outline: none;
    margin: 0;
    transition: all .2s;
&#125;
.slider:hover &#123;
    background: rgba(242,242,241,.1); 
&#125;
.slider::-webkit-slider-thumb &#123;
    -webkit-appearance: none;
    appearance: none;
    width: 6px;
    height: 600px;
    background: white;
&#125;
.slider-button &#123;
    pointer-events: none;
    position: absolute;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    background-color: white;
    left: calc(50% - 18px);
    top: calc(50% - 18px);
    display: flex;
    justify-content: center;
    align-items: center;
&#125;
.slider-button::after &#123;
    content: &#39;&#39;;
    padding: 3px;
    display: inline-block;
    border: solid #5D5D5D;
    border-width: 0 2px 2px 0;
    transform: rotate(-45deg);
&#125;
.slider-button::before &#123;
    content: &#39;&#39;;
    padding: 3px;
    display: inline-block;
    border: solid #5D5D5D;
    border-width: 0 2px 2px 0;
    transform: rotate(135deg);
&#125;
</code></pre>
<pre><code class="javascript">document.getElementById(&quot;slider&quot;).addEventListener(&quot;input&quot;, function(e) &#123;
    let sliderPos = e.target.value;
    document.querySelector(&quot;.foreground-img&quot;).style.width = `$&#123;sliderPos&#125;%`
    document.querySelector(&quot;.slider-button&quot;).style.left = `calc($&#123;sliderPos&#125;% - 18px)`
&#125;);
</code></pre>
</li>
<li><p>div 撑满页面</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;style&gt;
            * &#123;
                margin: 0;
                padding: 0;
            &#125;
            html, body &#123;
                width: 100%;
                height: 100%;
            &#125;
            div &#123;
                width: 100%;
                height: 100%;
                background: red;
            &#125;
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Deno</title>
    <url>/2025/03/22/deno/</url>
    <content><![CDATA[<h1 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a><a href="https://github.com/denoland/deno">Deno</a></h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><p>在线安装</p>
<ul>
<li>linux<br>  <del><code>curl -fsSL https://deno.land/x/install/install.sh | sh</code></del><br>  <code>curl -fsSL https://x.deno.js.cn/install.sh | sh</code></li>
<li><a href="https://dl.deno.js.cn/release/v1.25.0/deno-x86_64-pc-windows-msvc.zip">windows</a>（powershell）<br>  <del><code>iwr https://deno.land/x/install/install.ps1 -useb | iex</code></del><br>  <code>iwr https://x.deno.js.cn/install.ps1 -useb | iex</code></li>
</ul>
</li>
<li><p><a href="https://marketplace.visualstudio.com/items?itemName=denoland.vscode-deno">Deno for Visual Studio Code</a></p>
<ol>
<li>安装<br> <code>ext install denoland.vscode-deno</code></li>
<li>配置，在工程根目录下创建 settings.json 并配置开启插件<pre><code class="bash">mkdir .vscode
cat &gt; .vscode/settings.json &lt;&lt; EOF
&#123;
    &quot;deno.enable&quot;: true
&#125;
EOF
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li><p>执行脚本</p>
<pre><code class="bash"># deno run greeting.ts
deno run https://deno.land/std/examples/welcome.ts
</code></pre>
</li>
<li><p>安装 HTTP 文件服务器</p>
<pre><code class="bash">deno install --allow-net --allow-read https://deno.land/std/http/file_server.ts

file_server . # 启动 HTTP 文件服务器
</code></pre>
</li>
</ul>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><ul>
<li><p>设置代理服务器</p>
<pre><code class="bash">export HTTP_PROXY=http://127.0.0.1:5566 # 设置代理服务器
export HTTPS_PROXY=http://127.0.0.1:5566 # 设置代理服务器

deno run --allow-net service.ts # --allow-net 表示允许网络访问
# deno run -A service.ts # -A 表示允许所有权限，如网络访问等
</code></pre>
</li>
</ul>
<h2 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h2><ul>
<li><a href="https://deno.land/manual@v1.16.3/runtime/ffi_api">外部方法接口</a></li>
</ul>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><ul>
<li><p>uuid</p>
<pre><code class="typescript">import * as uuid from &quot;https://deno.land/x/std/uuid/v4.ts&quot;;

// uuid.generate()
</code></pre>
</li>
<li><p>http &amp; websocket</p>
<pre><code class="typescript">import &#123; listenAndServe &#125; from &quot;https://deno.land/std/http/server.ts&quot;;
import &#123; acceptWebSocket, acceptable, WebSocket, isWebSocketCloseEvent &#125; from &quot;https://deno.land/std/ws/mod.ts&quot;;

listenAndServe(&#123; port: 3000 &#125;, async (request) =&gt; &#123;
    if (request.method === &quot;GET&quot; &amp;&amp; request.url === &quot;/&quot;) &#123;
        request.respond(&#123;
            status: 200,
            headers: new Headers(&#123;
                &quot;content-type&quot;: &quot;text/html&quot;
            &#125;),
            body: await Deno.open(&quot;./index.html&quot;)
        &#125;);
    &#125;
    if (request.method === &quot;GET&quot; &amp;&amp; request.url === &quot;/ws&quot;) &#123; // WebSocket
        if (acceptable(request)) &#123;
            acceptWebSocket(&#123;
                conn: request.conn,
                bufReader: request.r,
                bufWriter: request.w,
                headers: request.headers
            &#125;).then(async function(websocket: WebSocket): Promise&lt;void&gt; &#123;
                for await (const event of websocket) &#123; // wait for new messages
                    const message = typeof event === &quot;string&quot; ? event : &quot;&quot;;
                    console.info(&quot;new message received&quot;, message);
                    if (!message &amp;&amp; isWebSocketCloseEvent(event)) &#123; // disconnect
                        break;
                    &#125;
                &#125;
            &#125;);
        &#125;
    &#125;
&#125;);
console.log(&quot;server has started on http://127.0.0.1:3000&quot;);
</code></pre>
</li>
<li><p>crypto</p>
<pre><code class="typescript">import &#123; crypto &#125; from &quot;https://deno.land/std@0.114.0/crypto/mod.ts&quot;;

// This will delegate to the runtime&#39;s WebCrypto implementation.
console.log(
    await crypto.subtle.digest(
        &quot;SHA-384&quot;,
        new TextEncoder().encode(&quot;hello world&quot;),
    )
);

// This will use a bundled WASM/Rust implementation.
console.log(
    await crypto.subtle.digest(&quot;BLAKE3&quot;, new TextEncoder().encode(&quot;hello world&quot;))
);
</code></pre>
</li>
<li><p>workers<br>  Workers can be used to run code on multiple threads. Each instance of Worker is run on a separate thread, dedicated only to that worker.</p>
<pre><code class="typescript">new Worker(new URL(&quot;./worker.ts&quot;, import.meta.url).href, &#123; type: &quot;module&quot; &#125;);
</code></pre>
</li>
<li><p>sleep</p>
<pre><code class="typescript">function sleep(ms: number)&#123;
    return new Promise((resolve) =&gt; setTimeout(resolve, ms));
&#125;

await sleep(500); // sleep for 500ms
</code></pre>
</li>
</ul>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><h4 id="chat-WebSocket-chat-server-and-browser-client"><a href="#chat-WebSocket-chat-server-and-browser-client" class="headerlink" title="chat - WebSocket chat server and browser client"></a>chat - WebSocket chat server and browser client</h4><pre><code class="bash">deno run --allow-net --allow-read https://deno.land/std/examples/chat/server.ts
</code></pre>
<h4 id="curl-print-the-contents-of-a-url-to-standard-output"><a href="#curl-print-the-contents-of-a-url-to-standard-output" class="headerlink" title="curl - print the contents of a url to standard output"></a>curl - print the contents of a url to standard output</h4><pre><code class="bash">deno run --allow-net=deno.land https://deno.land/std/examples/curl.ts https://deno.land/
</code></pre>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><ul>
<li><p><a href="https://github.com/asos-craigmorten/opine">opine</a> 实现 web 服务器</p>
<ul>
<li><p>hello, world</p>
<pre><code class="typescript">import &#123; opine &#125; from &quot;https://deno.land/x/opine/mod.ts&quot;;

const app = opine();

app.get(&quot;/greeting&quot;, function (req, res) &#123;
    res.send(&quot;&lt;html&gt;&lt;body&gt;hello world&lt;/body&gt;&lt;/html&gt;&quot;);
&#125;);

app.listen(3000, () =&gt; console.log(&quot;server has started on http://127.0.0.1:3000 🚀&quot;));
</code></pre>
</li>
<li><p>json</p>
<pre><code class="typescript">import &#123; opine, json &#125; from &quot;https://deno.land/x/opine/mod.ts&quot;;

const app = opine();

app.use(json()); // for parsing application/json

app.get(&quot;/greeting/:name&quot;, function (req, res) &#123;
    res.json(&#123;
        &quot;greeting&quot;: &quot;hello, &quot; + req.params.name
    &#125;);
&#125;);
app.post(&quot;/greeting&quot;, function (req, res) &#123;
    res.json(&#123;
        &quot;greeting&quot;: &quot;hello, &quot; + req.body.name
    &#125;);
&#125;);

app.listen(3000);
</code></pre>
</li>
<li><p>下载文件</p>
<pre><code class="typescript">import &#123; opine &#125; from &quot;https://deno.land/x/opine/mod.ts&quot;;
import &#123; dirname, join &#125; from &quot;https://deno.land/x/opine@1.5.4/deps.ts&quot;;

const app = opine();
const __dirname = dirname(import.meta.url);

app.get(&quot;/files/:file(*)&quot;, async function (req, res, next) &#123; // 下载文件，如 http://127.0.0.1:3000/files/a.txt（./files/a.txt）
    const filePath = join(__dirname, &quot;files&quot;, req.params.file);

    try &#123;
        await res.download(filePath);
    &#125; catch (err) &#123;
        // file for download not found
        if (err instanceof Deno.errors.NotFound) &#123;
            res.status = 404;
            res.send(&quot;Cant find that file, sorry!&quot;);
            return;
        &#125;
        // non-404 error
        return next(err);
    &#125;
&#125;);

app.listen(3000);
</code></pre>
</li>
</ul>
</li>
<li><p><a href="https://github.com/denodrivers/mysql">mysql</a> 连接数据库</p>
<pre><code class="typescript">import &#123; Client &#125; from &quot;https://deno.land/x/mysql/mod.ts&quot;;

const client = await new Client().connect(&#123;
    hostname: &quot;127.0.0.1&quot;,
    username: &quot;root&quot;,
    db: &quot;dbname&quot;,
    password: &quot;password&quot;,
    // poolSize: 3, // 最大连接数
&#125;);

// 创建数据库
await client.execute(`CREATE DATABASE IF NOT EXISTS enok`);

// 创建表
await client.execute(`
    CREATE TABLE users (
        id int(11) NOT NULL AUTO_INCREMENT,
        name varchar(100) NOT NULL,
        created_at timestamp not null default current_timestamp,
        PRIMARY KEY (id)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
`);

// 插入数据
await client.execute(`INSERT INTO users(name) values(?)`, [&quot;manyuanrong&quot;]); // &#123; affectedRows: 1, lastInsertId: 1 &#125;

// 修改数据
await client.execute(`update users set ?? = ?`, [&quot;name&quot;, &quot;MYR&quot;]); // &#123; affectedRows: 1, lastInsertId: 0 &#125;

// 删除数据
await client.execute(`delete from users where ?? = ?`, [&quot;id&quot;, 1]); // &#123; affectedRows: 1, lastInsertId: 0 &#125;

// 查询
const &#123; rows: users &#125; = await client.execute(`select * from users`);
console.log(users);
await client.query(&quot;select ??, name from ?? where id = ?&quot;, [&quot;id&quot;, &quot;users&quot;, 1]);

// execute
await client.execute(`select * from users`);

// iterator
await client.useConnection(async (conn) =&gt; &#123;
    // note the third parameter of execute() method.
    const &#123; iterator: users &#125; = await conn.execute(
        `select * from users`,
        [], // params
        false, // iterator
    );
    for await (const user of users) &#123;
        console.log(user);
    &#125;
&#125;);

// transaction
await client.transaction(async (conn) =&gt; &#123;
    await conn.execute(`insert into users(name) values(?)`, [&quot;test&quot;]);
    return await conn.query(`select ?? from ??`, [&quot;name&quot;, &quot;users&quot;]);
&#125;);

await client.close();
</code></pre>
</li>
<li><p><a href="https://github.com/dyedgreen/deno-sqlite">sqlite</a></p>
<pre><code class="typescript">import &#123; DB &#125; from &quot;https://deno.land/x/sqlite/mod.ts&quot;;

// Open a database
const db = new DB(&quot;test.db&quot;);

db.query(&quot;CREATE TABLE IF NOT EXISTS people (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT)&quot;);

// Run a simple query
for (const name of [&quot;Peter Parker&quot;, &quot;Clark Kent&quot;, &quot;Bruce Wayne&quot;]) &#123;
    db.query(&quot;INSERT INTO people (name) VALUES (?)&quot;, [name]);
&#125;

// Print out data in table
for (const [name] of db.query(&quot;SELECT name FROM people&quot;)) &#123;
    console.log(name);
&#125;

// Close connection
db.close();
</code></pre>
</li>
<li><p><a href="https://github.com/keroxp/deno-redis">redis</a></p>
<pre><code class="typescript">import &#123; connect &#125; from &quot;https://denopkg.com/keroxp/deno-redis/mod.ts&quot;;

const redis = await connect(&#123;
    hostname: &quot;127.0.0.1&quot;,
    port: 6379
&#125;);
const ok = await redis.set(&quot;example&quot;, &quot;this is an example&quot;);
const example = await redis.get(&quot;example&quot;);
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>deno</category>
      </categories>
      <tags>
        <tag>deno</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2025/03/22/docker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><p>从 <a href="http://get.daocloud.io/">DaoCloud</a> 下载并安装（推荐，速度快）</p>
<ul>
<li>安装 docker<pre><code class="bash">curl -sSL https://get.daocloud.io/docker | sh
</code></pre>
</li>
<li>安装 docker-compose<pre><code class="bash">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
</code></pre>
</li>
<li>配置 docker 镜像站<pre><code class="bash">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io
</code></pre>
</li>
</ul>
</li>
<li><p>Debian/Ubuntu 环境安装 docker 社区版</p>
<ol>
<li><p>新增 docker apt repository</p>
<pre><code class="bash"># curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
# sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable&quot;

curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;
</code></pre>
</li>
<li><p>安装 docker-ce<br> <code>sudo apt-get update</code><br> <code>sudo apt-get install docker-ce</code></p>
<blockquote>
<p>非官方源是不可信任的，可能会出现异常 “W: GPG error: <a href="https://download.docker.com/">https://download.docker.com</a> trusty Release: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY 7EA0A9C3F273FCD8”，解决办法是导入该源的公钥<br>  <del><code>gpg --keyserver download.docker.com --recv 7EA0A9C3F273FCD8 &amp;&amp; gpg --export --armor 7EA0A9C3F273FCD8 | sudo apt-key add -</code><br>  或</del><br>  <code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code><br>  <code>sudo apt-get update</code></p>
</blockquote>
<blockquote>
<p>启动 docker 服务<br><code>service docker start</code><br>停止 docker 服务<br><code>service docker stop</code></p>
</blockquote>
</li>
</ol>
</li>
<li><p><a href="http://www.cnblogs.com/xiaoff/p/8176819.html">ubuntu 14.04 离线安装 docker 和 docker compose</a></p>
</li>
<li><p><a href="http://blog.csdn.net/mideagroup/article/details/52052618">使用 registry 搭建 docker 私有 hub</a></p>
<ol>
<li><p>下载 registry 镜像<br> <code>docker pull registry</code></p>
</li>
<li><p>创建一个 registry 的容器并运行（”-p 5000:5000” 表示将容器内部的 5000 端口映射到宿主机的 5000 端口）</p>
<pre><code class="bash">docker run -d -p 5000:5000 registry
</code></pre>
<pre><code class="bash">docker run \
    -d \ # 作为 daemon 进程启动，即后台启动
    -v /myrepo:/var/lib/registry \ # 将容器 /var/lib/registry 目录映射到宿主机的 /myrepo，用于存放镜像数据
    -p 5000:5000 \ # 将容器的 5000 端口映射到 Host 的 5000 端口（5000 是 registry 服务端口）
    registry:latest
</code></pre>
</li>
<li><p>验证 registry 容器是否启动成功<br> <code>curl http://127.0.0.1:5000/v2/_catalog</code></p>
</li>
<li><p>使用 registry 管理仓库和镜像</p>
<ul>
<li>上传镜像<ol>
<li>使用 tag 命令让本地镜像 hello-world 指向到 registry 仓库中<br> <code>docker tag hello-world localhost:5000/hello-world:latest</code></li>
<li>推送到 registry 仓库中<br> <code>docker push localhost:5000/hello-world</code></li>
</ol>
</li>
<li>下载镜像<br>  <code>docker pull localhost:5000/hello-world</code></li>
</ul>
</li>
<li><p>开启 TLS 认证</p>
<ol>
<li><p>启动服务</p>
<pre><code class="bash"># 生成证书
openssl req -newkey rsa:4096 -nodes -sha256 -keyout myhub.key -subj &quot;/CN=myhub.com&quot; -x509 -days 365 -out myhub.crt

# 生成账号密码 zhangsan/123456
docker run --rm --entrypoint htpasswd httpd:2 -Bbn zhangsan 123456 &gt; htpasswd

# 启动 registry 容器
docker run -d -p 5000:5000 --restart=always --name registry \
    # -v /myrepo:/var/lib/registry \
    -v $(pwd):/certs \ # 将证书和私钥文件挂载进容器内 /certs 目录下
    -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/myhub.crt \ # 指定（容器内的）证书和私钥文件路径
    -e REGISTRY_HTTP_TLS_KEY=/certs/myhub.key \
    -v $(pwd):/auth \ # 将账号密码文件挂载进容器内 /auth 目录下
    -e &quot;REGISTRY_AUTH=htpasswd&quot; \
    -e &quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot; \
    -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \ # 指定（容器内的）账号密码文件路径
    registry
</code></pre>
</li>
<li><p>配置访问</p>
<pre><code class="bash"># 配置 host
echo &quot;127.0.0.1 myhub.com&quot; &gt;&gt; /etc/hosts

# 验证服务是否启动
curl --cacert myhub.crt https://myhub.com:5000/v2/_catalog

# 下发证书
mkdir -p /etc/docker/certs.d/myhub.com\:5000
cp myhub.crt /etc/docker/certs.d/myhub.com\:5000

# 账号密码登录
docker login myhub.com:5000
# username: zhangsan
# password: 123456

# 上传镜像
docker tag hello-world myhub.com:5000/hello-world:latest
docker push myhub.com:5000/hello-world

# 下载镜像
docker pull myhub.com:5000/hello-world

# 退出登录
docker logout myhub.com:5000
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p>使用 Harbor 搭建 docker 私有 hub</p>
<ol>
<li>搭建</li>
<li>配置域名访问，如 <a href="https://www.mydockerhub.com/">https://www.mydockerhub.com</a></li>
<li>上传镜像<ol>
<li>在 /etc/docker/certs.d 目录下配置 Harbor 服务的公钥证书<pre><code class="bash">cd /etc/docker/certs.d

mkdir www.mydockerhub.com

cd www.mydockerhub.com

openssl s_client -showcerts -connect www.mydockerhub.com:443 &lt; /dev/null 2&gt; /dev/null | openssl x509 -outform PEM &gt; www.mydockerhub.com.crt
</code></pre>
</li>
<li>登录 Harbor 服务<br> <code>docker login www.mydockerhub.com</code></li>
<li>推送镜像<br> <code>docker push www.mydockerhub.com/hello-world:latest</code></li>
</ol>
</li>
</ol>
</li>
<li><p><a href="https://cr.console.aliyun.com/?spm=a2c4g.11186623.2.3.LLTrnr#/accelerator">配置阿里云镜像加速器</a></p>
<ol>
<li><p>修改 daemon 配置文件 /etc/docker/daemon.json 来使用加速器（其中 “<a href="https://0cx54rhx.mirror.aliyuncs.com&quot;/">https://0cx54rhx.mirror.aliyuncs.com&quot;</a> 为已申请的专属加速器地址）</p>
<pre><code class="bash">tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
&#123;
    &quot;registry-mirrors&quot;: [&quot;https://0cx54rhx.mirror.aliyuncs.com&quot;]
&#125;
EOF
</code></pre>
</li>
<li><p><span id="restart-docker-server">重启 docker 服务</span>  </p>
<pre><code class="bash"># ubuntu
service docker restart

# centos
# systemctl restart docker

# 如果是在容器中（如 docker:dind）重启 docker 服务，则直接在宿主机上执行 docker restart 重启容器即可
</code></pre>
</li>
</ol>
</li>
<li><p>开启 docker 实验功能</p>
<ol>
<li>修改配置文件 /etc/docker/daemon.json，在 <code>/</code> 节点下新增配置项<pre><code class="json">&quot;experimental&quot;: true
</code></pre>
</li>
<li><a href="#restart-docker-server">重启 docker 服务</a></li>
</ol>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><p>查看 docker 版本信息<br>  <code>docker version</code><br>  查看 docker 系统的信息<br>  <code>docker info</code></p>
</li>
<li><p>镜像（Image）管理</p>
<pre><code class="bash"># 列出远程仓库 Docker Hub 中所有名称为 ubuntu 的镜像
docker search ubuntu
# 从远程仓库 Docker Hub 中下载名称为 ubuntu 的镜像到本地
docker pull ubuntu
# 推送/发布镜像至远程仓库 Docker Hub 中
docker push new_image_name

# 列出本地仓库中所有的 docker 镜像
docker images
# 删除本地仓库中名称为 ubuntu 的镜像
docker rmi ubuntu
# # 删除本地仓库中所有镜像
# docker rmi $(docker images -q)

# 生成一个镜像 ubuntu 的实例（即容器），并执行该容器中的 /bin/bash，从而交互式进入到该容器中（键入 Ctrl + P + Q 键退出容器但不停止，键入 Ctrl + D 键或执行命令 exit 即可退出容器且停止容器）
docker run -it ubuntu /bin/bash
# # 创建一个镜像 ubuntu 的容器，新建的容器处于停止状态，可以使用 docker start 命令启动
# docker create -it ubuntu
# # 生成一个新的容器，并运行命令 ping www.google.com
# docker run ubuntu ping www.google.com
# # 通过 “-v” 参数可以支持把一个宿主机上的目录挂载到容器中
# docker run -it -v /home/downloads:/usr/downloads ubuntu /bin/bash
# 使用 &quot;--entrypoint bash&quot; 覆盖容器中 entrypoint 的默认启动命令，可用于启动因原 entrypoint 命令存在问题而导致无法启动容器的镜像
# docker run --entrypoint bash -it nginx
# 创建一个 redis 的只读容器
# docker run -- read-only redis

# 根据当前目录下的文件 Dockerfile 构建出一个名称为 IMAGE[:VERSION] 的镜像
docker build -t IMAGE[:VERSION] .
docker build --squash -t IMAGE[:VERSION] . # 参数 &quot;--squash&quot; 表示压缩镜像，需要开启 docker 实验功能

# # 查看指定镜像的创建历史
# docker history IMAGE[:VERSION]

# 打包镜像 ubuntu，并导出到文件 ubuntu.tar 中
docker save -o ubuntu.tar ubuntu
# 从文件 ubuntu.ta 中导入镜像到本地仓库中
docker load -i ubuntu.tar
# docker load &lt; ubuntu.tar
</code></pre>
</li>
<li><p>容器（Container）管理</p>
<pre><code class="bash"># 列出本地所有正在运行的容器
docker ps
# 列出本地所有的容器
docker ps -a
# # 列出本地所有的容器和体积大小
# docker ps -as

# 登录一个正在执行的容器
docker attach [CONTAINER ID|NAMES]

# 启动容器 # 其中 CONTAINER ID 为容器 ID、NAMES 为容器名称，可由 docker ps 查得。如启动 ID 为 5bf9b7645ed2 的容器：docker start 5bf9b7645ed2
docker start [CONTAINER ID|NAMES]
# 停止容器 # 如停止 NAMES 为 focused_bardeen 的容器：docker stop focused_bardeen
docker stop [CONTAINER ID|NAMES]
# 杀死容器
docker kill [CONTAINER ID|NAMES]
# docker kill $(docker ps -a -q) # 杀死所有正在运行的容器
# 重启容器
docker restart [CONTAINER ID|NAMES]
# 删除容器
docker rm [CONTAINER ID|NAMES]
# docker rm $(docker ps -a -q) # 删除所有已经停止的容器

# 从一个容器中取日志
docker logs [CONTAINER ID|NAMES]

# 列出一个容器里面被改变的文件或者目录，list 列表会显示出三种事件，A 增加的，D 删除的，C 被改变的
docker diff [CONTAINER ID|NAMES]

# 显示一个运行的容器里面的进程信息
docker top [CONTAINER ID|NAMES]

# 从容器里面拷贝文件/目录到本地一个路径
# docker cp [CONTAINER ID|NAMES]:/container_path to_path
docker cp /sbin/ifconfig 5bf9b7645ed2:/sbin

# 使用已启动的容器，运行命令 ping www.google.com
docker exec 5bf9b7645ed2 ping www.google.com
# 使用已启动的容器，交互运行 /bin/sh
docker exec -it b7542f84a6c3 /bin/sh

# 导出容器到文件 /tmp/container01.tar 中
docker export [CONTAINER ID|NAMES] &gt; /tmp/container01.tar
# 从文件 /tmp/container01.tar 中导入容器，并设置其 NAMES 为 focused_bardeen
cat /tmp/container01.tar | docker import - focused_bardeen
# # 导出容器并重新导入到镜像中，可用于压缩镜像。ref https://blog.csdn.net/qq_36763896/article/details/53293088
# docker export &lt;container id&gt; | docker import - &lt;image name&gt;

# 将容器 a404c6c174a2 保存为新的镜像 hello，并添加提交人信息和说明信息
docker commit -a &quot;author&quot; -m &quot;describe&quot; a404c6c174a2  hello:v1
# docker commit --change=&#39;ENTRYPOINT [&quot;entrypoint.sh&quot;]&#39; a404c6c174a2  hello:v1
# docker commit -c &#39;ENV JAVA_HOME=/opt/jdk&#39; -c &#39;ENV PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:$JAVA_HOME/bin&#39; -c &#39;ENTRYPOINT service ssh start &amp;&amp; /bin/bash&#39; a404c6c174a2 ubuntu-jdk-ssh

# 查看容器端口映射
docker port a404c6c174a2
docker port a404c6c174a2 8080
</code></pre>
</li>
<li><p><a href="http://www.cnblogs.com/sammyliu/p/5894191.html">网络管理</a></p>
<pre><code class="bash"># 创建一个 overlay 网络 overlay1
docker network create -d overlay --attachable overlay1

# 查看网络 overlay1 的信息
network inspect overlay1
</code></pre>
<pre><code class="bash"># 查看 NAT 表中的 PREROUTING 链（iptables 将满足条件的数据都转发到了 DOCKER 链上去了）
iptables -t nat --list-rules PREROUTING

# 查看 NAT 表中的 DOCKER 链
iptables -t nat --list-rules DOCKER

# 查看容器的 ip
docker inspect &lt;容器id&gt; | grep &#39;&quot;IPAddress&quot;:&#39; | grep -o -E [0-9.]+ | head -n 1

# 端口映射
iptables -t nat -A DOCKER -p tcp --dport &lt;容器外部端口&gt; -j DNAT --to-destination &lt;容器ip&gt;:&lt;容器内部端口&gt;
# iptables -t nat -A POSTROUTING -j MASQUERADE -p tcp --source &lt;容器ip&gt; --destination &lt;容器ip&gt; --dport &lt;容器内部端口&gt;
iptables -A DOCKER -j ACCEPT -p tcp --destination &lt;容器ip&gt; --dport &lt;容器内部端口&gt;

# 取消端口映射规则
iptables -t nat -D DOCKER -p tcp -d 0/0 --dport &lt;容器外部端口&gt; -j DNAT --to-destination &lt;容器ip&gt;:&lt;容器内部端口&gt;
iptables -D DOCKER -j ACCEPT -p tcp --destination &lt;容器ip&gt; --dport &lt;容器内部端口&gt;
</code></pre>
</li>
<li><p>删除那些已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache<br>  <code>docker system prune</code><br>  强制清理<br>  <code>docker system prune --all --force --volumes</code></p>
</li>
<li><p>资源限制</p>
<pre><code class="bash">docker run --rm -it \
    --cpu-period=100000 --cpu-quota=20000 \ # 每 100 毫秒(即 100000 微秒)内，运行进程使用的 cpu 时间最多为 20 毫秒
    --cpuset-cpus=&quot;1&quot; \ # 指定运行容器编号为 1 的 cpu。https://m.jb51.net/article/135395.htm?from=singlemessage
    -m 50M --memory-swap 50M \ # 容器可以使用 50M 的物理内存，且不能使用 swap。https://www.cnblogs.com/sparkdev/p/8032330.html
    --device-write-bps /dev/sda:30MB \ # 限制容器写 /dev/sda 的速率为 30MB/s。http://m.hangge.com/news/cache/detail_2413.html
    u-stress:latest /bin/bash

stress -c 4 # 启动压力测试
</code></pre>
</li>
<li><p>示例</p>
<pre><code class="bash"># 创建一个（虚拟的）网络接口名称为 docker1、网络 NAME 为 bridge1、子网网段为 10.0.1.* 的网桥
docker network create -o &quot;com.docker.network.bridge.name&quot;=&quot;docker1&quot; --subnet=10.0.1.0/24 bridge1

# 停用网络接口 docker1
# ifconfig docker1 down
#apt-get install bridge-utils
#brctl delbr docker1

# 创建一个镜像为 ubuntu、网桥为 bridge1、ip 地址为 10.0.1.2、名称为 client1 的容器，并将宿主机目录 /sbin 挂载到容器中目录 /sbin 下，交互式启动容器中 /bin/bash
docker run -it --network bridge1 --ip 10.0.1.2 --name client1 -v /sbin:/sbin ubuntu /bin/bash
</code></pre>
</li>
<li><p>构建镜像</p>
<ul>
<li><p><a href="https://www.jianshu.com/p/3a2a96ba6b44">构建极简镜像（镜像中应用存在依赖关系）</a><br>  例如，基于一个空的基础镜像完成一个 /bin/hello 的镜像</p>
<ol>
<li><p>查看 /bin/hello 的依赖库，并将 /bin/hello 以及其依赖的动态库，打包至文件 rootfs.tar.gz 中<br> <code>ldd /bin/hello | perl -p -e &#39;s#^\s*(\S+ =&gt; )?(/\S+) \(0x[0-9a-z]+\)$#$2#g&#39; | grep -v &#39;linux-vdso&#39; | sed &#39;$a/bin/hello&#39; | xargs tar zcvf rootfs.tar.gz</code></p>
</li>
<li><p>编辑文件 Dockerfile 构建镜像</p>
<pre><code class="dockerfile">FROM scratch 

ADD rootfs.tar.gz / 

# COPY redis.conf /etc/redis/redis.conf 
# EXPOSE 6379

# CMD [&quot;redis-server&quot;]
CMD [&quot;/bin/hello&quot;]
</code></pre>
</li>
<li><p>构建镜像 hello<br> <code>docker build -t hello .</code></p>
</li>
</ol>
</li>
<li><p>构建简单镜像（镜像中应用无依赖）</p>
<ol>
<li><p>编辑文件 <a href="/Source/docker/hello.sh">Dockerfile</a></p>
<pre><code class="dockerfile">FROM scratch
ADD hello /
CMD [&quot;/hello&quot;]
</code></pre>
<blockquote>
<p>Docker registry 中，有一个被称为 scratch 的使用空 tar 文件构建的特殊镜像<br><code>tar cv --files-from /dev/null | docker import - scratch</code><br>基于该映像可构建新的无冗余的镜像</p>
</blockquote>
</li>
<li><p>构建镜像 hello<br> <code>docker build -t hello .</code></p>
</li>
</ol>
</li>
<li><p><a href="https://m.toutiaocdn.com/i6807657333934522891/?app=news_article&timestamp=1585054531&req_id=202003242055310101450260140F1D4D28&group_id=6807657333934522891&wxshare_count=1&tt_from=weixin&utm_source=weixin&utm_medium=toutiao_android&utm_campaign=client_share&from=singlemessage">多阶段构建</a>  </p>
<pre><code class="dockerfile">FROM gcc AS mybuildstage
COPY hello.c .
RUN gcc -o hello hello.c
FROM alpine
COPY --from=mybuildstage hello .
CMD [&quot;./hello&quot;]
</code></pre>
<!--</li>
<li><p>使用 <a href="https://github.com/jwilder/docker-squash">docker-squash</a> 压缩镜像体积</p>
<ol>
<li><p>下载<br> <code>curl -k -O -L https://github.com/jwilder/docker-squash/releases/download/v0.2.0/docker-squash-linux-amd64-v0.2.0.tar.gz --retry 3 --retry-delay 2</code></p>
</li>
<li><p>解压并添加至 /usr/bin 目录下</p>
<pre><code class="bash">tar -C /usr/bin -xzvf docker-squash-linux-amd64-v0.2.0.tar.gz
chown root:root /usr/bin/docker-squash
chmod 755 /usr/bin/docker-squash
</code></pre>
</li>
<li><p>使用命令压缩镜像  </p>
<pre><code class="bash"># docker save IMAGE_ID | sudo docker-squash -t NEW_TAG | docker load

docker save IMAGE_ID &gt; image.tar
sudo docker-squash -i image.tar -o squashed.tar -t NEW_TAG
cat squashed.tar | docker load
</code></pre>
</li>
</ol>
</li>
<li><p>使用 <a href="https://github.com/docker-slim/docker-slim">docker-slim</a> 压缩镜像体积（不推荐，实测新镜像在运行时出现异常）</p>
<ol>
<li>下载<br> <code>curl -O https://downloads.dockerslim.com/releases/1.25.3/dist_linux.tar.gz</code></li>
<li>解压并添加至 /usr/bin 目录下  <pre><code class="bash">tar zxvf dist_linux.tar.gz
(cd ./dist_linux &amp;&amp; &#123;
    chown root:root ./docker-slim ./docker-slim-sensor
    chmod 755 ./docker-slim ./docker-slim-sensor
    mv ./docker-* /usr/bin/
&#125;)
rm -d dist_linux
</code></pre>
</li>
<li>使用命令压缩镜像<br> <code>docker-slim build --http-probe IMAGE[:VERSION]</code></li>
</ol>
</li>
</ul>
</li>
<li><p>-&gt;</p>
<blockquote>
<p><a href="http://openvz.org/Download/templates/precreated">基础镜像包下载</a></p>
</blockquote>
</li>
<li><p><a href="#docker_client_in_docker">连接宿主机 docker 服务（daemon）</a></p>
</li>
<li><p>连接远程 docker 服务（daemon）</p>
<ol>
<li>配置 docker.service 启用 remote api<pre><code class="bash">mkdir -p /etc/systemd/system/docker.service.d
cat &gt; /etc/systemd/system/docker.service.d/override.conf &lt;&lt; EOF
[Service]
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2376
EOF
</code></pre>
 或者配置 daemon.json<pre><code class="bash">vim /etc/docker/daemon.json
&#123;
    &quot;hosts&quot;: [&quot;tcp://0.0.0.0:2376&quot;, &quot;unix:///var/run/docker.sock&quot;]
&#125;
</code></pre>
</li>
<li>重启服务使配置生效<pre><code class="bash">systemctl daemon-reload &amp;&amp; systemctl restart docker.service
</code></pre>
</li>
<li>查看 dockerd 进程<pre><code class="bash">ps aux | grep dockerd
# root       2471  0.8  1.7 723016 67808 ?        Ssl  09:38   0:00 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2376
</code></pre>
</li>
<li>远程主机 docker 客户端执行命令验证<pre><code class="bash">docker -H tcp://192.168.93.9:2375 version
</code></pre>
</li>
<li>curl 命令验证<pre><code class="bash">curl -XGET http://192.168.93.9:2376/version
</code></pre>
</li>
<li>变量方式使用示例<pre><code class="bash">docker run -it \
    -e DOCKER_HOST=tcp://192.168.93.9:2376 \
    docker version
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="故障解决"><a href="#故障解决" class="headerlink" title="故障解决"></a>故障解决</h2><ul>
<li><p>拉取镜像过程中，报 x509:certificate 错误</p>
<ul>
<li><p>方法一：设置 insecure-registries</p>
<pre><code class="bash">vim /etc/docker/daemon.json
&#123;
    &quot;insecure-registries&quot;: [&quot;myhub.com:443&quot;]
&#125;

# 重启 docker 服务
</code></pre>
</li>
<li><p>方法二：添加信任证书</p>
<pre><code class="bash"># 把网站的 https 证书内容加载到系统 ca-bundle 中
echo -n | openssl s_client -showcerts -connect myhub.com:443 2&gt;/dev/null | sed -ne &#39;/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p&#39; &gt;&gt; /etc/pki/tls/certs/ca-bundle.crt

# 重启 docker 服务
systemctl daemon-reload &amp;&amp; systemctl restart docker
</code></pre>
<blockquote>
<p>当我们在用 docker pull 等命令时，docker 调用的是系统的 CA 证书，这些证书保存在 /etc/pki/certs/ca-bundle.crt 中（centos），所以我们把网站的 https 证书加入到这个文件，重启服务即可</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><details>
<summary>Docker Swarm</summary>

</details>

<details>
<summary>Docker Compose</summary>

<p><a href="https://www.cnblogs.com/52fhy/p/5991344.html">Docker 之 Compose 服务编排</a></p>
<ol>
<li><p>安装</p>
<ul>
<li><p>方法一：从 github 上下载 docker-compose 脚本</p>
<pre><code class="bash"># 下载
sudo curl -L https://github.com/docker/compose/releases/download/1.20.1/docker-compose-Linux-x86_64 -o /usr/local/bin/docker-compose

# 设置可执行权限
chmod +x /usr/local/bin/docker-compose
</code></pre>
</li>
<li><p>方法二：使用 pip 安装<br>  <code>pip install docker-compose</code>  </p>
</li>
</ul>
</li>
<li><p>验证安装（查看 docker-compose 版本）<br> <code>docker-compose version</code></p>
</li>
<li><p>使用</p>
<ol>
<li><p>创建并编辑配置文件 docker-compose.yml 如下</p>
<pre><code class="yml">version: &#39;2&#39;
services:
  web:
    build: .
    ports:
      - &quot;5000:5000&quot;
  redis:
    image: &quot;redis:alpine&quot;
</code></pre>
</li>
<li><p>启动服务<br> <code>docker-compose up</code><br> 在后台启动服务<br> <code>docker-compose up -d</code><br> 查看启动的服务<br> <code>docker-compose ps</code><br> 停止服务<br> <code>docker-compose stop</code><br> 其他常用命令</p>
<pre><code class="bash"># 查看帮助
docker-compose -h

# -f 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。
docker-compose -f docker-compose.yml up -d 

# 启动所有容器，-d 将会在后台启动并运行所有的容器
docker-compose up -d

# 停用移除所有容器以及网络相关
docker-compose down

# 查看服务容器的输出
docker-compose logs

# 列出项目中目前的所有容器
docker-compose ps

# 构建（重新构建）项目中的服务容器。服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。可以随时在项目目录下运行 docker-compose build 来重新构建服务
docker-compose build

# 拉取服务依赖的镜像
docker-compose pull

# 重启项目中的服务
docker-compose restart

# 删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。
docker-compose rm 

# 在指定服务上执行一个命令。
docker-compose run ubuntu ping docker.com

# 设置指定服务运行的容器个数。通过 service=num 的参数来设置数量
docker-compose scale web=3 db=2

# 启动已经存在的服务容器。
docker-compose start

# 停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。
docker-compose stop
</code></pre>
</li>
</ol>
</li>
</ol>
</details>

<h2 id="第三方镜像"><a href="#第三方镜像" class="headerlink" title="第三方镜像"></a>第三方镜像</h2><ul>
<li><p>alpine（轻量级 linux 发行版，体积 &lt; 5 MB，内置 apk 软件包管理工具，可通过 apk –help 命令查看完整的包管理命令）</p>
<pre><code class="bash"># 创建一个新的 alpine 容器并运行 sh 命令
docker run -it alpine /bin/sh
</code></pre>
</li>
<li><p>mysql</p>
<pre><code class="bash">docker run --name mysql01 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7
docker exec -it mysql01 /bin/bash
# mysql -uroot -p123456
</code></pre>
</li>
<li><p>java</p>
<pre><code class="bash"># jre 8
docker run -it openjdk:8u292-jre-slim bash

# jre 11
docker run -it openjdk:11.0.12-jre-slim bash
</code></pre>
</li>
<li><p><a href="https://github.com/eclipse/che">eclipse che（在线 IDE 服务）</a></p>
<pre><code class="bash"># 创建并启动 che 服务
docker run -it --rm -v /var/run/docker.sock:/var/run/docker.sock -v /home/data:/data eclipse/che start
</code></pre>
</li>
<li><p><a href="https://github.com/ghostplant/web-ubuntu-mate">Ubuntu Classic Desktop (GTK3-based Desktop Environment)</a>  </p>
<blockquote>
<p>Default VNC password: 123456, and you can update it via ‘vncpasswd’ command inside VNC X session.</p>
</blockquote>
<pre><code class="bash"># Download/Update latest Ubuntu image
docker pull ghostplant/flashback

# Chioce 1 - Web as Client: Using web browser to login - http://localhost:8443/
docker run -it --rm -p 8443:8443 -v /external:/root ghostplant/flashback

# Chioce 2 - VNCViewer as Client: Using VNC client to login &#39;localhost:1&#39;
# docker run -it --rm -p 5901:5901 -v /external:/root ghostplant/flashback
</code></pre>
</li>
<li><p><a href="https://github.com/cdr/code-server">code-server（在线 VS Code）</a></p>
<pre><code class="bash">docker run --rm -it -p 8080:8080 -v &quot;$PWD:/home/coder/project&quot; codercom/code-server --auth none
</code></pre>
</li>
<li><p><a href="https://docs.min.io/cn/minio-docker-quickstart-guide.html">minio</a></p>
<pre><code class="bash">docker run -p 9000:9000 --name minio1 \
    -e &quot;MINIO_ACCESS_KEY=AKIAIOSFODNN7EXAMPLE&quot; \
    -e &quot;MINIO_SECRET_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY&quot; \
    -v /mnt/data:/data \
    -v /mnt/config:/root/.minio \
    minio/minio server /data
</code></pre>
</li>
<li><p><a href="https://github.com/theia-ide/theia-apps#theia-docker">theia（在线 IDE）</a></p>
<pre><code class="bash">docker run -it --init -p 3000:3000 -v &quot;$(pwd):/home/project:cached&quot; theiaide/theia:next
</code></pre>
</li>
<li><p>clickhouse</p>
<pre><code class="bash">docker run -d \
    --name clickhouse-server \
    -p 9000:9000 \
    -p 8123:8123 \
    -p 9009:9009 \
    --ulimit nofile=262144:262144 \
    yandex/clickhouse-server
</code></pre>
</li>
<li><p><a href="https://github.com/cloudreve/Cloudreve">cloudreve</a></p>
<pre><code class="bash">docker run -d \
    --name cloudreve \
    -v /etc/cloudreve:/etc/cloudreve \
    -v /data/cloudreve:/data \
    -p 8081:8080 \
    littleplus/cloudreve-3.0.0-rc-1:sqlite
</code></pre>
<blockquote>
<ul>
<li>访问路径 <a href="http://127.0.0.1:8081，默认管理员账号">http://127.0.0.1:8081，默认管理员账号</a> admin@cloudreve.org，密码见控制台启动日志</li>
<li>配置使用 Aria2 离线下载文件<ol>
<li><a href="linux.md#aria2">安装、启动 Aria2 RPC 服务</a></li>
<li>管理员登录 cloudreve，进入 “管理面板” -&gt; “参数设置” -&gt; “离线下载”。配置 “RPC 服务器地址” 为 “<a href="http://127.0.0.1:6800/&quot;%EF%BC%8C&quot;RPC">http://127.0.0.1:6800/&quot;，&quot;RPC</a> Secret” 为 “yourpassword”，”临时下载目录” 为 “/home/aria2/data”，点击 “保存” 按钮</li>
</ol>
</li>
</ul>
</blockquote>
</li>
<li><p>轻量级搜索引擎 <a href="https://github.com/meilisearch/MeiliSearch">MeiliSearch</a><br>  内置 webui，开箱即用，包含词干提取、停用词、同义词、排名、过滤器和分页等功能</p>
<pre><code class="bash">docker run \
    -p 7700:7700 \
    -v &quot;$(pwd)/data.ms:/data.ms&quot; \
    getmeili/meilisearch
</code></pre>
</li>
<li><p>基于 <a href="https://github.com/GoogleContainerTools/distroless">distroless</a> 镜像（多阶段）构建精简镜像</p>
<pre><code class="dockerfile"># Start by building the application.
FROM golang:1.13-buster as build
WORKDIR /go/src/app
ADD . /go/src/app
RUN go get -d -v ./...
RUN go build -o /go/bin/app

# Now copy it into our base image.
FROM gcr.io/distroless/base-debian10
COPY --from=build /go/bin/app /
CMD [&quot;/app&quot;]
</code></pre>
</li>
<li><p>使用 <a href="https://github.com/nocodb/nocodb">nocodb</a> 将关系数据库转变为智能电子表格</p>
<pre><code class="bash">docker run -d --name nocodb -p 8080:8080 nocodb/nocodb
</code></pre>
</li>
<li><p>使用 <a href="https://github.com/inbucket/inbucket">inbucket</a>（轻量级邮件接受平台，基于 golang 开发，占用内存 15 MB，仅支持 POP3 和 SMTP 服务）搭建邮件测试服务</p>
<pre><code class="bash">docker run \
    -d \
    --name inbucket \
    -p 9000:9000 \ # 控制台监听接口
    -p 2500:2500 \ # SMTP 服务监听接口
    -p 1100:1100 \ # POP3 服务监听接口
    inbucket/inbucket

start http://127.0.0.1:9000
</code></pre>
</li>
<li><p>基于 Go 实现的搜索引擎 <a href="https://github.com/prabhatsharma/zinc">zinc</a></p>
<pre><code class="bash">docker run \
    -v /full/path/of/data:/data \
    -e DATA_PATH=&quot;/data&quot; \
    -e FIRST_ADMIN_USER=admin \
    -e FIRST_ADMIN_PASSWORD=Admin_1234 \
    -p 4080:4080 \
    --name zinc \
    public.ecr.aws/m5j1b6u0/zinc:v0.1.1

start http://127.0.0.1:4080
</code></pre>
</li>
<li><p><a href="https://blog.csdn.net/networken/article/details/108218569">docker in docker</a></p>
<ul>
<li><p><span id="docker_client_in_docker">客户端</span></p>
<ol>
<li>方法一：挂载主机上的 docker.sock 以及 docker 二进制文件<pre><code class="bash">docker run -it \
    -v /var/run/docker.sock:/var/run/docker.sock \ # 将宿主机的 docker 服务（daemon）挂载进容器内，使的容器内部 docker 客户端可以访问宿主机的 docker 服务
    -v $(which docker):/usr/bin/docker \
    -v /usr/lib64/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7 \
    ubuntu:xenial docker version
</code></pre>
</li>
<li>方法二：使用官方 docker 客户端<pre><code class="bash">docker run -it \
    -v /var/run/docker.sock:/var/run/docker.sock docker:latest \ # docker:latest 只包含 docker 客户端
    docker version
</code></pre>
<blockquote>
<p>本质上还是连接到主机节点上的 docker 引擎执行 docker 命令，实际容器中执行 docker 操作与在主机节点直接执行 docker 命令没有区别。</p>
</blockquote>
</li>
</ol>
</li>
<li><p>服务端 + 客户端</p>
<pre><code class="bash">docker run -it \
    --privileged \
    -d \
    --name docker-dind \
    docker:dind # docker:dind 包含 docker 客户端和 docker 服务端

# 使用带有 docker 客户端的容器连接到 dind 容器
docker run -it --link docker-dind:docker docker:latest version
</code></pre>
<pre><code class="bash"># 启用 TLS
docker network create dind

docker run \
    --privileged \
    --name docker-dind \
    -d \
    --network dind --network-alias docker \
    -e DOCKER_TLS_CERTDIR=/certs \
    -v docker-certs-ca:/certs/ca \
    -v docker-certs-client:/certs/client \
    docker:dind
</code></pre>
<blockquote>
<p>docker dind 方式有所不同，所有的 docker 操作真正在容器内部进行，包括创建的容器、拉取的镜像都保留在容器内部。<br>docker in docker 的原理是挂载 cgroup、tmpfs、securityfs、cgroup 的 SUBSYS、关掉不需要的文件描述符、最后启动 dockerd。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><a href="https://github.com/HelloZeroNet/ZeroNet">ZeroNet</a></p>
<pre><code class="bash">docker run -d -e &quot;ENABLE_TOR=true&quot; -v &lt;local_data_folder&gt;:/root/data -p 15441:15441 -p 127.0.0.1:43110:43110 nofish/zeronet
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/2025/03/22/elasticsearch/</url>
    <content><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/index.html">ElasticSearch</a></h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><ol>
<li><p>下载 elasticsearch</p>
<pre><code class="bash">curl -O https://mirrors.huaweicloud.com/elasticsearch/6.2.4/elasticsearch-6.2.4.tar.gz
</code></pre>
</li>
<li><p>解压</p>
<pre><code class="bash">tar zxvf elasticsearch-6.2.4.tar.gz
</code></pre>
</li>
<li><p>运行</p>
<pre><code class="bash">cd ./elasticsearch-6.2.4/bin

./elasticsearch -d # 以 daemon 方式启动
# ./elasticsearch
</code></pre>
</li>
<li><p>访问</p>
<pre><code class="bash">curl http://127.0.0.1:9200/
</code></pre>
</li>
</ol>
<h3 id="搭建可视化控制台-Kibana"><a href="#搭建可视化控制台-Kibana" class="headerlink" title="搭建可视化控制台 Kibana"></a>搭建可视化控制台 Kibana</h3><ol>
<li><p>下载</p>
<pre><code class="bash">curl -O &#39;https://mirrors.huaweicloud.com/kibana/6.2.4/kibana-6.2.4-windows-x86_64.zip&#39;
</code></pre>
</li>
<li><p>解压</p>
<pre><code class="bash">unzip kibana-6.2.4-windows-x86_64.zip
</code></pre>
</li>
<li><p>运行</p>
<pre><code class="bash">cd ./kibana-6.2.4-windows-x86_64/bin
./kibana
</code></pre>
</li>
<li><p>访问</p>
<pre><code class="cmd">start http://127.0.0.1:5601/
</code></pre>
</li>
</ol>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote>
<p>索引、类型、文档、字段关系如下  </p>
<ul>
<li>Indices 索引，类似关系型数据中的数据库  <ul>
<li>Types 类型（≥7.0 版本已移除），类似关系型数据中的数据表  <ul>
<li>Documents 文档，类似关系型数据中的表记录行  <ul>
<li>Fields 字段，类似关系型数据中的表字段</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL(数据定义语言)"></a>DDL(数据定义语言)</h3><ul>
<li><p>查看所有索引库</p>
<pre><code class="bash">curl http://127.0.0.1:9200/_cat/indices?v
</code></pre>
</li>
<li><p>创建索引库</p>
<pre><code class="bash"># # 创建索引库，如 commerce
curl -XPUT http://127.0.0.1:9200/commerce

# 创建带有类型、映射的索引
curl -XPUT http://127.0.0.1:9200/commerce -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;settings&quot;: &#123;
        &quot;number_of_shards&quot;: 2, # 分片个数，默认为 5
        &quot;number_of_replicas&quot;: 2 # 副本个数，默认为 1
    &#125;,
    &quot;mappings&quot;: &#123;
        &quot;offering&quot;: &#123; # 类型，7.0+ 版本无需该参数。如果需要设置默认类型，类型名称应为 &quot;_default_&quot;
            &quot;properties&quot;: &#123;
                &quot;name&quot;: &#123;
                    &quot;type&quot;: &quot;text&quot;, # 不指定分词器时，会使用默认的 standard 分词器
                    # &quot;index&quot;: true, # 是否索引。默认为 true，未索引的字段不可查询
                    # &quot;store&quot;: true, # 是否存储。默认为 false，可以查询但是原始数据不能返回，但是这通常无关紧要，因为 _source 默认会存储
                    # &quot;copy_to&quot;: &quot;description&quot; # 索引过程中，将字段值拷贝到指定字段
                    &quot;fields&quot;: &#123;
                        &quot;suggest&quot;: &#123;
                            &quot;type&quot;: &quot;completion&quot;, # Completion 建议器用
                            &quot;analyzer&quot;: &quot;english&quot;
                        &#125;
                    &#125;
                &#125;,
                &quot;description&quot;: &#123;
                    &quot;type&quot;: &quot;text&quot;,
                    &quot;analyzer&quot;: &quot;english&quot;, # 指定使用 english 分词器
                    &quot;fielddata&quot;: true # text 类型不能用于聚合，需要开启 fielddata 以支持聚合，但会额外占用存储。默认为关闭状态。
                &#125;,
                &quot;brand&quot;: &#123;
                    &quot;type&quot;: &quot;keyword&quot; # 不需要分词的字段将 type 设置为 keyword，可以节省空间和提高写性能
                &#125;,
                &quot;product&quot;: &#123;
                    &quot;type&quot;: &quot;nested&quot;,
                    &quot;properties&quot;: &#123;
                        &quot;price&quot;: &#123;
                            &quot;type&quot;: &quot;double&quot;
                        &#125;,
                        &quot;stock&quot;: &#123;
                            &quot;type&quot;: &quot;long&quot;
                        &#125;
                    &#125;
                &#125;,
                &quot;timestamp&quot;: &#123;
                    &quot;type&quot;: &quot;date&quot;,
                    # &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||epoch_millis&quot; # 格式为 `yyyy-MM-dd HH:mm:ss` 或毫秒数
                &#125;
            &#125;
        &#125;
    &#125;
&#125;&#39;
</code></pre>
</li>
<li><p>修改索引库</p>
<pre><code class="bash"># 修改索引库映射
curl -XPOST http://127.0.0.1:9200/commerce/offering/_mapping -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;properties&quot;: &#123;
        &quot;spu&quot;: &#123; # SPU 编码
            &quot;type&quot;: &quot;text&quot;
        &#125;,
        &quot;tag&quot;: &#123; # 标签、关键词
            &quot;type&quot;: &quot;keyword&quot;
        &#125;
    &#125;
&#125;&#39;

# 修改索引的副本数
curl -XPUT http://127.0.0.1:9200/commerce/_settings -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;number_of_replicas&quot;: 1
&#125;&#39;

# 修改索引刷新间隔时间（当数据添加到索引后并不能马上被查询到，等到索引刷新后才会被查询到，默认为 1 秒）
curl -XPUT http://127.0.0.1:9200/commerce/_settings -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;index&quot;: &#123;
        &quot;refresh_interval&quot;: &quot;5s&quot; # 配置间隔时间为 5 秒。单位支持 ms（毫秒）、s（秒）、m（分钟），默认单位为毫秒。值为 -1 时，表示不刷新索引。
    &#125;
&#125;&#39;

# 开启字段的缓存，用于 text 类型字段的聚合索引（默认 text 类型不能用于聚合）
curl -XPUT http://127.0.0.1:9200/commerce/offering/_mapping -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;properties&quot;: &#123;
        &quot;description&quot;: &#123; # 字段名为 description
            &quot;type&quot;: &quot;text&quot;,
            &quot;fielddata&quot;: true # 开启 fielddata 缓存
        &#125;
    &#125;
&#125;&#39;
</code></pre>
</li>
<li><p>查看索引库映射</p>
<pre><code class="bash">curl -XGET http://127.0.0.1:9200/commerce/_mapping?pretty
</code></pre>
</li>
<li><p>删除索引库</p>
<pre><code class="bash"># 删除索引库，如 commerce
curl -XDELETE http://127.0.0.1:9200/commerce

# 删除所有索引
curl -XDELETE http://127.0.0.1:9200/_all
curl -XDELETE http://127.0.0.1:9200/*
</code></pre>
</li>
<li><p>关闭、打开索引</p>
<pre><code class="bash"># 关闭索引
curl -XPOST http://127.0.0.1:9200/commerce/_close

# 打开索引
curl -XPOST http://127.0.0.1:9200/commerce/_open
</code></pre>
</li>
<li><p>重建（迁移）索引</p>
<pre><code class="bash"># 对当前的索引 commerce 添加别名
curl -XPOST http://127.0.0.1:9200/_aliases -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;actions&quot;: [
        &#123;
            &quot;add&quot;: &#123;
                &quot;index&quot;: &quot;commerce&quot;,
                &quot;alias&quot;: &quot;commerce_lastest&quot;
            &#125;
        &#125;
    ]
&#125;&#39;

# 新增⼀个索引
NEW_INDEX_NAME=commerce_`date +%Y%m%d%H%M%S`
INDEX_MAPPINGS=`curl -XGET http://127.0.0.1:9200/commerce/_mappings | sed &#39;s/^&#123;&quot;commerce&quot;://&#39; | sed &#39;s/&#125;$//&#39;`
curl -XPUT &quot;http://127.0.0.1:9200/commerce_$(date +%Y%m%d%H%M%S)&quot; -H &#39;Content-Type: application/json&#39; -d &quot;$INDEX_MAPPINGS&quot;

# 同步数据至新索引，wait_for_completion 表示是否同步执行（true）还是异步执行（false）
curl -XPOST http://127.0.0.1:9200/_reindex?wait_for_completion=true -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;source&quot;: &#123;
        &quot;index&quot;: &quot;commerce&quot;
    &#125;,
    &quot;dest&quot;: &#123;
        &quot;index&quot;: &quot;&#39;$NEW_INDEX_NAME&#39;&quot;
    &#125;
&#125;&#39;

# 替换别名
curl -XPOST http://127.0.0.1:9200/_aliases -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;actions&quot;: [
        &#123;
            &quot;add&quot;: &#123;
                &quot;index&quot;: &quot;&#39;$NEW_INDEX_NAME&#39;&quot;,
                &quot;alias&quot;: &quot;commerce_lastest&quot;
            &#125;
        &#125;,
        &#123;
            &quot;remove&quot;: &#123;
                &quot;index&quot;: &quot;commerce&quot;,
                &quot;alias&quot;: &quot;commerce_lastest&quot;
            &#125;
        &#125;
    ]
&#125;&#39;

# 删除旧的索引
curl -XDELETE http://127.0.0.1:9200/commerce

# 验证新的索引
curl -XPOST http://127.0.0.1:9200/commerce_lastest/_search?pretty -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;query&quot;: &#123;
        &quot;match_all&quot;: &#123; &#125;
    &#125;
&#125;&#39;
</code></pre>
</li>
</ul>
<h3 id="DML-数据操纵语言"><a href="#DML-数据操纵语言" class="headerlink" title="DML(数据操纵语言)"></a>DML(数据操纵语言)</h3><ul>
<li><p>新增</p>
<pre><code class="bash"># 可以不用预先创建索引库，es 将会自动创建索引库
curl -XPOST http://127.0.0.1:9200/commerce/offering -H &#39;Content-Type:application/json&#39; -d &#39;&#123;
    &quot;name&quot;: &quot;Apple iPhone 8&quot;,
    &quot;price&quot;: 823.88
&#125;&#39;

curl -XPUT http://127.0.0.1:9200/commerce/offering/1?refresh -H &#39;Content-Type:application/json&#39; -d &#39;&#123; # 参数 refresh 表示添加数据时忽略 refresh_interval 配置，直接触发刷新索引
    &quot;name&quot;: &quot;Apple iPhone X&quot;,
    &quot;price&quot;: 1129.08
&#125;&#39;
</code></pre>
</li>
<li><p>修改</p>
<pre><code class="bash"># 根据 id 修改
curl -XPOST http://127.0.0.1:9200/commerce/offering/1/_update -H &#39;Content-Type:application/json&#39; -d &#39;&#123;
    &quot;doc&quot;: &#123;
        &quot;price&quot;: 1098.56
    &#125;
&#125;&#39;

# 根据条件修改，如果没有 description 字段，则修改其 description 字段值为 NA
curl -XPOST http://127.0.0.1:9200/commerce/offering/_update_by_query -H &#39;Content-Type:application/json&#39; -d &#39;&#123;
    &quot;script&quot;: &#123;
        &quot;source&quot;: &quot;ctx._source[\&quot;description\&quot;] = \&quot;NA\&quot;&quot; # 语法参考 https://www.elastic.co/guide/en/elasticsearch/reference/6.2/painless-api-reference.html
    &#125;,
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;must_not&quot;: [&#123;
                &quot;exists&quot;: &#123;
                    &quot;field&quot;: &quot;description&quot;
                &#125;
            &#125;]
        &#125;
    &#125;
&#125;&#39;
</code></pre>
</li>
<li><p>查询</p>
<pre><code class="bash"># 根据 id 查询
curl -XGET http://127.0.0.1:9200/commerce/offering/7081550

# 查询
curl http://127.0.0.1:9200/commerce/_search?pretty -H &#39;Content-Type: application/json&#39; -d &#39;&#123; # 参数 pretty 用于格式化显示结果
    &quot;query&quot;: &#123;
        &quot;match&quot;: &#123;
            &quot;name&quot;: &quot;iPhone&quot;
        &#125;
    &#125;
&#125;&#39;
</code></pre>
</li>
<li><p>计数</p>
<pre><code class="bash">curl http://127.0.0.1:9200/commerce/_count -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;query&quot;: &#123;
        &quot;match&quot;: &#123;
            &quot;name&quot;: &quot;iPhone&quot;
        &#125;
    &#125;
&#125;&#39;
</code></pre>
</li>
<li><p>删除</p>
<pre><code class="bash"># P.S. Deleting a document doesn’t immediately remove the document from disk; it just marks it as deleted. Elasticsearch will clean up deleted documents in the background as you continue to index more data.
curl -XDELETE http://127.0.0.1:9200/commerce/offering/7081550

# 根据条件删除
curl -XPOST http://127.0.0.1:9200/commerce/_delete_by_query?conflicts=proceed \ # conflicts=proceed 表示强制执行删除（执行批量删除的时候，可能会发生版本冲突）
-H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;query&quot;: &#123;
        &quot;match&quot;: &#123;
            &quot;name&quot;: &quot;iPhone&quot;
        &#125;
    &#125;
&#125;&#39;

# 删除文档的时候，是将新文档写入，同时将旧文档标记为已删除。 磁盘空间是否释放取决于新旧文档是否在同一个segment file里面，因此ES后台的segment merge在合并segment file的过程中有可能触发旧文档的物理删除。但因为一个shard可能会有上百个segment file，还是有很大几率新旧文档存在于不同的segment里而无法物理删除。想要手动释放空间，只能是定期做一下force merge，并且将max_num_segments设置为1。
curl -XPOST http://127.0.0.1:9200/_forcemerge?only_expunge_deletes=true&amp;max_num_segments=1
</code></pre>
</li>
<li><p>批量导入</p>
<pre><code class="bash"># curl -XPOST http://127.0.0.1:9200/commerce/offering/_bulk?pretty -H &#39;Content-Type: application/x-ndjson&#39; --data-binary $&#39;
curl -XPOST http://127.0.0.1:9200/_bulk -H &#39;Content-Type: application/json&#39; -d &#39;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;1600139446635&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;HUAWEI Mate 40 Pro+&quot;,&quot;description&quot;:&quot;HUAWEI Mate 40 Pro+ Kirin 9000 SoC chip super-sensing movie image wired and wireless dual super fast charge mobile phones&quot;,&quot;price&quot;:2050.00,&quot;brand&quot;:&quot;Huawei&quot;,&quot;rom&quot;:[&quot;256GB&quot;],&quot;ram&quot;:[&quot;12GB&quot;],&quot;color&quot;:[&quot;Black&quot;,&quot;White&quot;]&#125;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;1600065238546&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;Honor 9i&quot;,&quot;description&quot;:&quot;In stock Original Huawei Honor 9i Mobile Phone 64GB 128GB Face Recogntion Phone 5.84 inch Android 8.0 Huawei 4G Smartphone&quot;,&quot;price&quot;:119.00,&quot;brand&quot;:&quot;Honor&quot;,&quot;rom&quot;:[&quot;64GB&quot;],&quot;ram&quot;:[&quot;4GB&quot;],&quot;color&quot;:[&quot;Black&quot;,&quot;Blue&quot;]&#125;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;62454454292&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;HUAWEI Mate 20X&quot;,&quot;description&quot;:&quot;Global New HUAWEI Mate 20X 7.2 inch 4000mAh Battery Android Smartphone 4G Mobile Phone&quot;,&quot;price&quot;:467.00,&quot;brand&quot;:&quot;Huawei&quot;,&quot;rom&quot;:[&quot;64GB&quot;,&quot;128GB&quot;],&quot;ram&quot;:[&quot;8GB&quot;],&quot;color&quot;:[&quot;Silver&quot;,&quot;Blue&quot;]&#125;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;1600062036029&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;Oneplus 8 Pro&quot;,&quot;description&quot;:&quot;Original Oneplus 8 Pro 5G Mobile Phone 6.78 inch 865 Octa Core Four Rear Camera NFC Smartphone&quot;,&quot;price&quot;:599.00,&quot;brand&quot;:&quot;Oneplus&quot;,&quot;rom&quot;:[&quot;128GB&quot;,&quot;256GB&quot;],&quot;ram&quot;:[&quot;8GB&quot;,&quot;12GB&quot;],&quot;color&quot;:[&quot;Black&quot;,&quot;Blue&quot;,&quot;Green&quot;]&#125;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;1600193343226&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;OnePlus Nord N10&quot;,&quot;description&quot;:&quot;HOT OnePlus Nord N10 5G Mobile Phone 6.49 inch 90Hz Smooth Display 6GB 128GB Snapdragon 690 64MP Smartphone Oneplus Nord N10&quot;,&quot;price&quot;:269.00,&quot;brand&quot;:&quot;Oneplus&quot;,&quot;rom&quot;:[&quot;128GB&quot;],&quot;ram&quot;:[&quot;6GB&quot;],&quot;color&quot;:[&quot;Midnight Ice&quot;]&#125;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;1600170560559&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;Xiaomi Poco M3&quot;,&quot;description&quot;:&quot;Xiomi mobile phone poco Celular poco M3 phones 128GB 64GB on sale global version xiaomi poco m3&quot;,&quot;price&quot;:148.00,&quot;brand&quot;:&quot;Xiomi&quot;,&quot;rom&quot;:[&quot;64GB&quot;],&quot;ram&quot;:[&quot;6GB&quot;],&quot;color&quot;:[&quot;Blue&quot;]&#125;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;62347912813&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;Redmi Note 9S&quot;,&quot;description&quot;:&quot;Global Version Xiaomi Redmi Note 9S 4GB 64GB Full Screen AI Voice Assistant Mobile Phone&quot;,&quot;price&quot;:155.00,&quot;brand&quot;:&quot;Redmi&quot;,&quot;rom&quot;:[&quot;64GB&quot;],&quot;ram&quot;:[&quot;4GB&quot;],&quot;color&quot;:[&quot;Black&quot;,&quot;Blue&quot;,&quot;Grey&quot;]&#125;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;1600151821373&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;Realme 7&quot;,&quot;description&quot;:&quot;Realme 7 6.5 Inch Perforated Screen 8GB RAM 128GB 48MP Camera Mobile Phone&quot;,&quot;price&quot;:219,&quot;brand&quot;:&quot;Realme&quot;,&quot;rom&quot;:[&quot;128GB&quot;],&quot;ram&quot;:[&quot;8GB&quot;],&quot;color&quot;:[&quot;Blue&quot;,&quot;White&quot;]&#125;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;1600207086497&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;Realme GT&quot;,&quot;description&quot;:&quot;Original realme GT 5G Mobile Phone 12GB 256GB 6.43\&quot;120Hz SuperAMOLED Snapdragon 888 Octa Core 65W Fast Charger NFC realme GT&quot;,&quot;price&quot;:560.00,&quot;brand&quot;:&quot;Realme&quot;,&quot;rom&quot;:[&quot;256GB&quot;],&quot;ram&quot;:[&quot;12GB&quot;],&quot;color&quot;:[&quot;Blue&quot;,&quot;White&quot;,&quot;Yellow&quot;]&#125;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;10023605369768&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;Apple iPhone 12&quot;,&quot;description&quot;:&quot;Apple iPhone 12 All China Netcom 5g mobile phone black all China Netcom 128G&quot;,&quot;price&quot;:913.76,&quot;brand&quot;:&quot;Apple&quot;,&quot;rom&quot;:[&quot;128GB&quot;,&quot;256GB&quot;],&quot;ram&quot;:[&quot;4GB&quot;],&quot;color&quot;:[&quot;Black&quot;,&quot;White&quot;,&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;]&#125;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;100005492551&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;Apple iPhone 11&quot;,&quot;description&quot;:&quot;Apple iPhone 11 (A2223) 128GB Black Mobile Unicom Telecom 4G mobile phone dual card dual standby [Airpods package]&quot;,&quot;price&quot;:857.30,&quot;brand&quot;:&quot;Apple&quot;,&quot;rom&quot;:[&quot;64GB&quot;,&quot;128GB&quot;,&quot;256GB&quot;],&quot;ram&quot;:[&quot;4GB&quot;],&quot;color&quot;:[&quot;Black&quot;,&quot;White&quot;,&quot;Red&quot;,&quot;Green&quot;,&quot;Blue&quot;,&quot;Purple&quot;]&#125;
&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;commerce&quot;,&quot;_type&quot;:&quot;offering&quot;,&quot;_id&quot;:&quot;10026915217186&quot;&#125;&#125;
&#123;&quot;name&quot;:&quot;OPPO Find X3&quot;,&quot;description&quot;:&quot;Oppo find X3 series 5g mobile phone oppo curved screen findx2pro findx3pro find X3 Mirror Black (8GB + 128GB) 5g all China Netcom [quick delivery from stock + 2-year warranty + 50% refund after sun exposure]&quot;,&quot;price&quot;:686.54,&quot;brand&quot;:&quot;Oppo&quot;,&quot;rom&quot;:[&quot;128GB&quot;,&quot;256GB&quot;],&quot;ram&quot;:[&quot;8GB&quot;,&quot;12GB&quot;],&quot;color&quot;:[&quot;Black&quot;,&quot;Blue&quot;,&quot;White&quot;]&#125;
&#39;
</code></pre>
<pre><code class="bash"># 导入 json 文件
curl -O &#39;http://storage.ikyxxs.com/es/bookdata.json
echo &#39;&#39;&gt;&gt; bookdata.json # https://stackoverflow.com/questions/48810804/missing-newline-for-adding-with-bulk-api

curl -XPOST &#39;localhost:9200/test/book/_bulk?pretty&#39; -H &#39;Content-Type: application/x-ndjson&#39; --data-binary @bookdata.json
curl -XPOST &#39;localhost:9200/test/book/_count?pretty
</code></pre>
</li>
</ul>
<h4 id="URL-查询"><a href="#URL-查询" class="headerlink" title="URL 查询"></a>URL 查询</h4><pre><code class="bash"># 查询全部
curl -XGET http://127.0.0.1:9200/commerce/_search
curl -XGET http://127.0.0.1:9200/commerce/_search?q=*

# 查询所有字段中包含关键字 iphone 的文档(当索引一个文档，ES 把所有字符串字段值连接起来放在一个大字符串中，它被索引为一个特殊的字段 _all)
curl -XGET http://127.0.0.1:9200/commerce/_search?q=iphone

# 查询 name 字段中包含 oppo、vivo 或 &quot;iphone 8&quot;，timestamp 晚于 2014-09-10，_all 字段包含 android 或 ios 的文档
# curl -XGET &#39;http://127.0.0.1:9200/commerce/_search?pretty&amp;q=name:(oppo vivo &quot;iphone 8&quot;) AND timestamp:&gt;2014-09-10 OR (android ios)&#39;

# 查询 name 字段包含 oppo 或 vivo、timestamp 晚于 2014-09-10、_all 字段包含 android 或 ios
# curl -XGET http://127.0.0.1:9200/commerce/_search?q=+name:(oppo vivo) +timestamp:&gt;2014-09-10 +(android ios)

# 根据时间范围查询
# curl -XGET http://127.0.0.1:9200/commerce/_search?q=timestamp:[&quot;2021-01-01 00:00:00&quot; TO *]
</code></pre>
<h4 id="DSL-查询"><a href="#DSL-查询" class="headerlink" title="DSL 查询"></a>DSL 查询</h4><ul>
<li><p>基本查询</p>
<ul>
<li>精准查询（term、terms）<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;term&quot;: &#123;
            &quot;brand&quot;: &quot;Apple&quot;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;terms&quot;: &#123; // terms 查询是 term 的扩展，可以支持多个 value 匹配，只需要一个匹配就可以了
            &quot;brand&quot;: [&quot;Apple&quot;, &quot;Huawei&quot;]
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>分词匹配查询（match）<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match_all&quot;: &#123; &#125; // match_all 用于查询全部信息
    &#125;
&#125;
</code></pre>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match&quot;: &#123; // 单个字段进行分词匹配查询
            &quot;name&quot;: &quot;iphone&quot;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;multi_match&quot;: &#123; // 多字段进行匹配查询
            &quot;query&quot;: &quot;iphone&quot;,
            &quot;fields&quot;: [&quot;name&quot;, &quot;description&quot;]
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match_phrase&quot;: &#123; // 短语匹配查询，ElasticSearch 引擎首先分析（analyze）查询字符串，从分析后的文本中构建短语查询，这意味着必须匹配短语中的所有分词，并且保证各个分词的相对位置不变
            // &quot;description&quot;: &quot;4GB 64GB&quot;
            &quot;description&quot;: &#123;
                &quot;query&quot;: &quot;8GB 128GB&quot;,
                &quot;slop&quot;: 2 // 表示 &quot;8GB 128GB&quot; 这个短语中，&quot;128GB&quot; 移动了 1 次，即最多移动了不超过 2 次，就可以跟 &quot;8GB RAM 128GB&quot; 匹配上了
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match&quot;: &#123;
            &quot;name&quot;: &#123;
                &quot;query&quot;: &quot;iphone&quot;,
                &quot;fuzziness&quot;: &quot;AUTO&quot;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>模糊查询（fuzzy）<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;fuzzy&quot;: &#123;
            &quot;name&quot;: &#123;
                &quot;value&quot;: &quot;iphene&quot;,
                &quot;fuzziness&quot;: 1 // 最大编辑距离（莱文斯坦编辑距离），即可以允许纠正（入参 value）错误拼写的字符个数，默认为 2，推荐值 1。可设置为 &quot;AUTO&quot;，表示字符串长度为 1-2 时最大编辑距离为 0，长度为 3-5 时最大编辑距离为 1，长度大于 5 时最大编辑距离为 2（例如 AUTO 模式下，入参 &quot;abcd&quot; 能匹配 &quot;abcde&quot; 但不能匹配 &quot;abcdef&quot;，而入参 &quot;abcdef&quot; 能匹配 &quot;abcd&quot;）
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>通配符查询（wildcard）<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;wildcard&quot;: &#123;
            &quot;brand&quot;: &quot;Real*&quot; // 字符 &#39;?&#39; 将会匹配任何字符，&#39;*&#39; 将会匹配零个或者多个字符
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>布尔查询（bool）<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;must&quot;: [ // must 表示查询条件为 and 关系
                &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;iphone&quot; &#125;&#125;,
                &#123; &quot;match&quot;: &#123; &quot;description&quot;: &quot;unicom&quot; &#125;&#125;
            ]
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;filter&quot;: [ // 同 must，但子句将不计算得分
                &#123;
                    &quot;terms&quot;: &#123;
                        &quot;brand&quot;: [&quot;Huawei&quot;, &quot;Honor&quot;]
                    &#125;
                &#125;
            ],
            // // should 与 filter/must 混用时，会导致 should 失效，解决方法如下
            // // 方法一：新增 minimum_should_match 设置
            // &quot;should&quot;: [
            //     &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;iphone&quot; &#125;&#125;,
            //     &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;oppo&quot;&#125;&#125;
            // ],
            // &quot;minimum_should_match&quot;: 1 // 值为整数或百分数，如 1 或 &quot;50%&quot;。表示至少满足 should 中 1 个语句，或者 50% 的语句。
            // // 方法二：将 should 嵌在 must 语句中
            // &quot;must&quot;: &#123;
            //     &quot;bool&quot;: &#123;
            //         &quot;should&quot;: [
            //             &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;iphone&quot; &#125;&#125;,
            //             &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;oppo&quot;&#125;&#125;
            //         ]
            //     &#125;
            // &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;should&quot;: [ // should 表示查询条件为 or 关系
                &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;iphone&quot; &#125;&#125;,
                &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;oppo&quot;&#125;&#125;
            ]
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;must_not&quot;: [
                &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;iphone&quot; &#125;&#125;,
                &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;oppo&quot; &#125;&#125;
            ]
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;must&quot;: [
                &#123;
                    &quot;term&quot;: &#123;
                        &quot;brand&quot;: &quot;Apple&quot;
                    &#125;
                &#125;,
                &#123;
                    &quot;bool&quot;: &#123; // 嵌套 bool 查询，查询品牌为 Apple 并且价格不高于 900 的文档
                        &quot;must_not&quot;: [
                            &#123;
                                &quot;range&quot;: &#123;
                                    &quot;price&quot;: &#123;
                                        &quot;gte&quot;: 900.00
                                    &#125;
                                &#125;
                            &#125;
                        ]
                    &#125;
                &#125;
            ]
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>前缀查询（prefix）<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;prefix&quot;: &#123;
            &quot;name&quot;: &quot;real&quot;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>正则查询（regexp）<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;regexp&quot;: &#123;
            &quot;name&quot;: &quot;[a-z]+&quot;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>查询字符串查询（query_string）<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;query_string&quot;: &#123;
            &quot;query&quot;: &quot;(xiaomi AND voice) OR movie&quot; // 查询包含 &quot;xiaomi&quot; 和 &quot;voice&quot; 或者 &quot;movie&quot;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;query_string&quot;: &#123;
            &quot;query&quot;: &quot;xiaomi OR movie&quot;, // 查询 name 和 description 中包含 &quot;xiaomi&quot; 和 &quot;movie&quot; 的文档
            &quot;fields&quot;: [&quot;name&quot;, &quot;description&quot;]
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>范围查询（range）<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;range&quot;: &#123;
            &quot;timestamp&quot;: &#123;
                &quot;gte&quot;: &quot;1999-01-01&quot;,
                &quot;lte&quot;: &quot;2000-01-01&quot;
                // &quot;gt&quot;: &quot;now-1M/d&quot;, // 当前时间的上一天，四舍五入到最近的一天（`+1h`: 加 1 小时，`-1d`: 减 1 天，`/d`: 四舍五入到最近的一天。表达式支持的时间单位有 `y`: 年，`M`: 月，`w`: 星期，`d`: 天，`h`: 小时，`H`: 小时，`m`: 分，`s`: 秒）
                // &quot;lt&quot;: &quot;now/d&quot; // 当前时间，四舍五入到最近的一天
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>id 查询<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;ids&quot;: &#123;
            &quot;values&quot;: [&quot;1600139446635&quot;, &quot;1600062036029&quot;]
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>排序</p>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match_all&quot;: &#123; &#125;
    &#125;,
    &quot;sort&quot;: &#123;
        &quot;price&quot;: &#123; // 根据价格倒序排序
            &quot;order&quot;: &quot;desc&quot;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>返回指定字段</p>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match_all&quot;: &#123; &#125;
    &#125;,
    &quot;_source&quot;: [&quot;name&quot;, &quot;price&quot;]
&#125;
</code></pre>
</li>
<li><p>分页</p>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match_all&quot;: &#123; &#125;
    &#125;,
    &quot;from&quot;: 0,
    &quot;size&quot;: 5
&#125;
</code></pre>
<blockquote>
<p>该分页查询方法，在深度分页场景下，查询效率低：每次查询，es 需要执行 from + size 条数据然后处理后返回。<br>同时 es 限制了分页的深度，默认配置最大值 max_result_window 为 10000：from + size ≤ 10000，即默认配置下查询第 ≥10000 条数据时会抛异常。</p>
</blockquote>
</li>
<li><p>聚合查询</p>
<pre><code class="json">// 统计词频
GET /commerce/_search
&#123;
    &quot;size&quot;: 0,
    &quot;aggs&quot;: &#123;
        &quot;description_words&quot;: &#123; // 自定义聚合名称
            &quot;terms&quot;: &#123;
                &quot;size&quot;: 10,
                &quot;field&quot;: &quot;description&quot;
            &#125;
        &#125;
    &#125;
&#125;

// 按时间统计
GET /commerce/_search
&#123;
    &quot;size&quot;: 0,
    &quot;query&quot;: &#123;
        &quot;match&quot;: &#123;
            &quot;name&quot;: &quot;iPhone&quot;
        &#125;
    &#125;,
    &quot;aggs&quot;: &#123;
        &quot;xxx&quot;: &#123;
            &quot;date_histogram&quot;: &#123;
                &quot;field&quot;: &quot;timestamp&quot;,
                &quot;interval&quot;: &quot;day&quot;, // `year` 或 `1y`: 1 年、`quarter` 或 `1q`: 1 季度、`month` 或 `1M`: 1 月份、`week` 或 `1w`: 1 星期、`day` 或 `1d`: 1 天、`hour` 或 `1h`: 1 小时、`minute` 或 `1m`: 1 分钟、`second` 或 `1s`: 1 秒，例如 `5m` 表示每 5 分钟，`day` 表示每天
                &quot;format&quot;: &quot;yyyy-MM-dd&quot;, // yyyy-MM-dd HH:mm:ss.SSSZ
                &quot;time_zone&quot;: &quot;+08:00&quot;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>查询结果高亮</p>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match&quot;: &#123;
            &quot;name&quot;: &quot;iphone&quot;
        &#125;
    &#125;,
    &quot;highlight&quot;: &#123;
        // &quot;pre_tags&quot;: [
        //     &quot;&lt;em class=\&quot;c_color\&quot;&gt;&quot;
        // ],
        // &quot;post_tags&quot;: [
        //     &quot;&lt;/em&gt;&quot;
        // ],
        &quot;fields&quot;: &#123;
            &quot;name&quot;: &#123;&#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>其它</p>
<pre><code class="json">// 多字段组合查询
GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;must&quot;: [ // must 表示 and，should 表示 or
                &#123;
                    &quot;match&quot;: &#123;
                        &quot;description&quot;: &quot;Camera&quot;
                    &#125;
                &#125;, &#123;
                    &quot;wildcard&quot;: &#123;
                        &quot;brand&quot;: &quot;Real*&quot;
                    &#125;
                &#125;
            ]
        &#125;
    &#125;,
    &quot;sort&quot;: &#123;
        &quot;timestamp&quot;: &#123;
            &quot;order&quot;: &quot;desc&quot;
        &#125;
    &#125;,
    &quot;from&quot;: 0,
    &quot;size&quot;: 10
&#125;

// 根据品牌去重并展示每个品牌的一条记录
GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match_all&quot;: &#123; &#125;
    &#125;,
    &quot;collapse&quot;: &#123;
        &quot;field&quot;: &quot;brand&quot;, // 要进行折叠的字段
        &quot;inner_hits&quot;: &#123; // 折叠的参数集
            &quot;name&quot;: &quot;test&quot;, // 自定义 hits 的名称
            &quot;ignore_unmapped&quot;: true, // 默认为 false，如果存在一些数据没有折叠字段的会报错，设置为 true 可以避免类似的报错
            &quot;from&quot;: 0,
            &quot;size&quot;: 0, // from 和 size 用来控制想要返回的折叠列表，这里我的需求是重复 brand 相同仅返回头条，所以两个参数均设置为 0，如果有需求折叠列表的可以通过这里控制
            &quot;version&quot;: false,
            &quot;explain&quot;: false,
            &quot;track_scores&quot;: true,
            &quot;sort&quot;: [&#123; // 折叠列表的排序，折叠列表中要把谁显示在第一个的排序，比如这样做是将该折叠列表的数据按字段 price 倒序排列
                &quot;price&quot;: &#123;
                    &quot;order&quot;: &quot;desc&quot;
                &#125;
            &#125;]
        &#125;
    &#125;
&#125;

// 聚合查询所有品牌
GET /commerce/_search
&#123;
    &quot;size&quot;: 0,
    &quot;aggs&quot;: &#123;
        &quot;brands&quot;: &#123; // 自定义组名为 brands
            &quot;terms&quot;: &#123;
                &quot;field&quot;: &quot;brand&quot;
            &#125;
        &#125;
    &#125;
&#125;

// 聚合去重，展示每个品牌下最高价格的 1 条记录
GET /commerce/_search
&#123;
    &quot;size&quot;: 0,
    &quot;aggs&quot;: &#123;
        &quot;brands&quot;: &#123;
            &quot;terms&quot;: &#123;
                &quot;field&quot;: &quot;brand&quot;
            &#125;,
            &quot;aggs&quot;: &#123;
                &quot;product&quot;: &#123;
                    &quot;top_hits&quot;: &#123;
                        &quot;sort&quot;: [
                            &#123;
                                &quot;price&quot;: &#123;
                                    &quot;order&quot;: &quot;desc&quot;
                                &#125;
                            &#125;
                        ],
                        &quot;size&quot;: 1 // 每个品牌下展示 1 条商品记录
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

// 统计每种品牌的平均价格
GET /commerce/_search
&#123;
    &quot;size&quot;: 0,
    &quot;aggs&quot;: &#123;
        &quot;popular_brand&quot;: &#123;
            &quot;terms&quot;: &#123;
                &quot;field&quot;: &quot;brand&quot;
            &#125;,
            &quot;aggs&quot;: &#123;
                &quot;avg_price&quot;: &#123;
                    &quot;avg&quot;: &#123;
                        &quot;field&quot;: &quot;price&quot;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

// 按照日期聚合分组，求出每个月个数
// GET /commerce/_search
// &#123;
//     &quot;size&quot;: 0,
//     &quot;aggs&quot;: &#123;
//         &quot;date_sales&quot;: &#123;
//             &quot;date_histogram&quot;: &#123;
//                 &quot;field&quot;: &quot;timestamp&quot;,
//                 &quot;calendar_interval&quot;: &quot;month&quot;,
//                 &quot;format&quot;: &quot;yyyy-MM-dd&quot;,
//                 &quot;min_doc_count&quot;: 0,
//                 &quot;extended_bounds&quot;: &#123;
//                     &quot;min&quot;: &quot;2019-01-01&quot;,
//                     &quot;max&quot;: &quot;2019-12-31&quot;
//                 &#125;
//             &#125;
//         &#125;
//     &#125;
// &#125;

// 统计每个季度每个品牌的销售额，及每个季度销售总额
// GET /commerce/_search
// &#123;
//     &quot;size&quot;: 0,
//     &quot;aggs&quot;: &#123;
//         &quot;date_sales&quot;: &#123;
//             &quot;date_histogram&quot;: &#123;
//                 &quot;field&quot;: &quot;timestamp&quot;,
//                 &quot;calendar_interval&quot;: &quot;quarter&quot;,
//                 &quot;format&quot;: &quot;yyyy-MM-dd&quot;,
//                 &quot;min_doc_count&quot;: 0,
//                 &quot;extended_bounds&quot;: &#123;
//                     &quot;min&quot;: &quot;2019-01-01&quot;,
//                     &quot;max&quot;: &quot;2020-12-31&quot;
//                 &#125;
//             &#125;,
//             &quot;aggs&quot;: &#123;
//                 &quot;group_by_brand&quot;: &#123;
//                     &quot;terms&quot;: &#123;
//                         &quot;field&quot;: &quot;brand&quot;
//                     &#125;,
//                     &quot;aggs&quot;: &#123;
//                         &quot;sum_price&quot;: &#123;
//                             &quot;sum&quot;: &#123;
//                                 &quot;field&quot;: &quot;price&quot;
//                             &#125;
//                         &#125;
//                     &#125;
//                 &#125;,
//                 &quot;total_sum_price&quot;: &#123;
//                     &quot;sum&quot;: &#123;
//                         &quot;field&quot;: &quot;price&quot;
//                     &#125;
//                 &#125;
//             &#125;
//         &#125;
//     &#125;
// &#125;
</code></pre>
</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><details>
<summary>深度分页</summary>

<ul>
<li><p>使用 skip + size 深度分页时（大于阈值 max_result_window，默认为 10000）导致查询失败，可以配置修改 max_result_window 阈值</p>
<pre><code class="bash">curl -XPUT &quot;http://127.0.0.1:9200/commerce/_settings&quot; -d &#39;&#123;
    &quot;index&quot;: &#123;
        &quot;max_result_window&quot;: 50000
    &#125;
&#125;&#39;
</code></pre>
</li>
<li><p>深度分页 scroll（游标查询，无法实现实时查询）<br>  如果我们分页要请求大数据集或者一次请求要获取较大的数据集，scroll 都是一个非常好的解决方案。<br>  使用 scroll 滚动搜索，可以先搜索一批数据，然后下次再搜索一批数据，以此类推，直到搜索出全部的数据来 scroll 搜索会在第一次搜索的时候，保存一个当时的视图快照，之后只会基于该旧的视图快照提供数据搜索，如果这个期间数据变更，是不会让用户看到的。每次发送 scroll 请求，我们还需要指定一个 scroll 参数，指定一个时间窗口，每次搜索请求只要在这个时间窗口内能完成就可以了。</p>
<pre><code class="json">GET /commerce/offering/_search?scroll=5m # scroll=5m 表示该窗口过期时间为 5 分钟
&#123;
    &quot;query&quot;: &#123;
        &quot;match_all&quot;: &#123;&#125;
    &#125;,
    &quot;size&quot;: 2
&#125;
# 返回 _scroll_id，如 DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAC0YFmllUjV1QTIyU25XMHBTck1XNHpFWUEAAAAAAAAtGRZpZVI1dUEyMlNuVzBwU3JNVzR6RVlBAAAAAAAALRsWaWVSNXVBMjJTblcwcFNyTVc0ekVZQQAAAAAAAC0aFmllUjV1QTIyU25XMHBTck1XNHpFWUEAAAAAAAAtHBZpZVI1dUEyMlNuVzBwU3JNVzR6RVlB
</code></pre>
<pre><code class="json">GET /_search/scroll
&#123;
    &quot;scroll&quot;: &quot;5m&quot;,
    &quot;scroll_id&quot;: &quot;DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAC0YFmllUjV1QTIyU25XMHBTck1XNHpFWUEAAAAAAAAtGRZpZVI1dUEyMlNuVzBwU3JNVzR6RVlBAAAAAAAALRsWaWVSNXVBMjJTblcwcFNyTVc0ekVZQQAAAAAAAC0aFmllUjV1QTIyU25XMHBTck1XNHpFWUEAAAAAAAAtHBZpZVI1dUEyMlNuVzBwU3JNVzR6RVlB&quot;
&#125;
</code></pre>
</li>
<li><p>深度分页 search_after（假分页）<br>  search_after 是一种假分页方式，根据上一页的最后一条数据来确定下一页的位置，同时在分页请求的过程中，如果有索引数据的增删改查，这些变更也会实时的反映到游标上。为了找到每一页最后一条数据，每个文档必须有一个全局唯一值，官方推荐使用 _uid 作为全局唯一值，但是只要能表示其唯一性就可以。<br>  为了演示，我们需要给上文中的 commerce 索引增加一个 uid 字段表示其唯一性。</p>
<pre><code class="json">GET /commerce/offering/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match_all&quot;: &#123;&#125;
    &#125;,
    &quot;size&quot;: 2,
    &quot;sort&quot;: [
        &#123;
            &quot;uid&quot;: &quot;desc&quot;
        &#125;
    ]
&#125;
</code></pre>
<pre><code class="json">GET /commerce/offering/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match_all&quot;: &#123;&#125;
    &#125;,
    &quot;size&quot;: 2,
    &quot;search_after&quot;: [1005], # 下一次分页，需要将上述分页结果集的最后一条数据的值带上。
    &quot;sort&quot;: [
        &#123;
            &quot;uid&quot;: &quot;desc&quot;
        &#125;
    ]
&#125;
</code></pre>
</li>
</ul>
</details>

<details>
<summary>词权重</summary>

<blockquote>
<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/query-time-boosting.html">查询时权重提升</a></p>
</blockquote>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;should&quot;: [
                &#123;
                    &quot;term&quot;: &#123;
                        &quot;brand&quot;: &#123;
                            &quot;value&quot;: &quot;Apple&quot;,
                            &quot;boost&quot;: 4
                        &#125;
                    &#125;
                &#125;,
                &#123;
                    &quot;match&quot;: &#123;
                        &quot;description&quot;: &#123;
                            &quot;query&quot;: &quot;iphone&quot;,
                            &quot;boost&quot;: 2 // description 查询 iphone 语句的重要性是 name 查询 huawei、vivo 的 2 倍，因为它的权重提升值为 2 。默认没有设置 boost 的查询语句的值为 1
                        &#125;
                    &#125;
                &#125;,
                &#123;
                    &quot;match&quot;: &#123;
                        &quot;name&quot;: &quot;huawei vivo&quot;
                    &#125;
                &#125;
            ]
        &#125;
    &#125;,
    &quot;explain&quot;: true, // 设置 explain: true，可返回评分计算过程
    &quot;sort&quot;: &#123; // 当有多个排序字段时，按字段出现顺序为优先级进行排序
        &quot;_score&quot;: &#123; // 首先根据得分排序
            &quot;order&quot;: &quot;desc&quot; // 按照评分降序排序
        &#125;,
        &quot;price&quot;: &#123; // 然后根据价格排序
            &quot;order&quot;: &quot;asc&quot; // 升序排序
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<ul>
<li>_score 算法，可通过查询 DSL 中设置 explain: true 查看评分计算过程<ul>
<li>BM25（ES≥5.0（即 Lucene≥6.0）版本默认评分算法）</li>
<li>TF/IDF（≥7.0 版本已废弃）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>

<details>
<summary>评分计算 explanation</summary>

<blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/wangjiuyong/articles/7055724.html">https://www.cnblogs.com/wangjiuyong/articles/7055724.html</a></p>
</blockquote>
<pre><code class="json">&#123;
    &quot;took&quot;: 69,
    &quot;timed_out&quot;: false,
    &quot;_shards&quot;: &#123;
        &quot;total&quot;: 2,
        &quot;successful&quot;: 2,
        &quot;skipped&quot;: 0,
        &quot;failed&quot;: 0
    &#125;,
    &quot;hits&quot;: &#123;
        &quot;total&quot;: 4, // 查找到的文档共有 4 个
        &quot;max_score&quot;: null,
        &quot;hits&quot;: [
            &#123;
                &quot;_shard&quot;: &quot;[commerce][1]&quot;,
                &quot;_node&quot;: &quot;_NK2n9X4SoCW6PKoRBuF2w&quot;,
                &quot;_index&quot;: &quot;commerce&quot;,
                &quot;_type&quot;: &quot;offering&quot;,
                &quot;_id&quot;: &quot;10023605369768&quot;,
                &quot;_score&quot;: 2.3536685,
                &quot;_source&quot;: &#123;
                    &quot;name&quot;: &quot;Apple iPhone 12&quot;,
                    &quot;description&quot;: &quot;Apple iPhone 12 All China Netcom 5g mobile phone black all China Netcom 128G&quot;,
                    ...
                &#125;,
                &quot;sort&quot;: [
                    2.3536685,
                    913.76
                ],
                &quot;_explanation&quot;: &#123;
                    &quot;value&quot;: 2.3536685,
                    &quot;description&quot;: &quot;sum of:&quot;,
                    &quot;details&quot;: [
                        &#123;
                            &quot;value&quot;: 2.3536685,
                            &quot;description&quot;: &quot;weight(description:iphon in 3) [PerFieldSimilarity], result of:&quot;, // 在文档（内部 id 为 3）中搜索字段 description 包含关键词 iphon 的权重评分结果如下
                            &quot;details&quot;: [
                                &#123;
                                    &quot;value&quot;: 2.3536685,
                                    &quot;description&quot;: &quot;score(doc=3,freq=1.0 = termFreq=1.0\n), product of:&quot;,
                                    &quot;details&quot;: [
                                        &#123;
                                            &quot;value&quot;: 2.0,
                                            &quot;description&quot;: &quot;boost&quot;,
                                            &quot;details&quot;: []
                                        &#125;,
                                        &#123;
                                            &quot;value&quot;: 1.0296195,
                                            &quot;description&quot;: &quot;idf, computed as log(1 + (docCount - docFreq + 0.5) / (docFreq + 0.5)) from:&quot;,
                                            &quot;details&quot;: [
                                                &#123;
                                                    &quot;value&quot;: 2.0,
                                                    &quot;description&quot;: &quot;docFreq&quot;, // 满足当前查询条件（description 中包含搜索词 iphon ）的文档个数
                                                    &quot;details&quot;: []
                                                &#125;,
                                                &#123;
                                                    &quot;value&quot;: 6.0,
                                                    &quot;description&quot;: &quot;docCount&quot;, // 数据对应的分片下的文档总个数
                                                    &quot;details&quot;: []
                                                &#125;
                                            ]
                                        &#125;,
                                        &#123;
                                            &quot;value&quot;: 1.1429797,
                                            &quot;description&quot;: &quot;tfNorm, computed as (freq * (k1 + 1)) / (freq + k1 * (1 - b + b * fieldLength / avgFieldLength)) from:&quot;,
                                            &quot;details&quot;: [
                                                &#123;
                                                    &quot;value&quot;: 1.0,
                                                    &quot;description&quot;: &quot;termFreq=1.0&quot;, // 搜索词 iphon 在字段 description 中出现的次数
                                                    &quot;details&quot;: []
                                                &#125;,
                                                &#123;
                                                    &quot;value&quot;: 1.2,
                                                    &quot;description&quot;: &quot;parameter k1&quot;,
                                                    &quot;details&quot;: []
                                                &#125;,
                                                &#123;
                                                    &quot;value&quot;: 0.75,
                                                    &quot;description&quot;: &quot;parameter b&quot;,
                                                    &quot;details&quot;: []
                                                &#125;,
                                                &#123;
                                                    &quot;value&quot;: 20.166666,
                                                    &quot;description&quot;: &quot;avgFieldLength&quot;, // 当前数据所在分片下，所有文档的字段 description 分词并且去除停用词部分的 terms 总个数，除以文档总数
                                                    &quot;details&quot;: []
                                                &#125;,
                                                &#123;
                                                    &quot;value&quot;: 14.0, // 这里可能不是整数，是因为：lucene 为了降低存储的空间，实现了区间映射功能，即在存储字段的长度时，没有存储实际长度，而是存储了一个 byte 类型的值（0-255），每个值对应了 BM25Similarity 中 NORM_TABLE 数组的下标 index
                                                    &quot;description&quot;: &quot;fieldLength&quot;, // 满足查询条件的文档的字段 description 的长度（分词并去除停用词部分 terms 个数）
                                                    &quot;details&quot;: []
                                                &#125;
                                            ]
                                        &#125;
                                    ]
                                &#125;
                            ]
                        &#125;
                    ]
                &#125;
            &#125;,
            ...
        ]
    &#125;
&#125;
</code></pre>
<p>BM25Similarity（NORM_TABLE）根据真实长度计算 fieldLength 值算法参考如下（ElasticSearch 5.3 版本）</p>
<pre><code class="javascript">var SmallFloat = &#123;
    byte315ToFloat: function (b) &#123;
        if (b == 0) return 0.0;
        let bits = (b &amp; 0xff) &lt;&lt; (24 - 3);
        bits += (63 - 15) &lt;&lt; 24;
        return this.intBitsToFloat(bits);
    &#125;,
    floatToByte315: function (f) &#123;
        let bits = this.floatToRawIntBits(f);
        let smallfloat = bits &gt;&gt; (24 - 3);
        if (smallfloat &lt;= ((63 - 15) &lt;&lt; 3)) &#123;
            return (bits &lt;= 0) ? 0 : 1;
        &#125;
        if (smallfloat &gt;= ((63 - 15) &lt;&lt; 3) + 0x100) &#123;
            return -1;
        &#125;
        return (smallfloat - ((63 - 15) &lt;&lt; 3));
    &#125;,
    intBitsToFloat: function (b) &#123;
        let buf = new ArrayBuffer(4);
        (new Uint32Array(buf))[0] = b;
        return (new Float32Array(buf))[0];
    &#125;,
    floatToRawIntBits: function (f) &#123;
        let buf = new ArrayBuffer(4);
        (new Float32Array(buf))[0] = f;
        return (new Uint32Array(buf))[0];
    &#125;
&#125;
var BM25Similarity = &#123;
    getNormTable: function () &#123;
        let NORM_TABLE = new Array(256);
        for (let i = 1; i &lt; 256; i++) &#123;
            let f = SmallFloat.byte315ToFloat(i);
            NORM_TABLE[i] = 1.0 / (f * f);
        &#125;
        NORM_TABLE[0] = 1.0 / NORM_TABLE[255]; // otherwise inf
        return NORM_TABLE;
    &#125;,
    getFieldLength: function (realFieldLength) &#123;
        let idx = SmallFloat.floatToByte315(Math.sqrt(1.0 / realFieldLength)); // the index of NORM_TABLE in BM25Similarity
        if (idx == 0) &#123;
            idx = 255;
        &#125;
        let f = SmallFloat.byte315ToFloat(idx);
        return 1.0 / (f * f);
    &#125;,
    getMightRealFieldLength: function (fieldLength, max = 100) &#123;
        let idx = this.getNormTable().findIndex((v, i) =&gt; (v + &quot;&quot;).startsWith(fieldLength + &quot;&quot;));
        if (idx == 255) &#123;
            idx = 0;
        &#125;
        let o = [];
        for (let i = 1; i &lt; max; i++) &#123;
            if (SmallFloat.floatToByte315(Math.sqrt(1.0 / i)) == idx) &#123;
                o.push(i);
            &#125;
        &#125;
        return o;
    &#125;
&#125;
BM25Similarity.getFieldLength(5); // 5.224489795918367
BM25Similarity.getMightRealFieldLength(5.2244897); // [5]
</code></pre>
</details>

<details>
<summary>设置评分算法</summary>

<blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-similarity.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-similarity.html</a></p>
</blockquote>
<pre><code class="json">PUT /commerce
&#123;
    &quot;settings&quot;: &#123;
        &quot;index&quot;: &#123;
            &quot;similarity&quot;: &#123;
                &quot;my_similarity&quot;: &#123;
                    &quot;type&quot;: &quot;BM25&quot;,
                    &quot;k1&quot;: 1.2, // （默认为 1.2）
                    &quot;b&quot;: 0 // （默认为 0.7）设置 b 为 0，则评分不受词频影响
                &#125;
            &#125;
        &#125;
    &#125;,
    &quot;mappings&quot;: &#123;
        &quot;offering&quot;: &#123;
            &quot;properties&quot;: &#123;
                &quot;description&quot;: &#123;
                    &quot;type&quot;: &quot;text&quot;,
                    &quot;similarity&quot;: &quot;my_similarity&quot;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</details>

<details>
<summary>使用 function_score 自定义计算评分</summary>

<blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#query-dsl-function-score-query">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#query-dsl-function-score-query</a></p>
</blockquote>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;function_score&quot;: &#123;
            &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;,
            &quot;boost&quot;: &quot;5&quot;, 
            &quot;functions&quot;: [
                &#123;
                    &quot;filter&quot;: &#123; &quot;match&quot;: &#123; &quot;test&quot;: &quot;bar&quot; &#125; &#125;,
                    &quot;random_score&quot;: &#123;&#125;, 
                    &quot;weight&quot;: 23
                &#125;,
                &#123;
                    &quot;filter&quot;: &#123; &quot;match&quot;: &#123; &quot;test&quot;: &quot;cat&quot; &#125; &#125;,
                    &quot;weight&quot;: 42
                &#125;
            ],
            &quot;max_boost&quot;: 42,
            &quot;score_mode&quot;: &quot;max&quot;,
            &quot;boost_mode&quot;: &quot;multiply&quot;,
            &quot;min_score&quot;: 42
        &#125;
    &#125;
&#125;
</code></pre>
</details>

<details>
<summary>使用 script_score 自定义计算评分</summary>

<blockquote>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-script-score-query.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-script-score-query.html</a></p>
</blockquote>
</details>

</blockquote>

</details>

<details>
<summary>联想词/建议器</summary>

<ul>
<li><p>term 建议器（基于 analyze 分析过后的单个 term 去提供建议）</p>
<pre><code class="json">GET /commerce/_search
&#123;
    &quot;suggest&quot;: &#123;
        &quot;my_suggestion&quot;: &#123; // 自定义搜索建议，可以为多个
            &quot;text&quot;: &quot;huaw real&quot;,
            &quot;term&quot;: &#123;
                &quot;suggest_mode&quot;: &quot;missing&quot;, // 可选值 missing（默认）、popular、always，其中 missing 表示如果 rock 在索引的字典中已存在，则不返回
                &quot;field&quot;: &quot;name&quot; // 联想字段需要支持分词，如 text 类型
                // &quot;max_edit&quot;: 2 // 可选参数，可选值为 1、2（默认），表示 text 中的词与索引字典中值的编辑距离，小于或等于这个值才会被建议返回
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>phrase 建议器（在 term 建议器基础上，考量多个 term 是否同时存在、相邻程度、词频等）</p>
<pre><code class="json">// GET commerce/_search
// &#123;
//     &quot;suggest&quot;: &#123;
//         &quot;text&quot;: &quot;jeva null point exception&quot;,
//         &quot;simple_phrase&quot;: &#123;
//             &quot;phrase&quot;: &#123;
//                 &quot;field&quot;: &quot;title&quot;,
//                 &quot;size&quot;: 3,
//                 &quot;direct_generator&quot;: [
//                     &#123;
//                         &quot;field&quot;: &quot;title&quot;,
//                         &quot;suggest_mode&quot;: &quot;always&quot;,
//                         &quot;min_word_length&quot;: 4
//                     &#125;
//                 ],
//                 &quot;collate&quot;: &#123;
//                     &quot;query&quot;: &#123;
//                         &quot;source&quot;: &#123;
//                             &quot;match&quot;: &#123;
//                                 &quot;&#123;&#123;field_name&#125;&#125;&quot;: &quot;&#123;&#123;suggestion&#125;&#125;&quot;
//                             &#125;
//                         &#125;
//                     &#125;,
//                     &quot;params&quot;: &#123;
//                         &quot;field_name&quot;: &quot;title&quot;
//                     &#125;,
//                     &quot;prune&quot;: true
//                 &#125;
//             &#125;
//         &#125;
//     &#125;
// &#125;
</code></pre>
</li>
<li><p>completion 建议器</p>
<ol>
<li>配置字段类型为 completion 类型<pre><code class="json">PUT /commerce
&#123;
    &quot;mappings&quot;: &#123;
        &quot;offering&quot;: &#123;
            &quot;properties&quot;: &#123;
                &quot;name&quot;: &#123;
                    &quot;type&quot;: &quot;text&quot;,
                    &quot;analyzer&quot;: &quot;english&quot;,
                    &quot;fields&quot;: &#123;
                        &quot;suggest&quot;: &#123;
                            &quot;type&quot;: &quot;completion&quot;,
                            &quot;analyzer&quot;: &quot;english&quot;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>查询<pre><code class="json">GET /commerce/_search
&#123;
    &quot;suggest&quot;: &#123;
        &quot;my_suggestion&quot;: &#123;
            &quot;prefix&quot;: &quot;hua&quot;,
            &quot;completion&quot;: &#123;
                &quot;field&quot;: &quot;name.suggest&quot;,
                &quot;fuzzy&quot;: &#123; // 可选，表示开启模糊匹配
                    // &quot;fuzziness&quot;: &quot;AUTO&quot; // 默认为 AUTO
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ol>
</li>
<li><p>context 建议器</p>
</li>
</ul>
</details>

<details>
<summary>同义词</summary>

<ol>
<li>定义一个同义词分析器<pre><code class="json">PUT /commerce
&#123;
    &quot;settings&quot;: &#123;
        &quot;analysis&quot;: &#123;
            &quot;filter&quot;: &#123;
                &quot;my_synonym_filter&quot;: &#123; // 自定义了一个语汇单元过滤器
                    &quot;type&quot;: &quot;synonym&quot;,  // 指定过滤器使用同义词类型
                    &quot;synonyms&quot;: [ // 定义同义词。同义词不具备传递性，同一组同义词不应拆分为多行(组)写
                        &quot;ipod, i-pod, i pod =&gt; ipod&quot;, // 单向同义词: 索引或查询时，箭头左侧的词将会被映射成箭头右侧的词
                        &quot;马铃薯, 土豆, potato&quot; // 双向同义词: 索引时会同时建立同义词的倒排索引，查询时会同时对同义词的倒排索引匹配
                    ]
                &#125;
            &#125;,
            &quot;analyzer&quot;: &#123;
                &quot;my_synonyms&quot;: &#123; // 自定义了一个使用 my_synonym_filter 过滤器的自定义分析器
                    &quot;tokenizer&quot;: &quot;standard&quot;,
                    &quot;filter&quot;: [
                        &quot;lowercase&quot;,
                        &quot;my_synonym_filter&quot;
                    ]
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>测试使用同义词分析器<pre><code class="json">GET /_analyze
&#123;
    &quot;analyzer&quot;: &quot;my_synonyms&quot;,
    &quot;text&quot;: &quot;Elizabeth is the English queen&quot;
&#125;
</code></pre>
</li>
</ol>
</details>

<details>
<summary>停用词</summary>

</details>

<details>
<summary>分词器</summary>

<ul>
<li><p>使用标准分析器分析文本</p>
<pre><code class="bash">curl -XGET http://127.0.0.1:9200/_analyze?pretty -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;analyzer&quot;: &quot;standard&quot;,
    &quot;text&quot;: &quot;this is a text&quot;
&#125;&#39;
</code></pre>
</li>
<li><p>配置、使用 english 分析器（索引时分词、查询时分词）</p>
<pre><code class="json">POST /commerce
&#123;
    &quot;mappings&quot;: &#123;
        &quot;offering&quot;: &#123;
            &quot;properties&quot;: &#123;
                &quot;content&quot;: &#123;
                    &quot;type&quot;: &quot;text&quot;,
                    &quot;analyzer&quot;: &quot;english&quot;, // 索引时分词
                    &quot;search_analyzer&quot;: &quot;english&quot; // 查询时分词
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">POST /commerce/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match&quot;: &#123;
            &quot;content&quot;: &#123;
                &quot;query&quot;: &quot;hello world&quot;,
                &quot;analyzer&quot;: &quot;english&quot;, // 查询时使用指定分词器分词
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<blockquote>
<p>分词流程：<em>text</em> =&gt; char_filter(Character Filter/字符过滤器) =&gt; tokenizer(Tokenizer/分词器) =&gt; <em>token(词元)</em> =&gt; filter(Token Filter/分词过滤器) =&gt; <em>term(词)</em></p>
</blockquote>
<ul>
<li><p><span id="create_custom_analyzer">创建自定义分析器</span></p>
<blockquote>
<p>analyzer 分析器包含零或多个 character filters，一个 tokenizer，零或多个 token filters</p>
</blockquote>
<pre><code class="json">PUT /commerce
&#123;
    &quot;settings&quot;: &#123;
        &quot;analysis&quot;: &#123;
            &quot;char_filter&quot;: &#123;
                &quot;my_char_filter&quot;: &#123;
                    &quot;type&quot;: &quot;mapping&quot;,
                    &quot;mappings&quot;: [&quot;&amp; =&gt; and&quot;]
                &#125;
            &#125;,
            &quot;tokenizer&quot;: &#123;
                &quot;my_tokenizer&quot;: &#123;
                    &quot;type&quot;: &quot;nGram&quot;, // N-gram 模型，参考 https://blog.csdn.net/songbinxu/article/details/80209197
                    &quot;min_gram&quot;: &quot;2&quot;,
                    &quot;max_gram&quot;: &quot;3&quot;,
                    &quot;token_chars&quot;: [&quot;letter&quot;, &quot;digit&quot;]
                &#125;
            &#125;,
            &quot;filter&quot;: &#123;
                &quot;my_token_filter&quot;: &#123;
                    &quot;type&quot;: &quot;stop&quot;,
                    &quot;stopwords&quot;: [&quot;the&quot;, &quot;a&quot;]
                &#125;
            &#125;,
            &quot;analyzer&quot;: &#123;
                &quot;my_analyzer&quot;: &#123;
                    &quot;type&quot;: &quot;custom&quot;,
                    &quot;char_filter&quot;: [&quot;html_strip&quot;, &quot;my_char_filter&quot;],
                    &quot;tokenizer&quot;: &quot;my_tokenizer&quot;,
                    &quot;filter&quot;: [&quot;lowercase&quot;, &quot;my_token_filter&quot;]
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>分析文本</p>
<pre><code class="json">GET /_analyze
&#123;
    &quot;analyzer&quot;: &quot;my_analyzer&quot;,
    &quot;text&quot;: &quot;oppo &amp; apple&quot;,
    &quot;explain&quot;: true
&#125;
</code></pre>
<pre><code class="json">GET /_analyze
&#123;
    &quot;char_filter&quot;: [&quot;my_char_filter&quot;],
    &quot;tokenizer&quot;: &quot;my_tokenizer&quot;,
    &quot;filter&quot;: [
        &quot;lowercase&quot;,
        &quot;my_token_filter&quot;,
        &#123;
            &quot;type&quot;: &quot;stemmer&quot;,
            &quot;name&quot;: &quot;english&quot;
        &#125;
    ],
    &quot;text&quot;: &quot;oppo &amp; apple&quot;,
    &quot;explain&quot;: true
&#125;
</code></pre>
</li>
</ul>
<blockquote>

<details open>
<summary><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/analysis-analyzers.html">ES 内置的分析器 analyzer</a></summary>

<ul>
<li>standard<br>  未设置分析器时默认使用此分析器。在空格、符号处切，中文部分切割为一个一个的汉字。由 standard tokenizer, standard filter, lower case filter, stop filter 组成。</li>
<li>simple<br>  在空格、符号、数字处切割，中文部分不会切割为一个一个的汉字。由 lower case tokenizer 组成。</li>
<li>stop<br>  在空格、符号、数字、英文介词和冠词处切割，中文部分不会切割为一个一个的汉字。由 lower case tokenizer, stop filter 组成。</li>
<li>keyword<br>  不分词，内容整体作为一个 token。</li>
<li>whitespace<br>  只在空格处切割。</li>
<li><a href="http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/analysis-lang-analyzer.html">lang</a><br>  语言分析器有很多种，把语言全小写就是，比如 english、chinese。english、chinese 的效果都一样：在空格、符号、英文介词和冠词处切割，中文切割为一个一个的汉字。</li>
<li>pattern<br>  根据正则表达式来切割，默认使用的正则表达式是 \W+，在匹配 \W+ 的地方切割。\w 包括英文字母、阿拉伯数字和 _，\W 是任意一个非 \w 字符，中文字符也算 \W。</li>
<li>snowball<br>  由 standard tokenizer, standard filter, lower case filter, stop filter, snowball filter 组成。</li>
<li>custom<br>  自定义分词器，参考<a href="#create_custom_analyzer">创建自定义分词器</a>。由零或多个 char_filter，一个 tokenizer, 零或多个 filter 组成。</li>
</ul>
<blockquote>

<details>
<summary><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/analysis-charfilters.html">ES 内置的字符串过滤器 char_filter</a></summary>

<ul>
<li>mapping<br>  根据配置的映射关系替换字符。</li>
<li>html_strip<br>  去掉 HTML 元素。</li>
<li>pattern_replace<br>  用正则表达式处理字符串<pre><code class="json">// 驼峰分词
&#123;
    &quot;type&quot;: &quot;pattern_replace&quot;,
    &quot;pattern&quot;: &quot;(?&lt;=\\p&#123;Lower&#125;)(?=\\p&#123;Upper&#125;)&quot;,
    &quot;replacement&quot;: &quot; &quot;
&#125;
</code></pre>
<pre><code class="json">// 特殊符号分词
&#123;
    &quot;type&quot;: &quot;pattern_replace&quot;,
    &quot;pattern&quot;: &quot;(?:\\p&#123;Punct&#125;)&quot;,
    &quot;replacement&quot;: &quot; &quot;
&#125;
</code></pre>
</li>
</ul>
</details>

<details>
<summary><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/analysis-tokenizers.html">ES 内置的分词器 tokenizer</a></summary>

<ul>
<li>standard</li>
<li>edgeNGram</li>
<li>keyword<br>  不分词</li>
<li>letter<br>  按单词分</li>
<li>lowercase<br>  letter tokenizer, lower case filter</li>
<li>nGram</li>
<li>whitespace<br>  以空格为分隔符拆分</li>
<li>pattern<br>  定义分隔符的正则表达式</li>
<li>uax_url_email<br>  不拆分 url 和 email</li>
<li>path_hierarchy<br>  处理类似 <code>/path/to/somthing</code> 样式的字符串</li>
</ul>
</details>

<details>
<summary><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/analysis-tokenfilters.html">ES 内置的分词过滤器 filter</a></summary>

<ul>
<li>standard</li>
<li>asciifolding</li>
<li>length<br>  去掉太长或者太短的</li>
<li>lowercase<br>  转成小写</li>
<li>nGram</li>
<li>edgeNGram</li>
<li>porterStem<br>  波特词干算法</li>
<li>shingle<br>  定义分隔符的正则表达式</li>
<li>stop<br>  停用词，从 tokens 中删除停用词<pre><code class="json">&#123;
    &quot;type&quot;: &quot;stop&quot;,
    &quot;stopwords&quot;: [ // 停用词列表。可选，字符串或字符数组类型。默认为 &quot;_english_&quot;。如果值为 &quot;_none_&quot; 则表示停用词为空。
        &quot;_english_&quot;, // english 停用词列表
        &quot;and&quot;, &quot;is&quot;, &quot;the&quot; // 自定义停用词
    ],
    &quot;stopwords_path&quot;: &quot;stopwords.txt&quot; // 停用词词库路径。可选，字符串类型。词库文件必须为 UTF-8 编码。文件路径相对于 $ES_HOME/config 目录。修改词库文件后需要关闭和重新打开索引以更新停用词。
&#125;
</code></pre>
</li>
<li>word_delimiter<br>  将一个单词再拆成子分词，如 WiFi =&gt; Wi, Fi<pre><code class="json">&#123;
    &quot;type&quot;: &quot;word_delimiter&quot;
&#125;
</code></pre>
</li>
<li>stemmer<pre><code class="json">&#123;
    &quot;type&quot;: &quot;stemmer&quot;,
    &quot;name&quot;: &quot;english&quot;
&#125;
</code></pre>
</li>
<li>stemmer_override</li>
<li>keyword_marker</li>
<li>keyword_repeat</li>
<li>kstem</li>
<li>snowball</li>
<li>phonetic<br>  <a href="https://github.com/elasticsearch/elasticsearch-analysis-phonetic">插件</a></li>
<li>synonyms<br>  处理同义词<pre><code class="json">&#123;
    &quot;type&quot;: &quot;synonym&quot;,
    &quot;synonyms&quot;: [
        &quot;ipod, i-pod, i pod =&gt; ipod&quot;,
        &quot;马铃薯, 土豆, potato&quot;
    ]
    // &quot;synonyms_path&quot;: &quot;synonyms.txt&quot;
&#125;
</code></pre>
</li>
<li>dictionary_decompounder, hyphenation_decompounder<br>  分解复合词<pre><code class="json">&#123;
    &quot;type&quot;: &quot;dictionary_decompounder&quot;,
    &quot;word_list&quot;: [
        &quot;wi&quot; // 如 `wifi` 分词为 `wifi`, `wi`
    ],
    // &quot;word_list_path&quot;: &quot;words.txt&quot;,
    &quot;min_word_size&quot;: 2 // 最小单词长度，默认为 5。这里需要小于等于 2，否则 wifi 中的 wi 不能被拆分出来
&#125;
</code></pre>
</li>
<li>reverse<br>  反转字符串</li>
<li>elision<br>  去掉缩略语</li>
<li>truncate<br>  截断字符串</li>
<li>unique  </li>
<li>pattern_capture</li>
<li>pattern_replace<br>  用正则表达式替换</li>
<li>trim<br>  去掉空格</li>
<li>limit<br>  限制token数量</li>
<li>hunspell<br>  拼写检查</li>
<li>common_grams</li>
<li>arabic_normalization, persian_normalization</li>
</ul>
</details>

</blockquote>

</details>

</blockquote>

<ul>
<li>Payload<ul>
<li>搜索关键词 “To be, or not to be” 会被停用词全部忽略，从而导致无法搜到正确结果<br>  中文意思是“生存还是毁灭”，出自莎士比亚的名言</li>
<li>搜索关键词 “create” 或 “created” 会被分词为 “creat”<br>  使用 Porter stemmer 词干算法，会将 “create” 还原为 “creat”，但不会影响分词索引结果</li>
<li>搜索关键词 “西门子”(中文)、”ximenzi”(拼音)、”siemens”(英文)、”xmz”(拼音简写)、”西闷子”(中文纠错)、”ximenzhi”(拼音纠错)、”西”(中文前缀) 都能匹配或联想到“西门子”相关记录</li>
<li>搜索关键词 “汽车改装鲨鱼鳍”，ik 分词器中的 ik_smart analyzer 会将其分词为“汽车”、“改装”、“鲨”、“鱼鳍”，在自定义词库 ext_dict 中写入“鲨鱼鳍”后，优化分词结果为“汽车”、“改装”、“鲨鱼鳍”</li>
<li>搜索关键词 “海洛因” 会阻断查询并提示该词汇为敏感词汇</li>
<li>分词与屏蔽敏感词汇？”科技处女干事每月经过下属都要亲口交代24口交换机等技术性器件的安装工作”</li>
</ul>
</li>
</ul>
</details>

<details>
<summary>数据预处理（Pipeline）</summary>

<ol>
<li>创建一个 Pipeline 并命名为 my_timestamp_pipeline，用于自动生成时间戳<pre><code class="json">PUT /_ingest/pipeline/my_timestamp_pipeline
&#123;
    &quot;description&quot;: &quot;Adds a field to a document with the time of ingestion&quot;,
    &quot;processors&quot;: [
        &#123;
            &quot;set&quot;: &#123;
                &quot;field&quot;: &quot;timestamp&quot;,
                &quot;value&quot;: &quot;&#123;&#123;_ingest.timestamp&#125;&#125;&quot; // 该时间是 UTC+0 时间，晚于国内 8 小时
            &#125;
        &#125;
    ]
&#125;
</code></pre>
</li>
<li>新增数据时使用 my_timestamp_pipeline<pre><code class="json">PUT /commerce/offering/1?pipeline=my_timestamp_pipeline
&#123;
    &quot;name&quot;: &quot;Apple iPhone 8&quot;,
    &quot;price&quot;: 823.00
&#125;
</code></pre>
</li>
</ol>
</details>

<details>
<summary>配置使用 ik 分词器</summary>

<blockquote>
<p>参考 <a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
</blockquote>
<ol>
<li><p>安装</p>
<ol>
<li>下载插件<pre><code class="bash">curl -O -L https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.2.4/elasticsearch-analysis-ik-6.2.4.zip
</code></pre>
</li>
<li>解压至 $ES_HOME/plugins/ik 目录下<pre><code class="bash">unzip -d elasticsearch-6.2.4/plugins elasticsearch-analysis-ik-6.2.4.zip &amp;&amp; mv elasticsearch-6.2.4/plugins/elasticsearch elasticsearch-6.2.4/plugins/ik
</code></pre>
</li>
<li>重启 elasticsearch</li>
</ol>
</li>
<li><p>测试</p>
<pre><code class="bash">curl -XGET http://127.0.0.1:9200/_analyze?pretty -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;analyzer&quot;: &quot;ik_max_word&quot;,
    &quot;text&quot;: &quot;\u4e2d\u534e\u4eba\u6c11\u5171\u548c\u56fd\u56fd\u52a1\u9662\uff0c\u5373\u4e2d\u592e\u4eba\u6c11\u653f\u5e9c\uff0c\u662f\u6700\u9ad8\u56fd\u5bb6\u6743\u529b\u673a\u5173\u7684\u6267\u884c\u673a\u5173\uff0c\u662f\u6700\u9ad8\u56fd\u5bb6\u884c\u653f\u673a\u5173\u3002&quot; # 中华人民共和国国务院，即中央人民政府，是最高国家权力机关的执行机关，是最高国家行政机关。
&#125;&#39;
</code></pre>
<blockquote>
<p>ik 支持以下 analyzer 和 tokenizer</p>
<ul>
<li>analyzer: <code>ik_smart</code>（粗颗粒度拆分，适合 Phrase 查询）, <code>ik_max_word</code>（细颗粒度拆分，适合 Term 查询）</li>
<li>tokenizer: <code>ik_smart</code>, <code>ik_max_word</code></li>
</ul>
</blockquote>
</li>
<li><p>配置词库<br>编辑 ${ES_HOME}/plugins/ik/config/IKAnalyzer.cfg.xml，配置内容如下</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;
&lt;properties&gt;
    &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;

    &lt;!-- 本地词库 --&gt;
    &lt;entry key=&quot;ext_dict&quot;&gt;custom/mydict.dic;custom/single_word_low_freq.dic&lt;/entry&gt;&lt;!-- 用户可以在这里配置自己的扩展字典 --&gt;
    &lt;entry key=&quot;ext_stopwords&quot;&gt;custom/ext_stopword.dic&lt;/entry&gt;&lt;!-- 用户可以在这里配置自己的扩展停止词字典--&gt;

    &lt;!-- 远程词库（热更新 IK 分词） --&gt;
    &lt;!--
        其中 location 是指一个 url，如 http://yoursite.com/getCustomDict，该请求只需满足以下两点即可完成分词热更新：
            - 该 http 请求需要返回两个头部(header)，一个是 `Last-Modified`，一个是 `ETag`，这两者都是字符串类型，只要有一个发生变化，该插件就会去抓取新的分词进而更新词库。
            - 该 http 请求返回的内容格式是一行一个分词，换行符用 `\n` 即可。
        满足上面两点要求就可以实现热更新分词了，不需要重启 ES 实例。
        P.S. 可以将需自动更新的热词放在一个 UTF-8 编码的 .txt 文件里，放在 nginx 或其他简易 http server 下，当 .txt 文件修改时，http server 会在客户端请求该文件时自动返回相应的 Last-Modified 和 ETag。可以另外做一个工具来从业务系统提取相关词汇，并更新这个 .txt 文件
    --&gt;
    &lt;entry key=&quot;remote_ext_dict&quot;&gt;location&lt;/entry&gt;&lt;!-- 用户可以在这里配置远程扩展字典 --&gt;
    &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;http://xxx.com/xxx.dic&lt;/entry&gt;&lt;!-- 用户可以在这里配置远程扩展停止词字典 --&gt;
&lt;/properties&gt;
</code></pre>
</li>
<li><p>使用</p>
<ol>
<li>创建索引<pre><code class="bash">curl -XPUT http://127.0.0.1:9200/ik_test_idx
</code></pre>
</li>
<li>创建 mapping<pre><code class="bash">curl -XPOST http://127.0.0.1:9200/ik_test_idx/fulltext/_mapping -H &#39;Content-Type: application/json&#39; -d &#39;&#123;
    &quot;properties&quot;: &#123;
        &quot;content&quot;: &#123;
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot;: &quot;ik_max_word&quot;, # 索引时分词
            &quot;search_analyzer&quot;: &quot;ik_smart&quot; # 查询时分词
        &#125;
    &#125;
&#125;&#39;
</code></pre>
</li>
<li>创建记录<pre><code class="json">POST /ik_test_idx/fulltext/1
&#123;
    &quot;content&quot;: &quot;中华人民共和国国务院，即中央人民政府，是最高国家权力机关的执行机关，是最高国家行政机关。&quot;
&#125;
</code></pre>
</li>
<li>高亮查询<pre><code class="json">POST /ik_test_idx/fulltext/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;match&quot;: &#123;
            &quot;content&quot;: &quot;国家&quot;
        &#125;
    &#125;,
    &quot;highlight&quot;: &#123;
        // &quot;pre_tags&quot;: [&quot;&lt;tag1&gt;&quot;, &quot;&lt;tag2&gt;&quot;],
        // &quot;post_tags&quot;: [&quot;&lt;/tag1&gt;&quot;, &quot;&lt;/tag2&gt;&quot;],
        &quot;fields&quot;: &#123;
            &quot;content&quot;: &#123;&#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>联想词<ol>
<li>创建基于 ik 插件的自动补全 mapping<pre><code class="bash">curl -XPOST http://127.0.0.1:9200/ik_test_idx/fulltext/_mapping -d&#39;
&#123;
    &quot;suggest&quot;: &#123;
        &quot;properties&quot;: &#123;
            &quot;content&quot;: &#123;
                &quot;type&quot;: &quot;text&quot;,
                &quot;analyzer&quot;: &quot;ik_max_word&quot;,
                &quot;search_analyzer&quot;: &quot;ik_smart&quot;,
                &quot;fields&quot;: &#123;
                    &quot;suggest&quot;: &#123;
                        &quot;type&quot;: &quot;completion&quot;,
                        &quot;analyzer&quot;: &quot;ik_max_word&quot;,
                        &quot;search_analyzer&quot;: &quot;ik_smart&quot;,
                        &quot;payloads&quot;: false
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;&#39;
</code></pre>
</li>
<li>通过 _suggest 对 Completion Suggester 数据进行搜索<pre><code class="bash">curl -XPOST &quot;http://127.0.0.1:9200/ik_test_idx/_suggest&quot; -d&#39;
&#123;
    &quot;my-suggest&quot;: &#123;
        &quot;text&quot;: &quot;中华&quot;,
        &quot;completion&quot;: &#123;
            &quot;field&quot;: &quot;content.suggest&quot;,
            &quot;size&quot;: 10 // 返回结果数量
        &#125;
    &#125;
&#125;&#39;
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</details>

<details>
<summary>索引模板</summary>

<ol>
<li><p>创建索引模板，新建的索引名称需要匹配 “goods*” 才可以使用该模板</p>
<pre><code class="json">PUT _template/goods
&#123;
    &quot;index_patterns&quot;: &quot;goods*&quot;,
    &quot;settings&quot;: &#123;
        &quot;index.number_of_replicas&quot;: &quot;1&quot;,
        &quot;index.number_of_shards&quot;: &quot;5&quot;,
        &quot;index.translog.flush_threshold_size&quot;: &quot;512mb&quot;,
        &quot;index.translog.sync_interval&quot;: &quot;60s&quot;,
        &quot;index.codec&quot;: &quot;best_compression&quot;,
        &quot;analysis&quot;: &#123;
            &quot;filter&quot;: &#123;
                &quot;edge_ngram_filter&quot;: &#123;
                    &quot;type&quot;: &quot;edge_ngram&quot;,
                    &quot;min_gram&quot;: 1,
                    &quot;max_gram&quot;: 50
                &#125;,
                &quot;simple_pinyin_filter&quot;: &#123;
                    &quot;type&quot;: &quot;pinyin&quot;,
                    &quot;keep_first_letter&quot;: true,
                    &quot;keep_separate_first_letter&quot;: false,
                    &quot;keep_full_pinyin&quot;: false,
                    &quot;keep_original&quot;: false,
                    &quot;limit_first_letter_length&quot;: 50,
                    &quot;lowercase&quot;: true
                &#125;,
                &quot;full_pinyin_filter&quot;: &#123;
                    &quot;type&quot;: &quot;pinyin&quot;,
                    &quot;keep_first_letter&quot;: false,
                    &quot;keep_separate_first_letter&quot;: false,
                    &quot;keep_full_pinyin&quot;: true,
                    &quot;none_chinese_pinyin_tokenize&quot;: true,
                    &quot;keep_original&quot;: false,
                    &quot;limit_first_letter_length&quot;: 50,
                    &quot;lowercase&quot;: true
                &#125;
            &#125;,
            &quot;char_filter&quot;: &#123;
                &quot;charconvert&quot;: &#123;
                    &quot;type&quot;: &quot;mapping&quot;,
                    &quot;mappings_path&quot;: &quot;char_filter_text.txt&quot;
                &#125;
            &#125;,
            &quot;tokenizer&quot;: &#123;
                &quot;ik_max_word&quot;: &#123;
                    &quot;type&quot;: &quot;ik_max_word&quot;,
                    &quot;use_smart&quot;: true
                &#125;
            &#125;,
            &quot;analyzer&quot;: &#123;
                &quot;ngramIndexAnalyzer&quot;: &#123;
                    &quot;type&quot;: &quot;custom&quot;,
                    &quot;tokenizer&quot;: &quot;keyword&quot;,
                    &quot;filter&quot;: [
                        &quot;edge_ngram_filter&quot;,
                        &quot;lowercase&quot;
                    ],
                    &quot;char_filter&quot;: [
                        &quot;charconvert&quot;
                    ]
                &#125;,
                &quot;ngramSearchAnalyzer&quot;: &#123;
                    &quot;type&quot;: &quot;custom&quot;,
                    &quot;tokenizer&quot;: &quot;keyword&quot;,
                    &quot;filter&quot;: [
                        &quot;lowercase&quot;
                    ],
                    &quot;char_filter&quot;: [
                        &quot;charconvert&quot;
                    ]
                &#125;,
                &quot;ikIndexAnalyzer&quot;: &#123;
                    &quot;type&quot;: &quot;custom&quot;,
                    &quot;tokenizer&quot;: &quot;ik_max_word&quot;,
                    &quot;char_filter&quot;: [
                        &quot;charconvert&quot;
                    ]
                &#125;,
                &quot;ikSearchAnalyzer&quot;: &#123;
                    &quot;type&quot;: &quot;custom&quot;,
                    &quot;tokenizer&quot;: &quot;ik_max_word&quot;,
                    &quot;char_filter&quot;: [
                        &quot;charconvert&quot;
                    ]
                &#125;,
                &quot;simplePinyinIndexAnalyzer&quot;: &#123;
                    &quot;tokenizer&quot;: &quot;keyword&quot;,
                    &quot;filter&quot;: [
                        &quot;simple_pinyin_filter&quot;,
                        &quot;edge_ngram_filter&quot;,
                        &quot;lowercase&quot;
                    ]
                &#125;,
                &quot;simplePinyinSearchAnalyzer&quot;: &#123;
                    &quot;tokenizer&quot;: &quot;keyword&quot;,
                    &quot;filter&quot;: [
                        &quot;simple_pinyin_filter&quot;,
                        &quot;lowercase&quot;
                    ]
                &#125;,
                &quot;fullPinyinIndexAnalyzer&quot;: &#123;
                    &quot;tokenizer&quot;: &quot;keyword&quot;,
                    &quot;filter&quot;: [
                        &quot;full_pinyin_filter&quot;,
                        &quot;edge_ngram_filter&quot;,
                        &quot;lowercase&quot;
                    ]
                &#125;,
                &quot;fullPinyinSearchAnalyzer&quot;: &#123;
                    &quot;tokenizer&quot;: &quot;keyword&quot;,
                    &quot;filter&quot;: [
                        &quot;full_pinyin_filter&quot;,
                        &quot;lowercase&quot;
                    ]
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>在 $ES_HOME/config 目录下新建文件 char_filter_text.txt</p>
</li>
<li><p>基于模板创建索引</p>
<pre><code class="json">PUT /goods_01
&#123;
    &quot;mappings&quot;: &#123;
        &quot;doc&quot;: &#123;
            &quot;properties&quot;: &#123;
                &quot;id&quot;: &#123;
                    &quot;type&quot;: &quot;long&quot;
                &#125;,
                &quot;name&quot;: &#123;
                    &quot;type&quot;: &quot;text&quot;,
                    &quot;analyzer&quot;: &quot;ikIndexAnalyzer&quot;,
                    &quot;fields&quot;: &#123;
                        &quot;ngram&quot;: &#123;
                            &quot;type&quot;: &quot;text&quot;,
                            &quot;analyzer&quot;: &quot;ngramIndexAnalyzer&quot;
                        &#125;,
                        &quot;SPY&quot;: &#123;
                            &quot;type&quot;: &quot;text&quot;,
                            &quot;analyzer&quot;: &quot;simplePinyinIndexAnalyzer&quot;
                        &#125;,
                        &quot;FPY&quot;: &#123;
                            &quot;type&quot;: &quot;text&quot;,
                            &quot;analyzer&quot;: &quot;fullPinyinIndexAnalyzer&quot;
                        &#125;
                    &#125;
                &#125;,
                &quot;update_time&quot;: &#123;
                    &quot;type&quot;: &quot;date&quot;
                &#125;,
                &quot;deleted&quot;: &#123;
                    &quot;type&quot;: &quot;boolean&quot;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>查询</p>
<pre><code class="json">GET /goods_01/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;bool&quot;: &#123;
            &quot;must&quot;: [
                &#123;
                    &quot;dis_max&quot;: &#123; // 取相似度 score 最大的返回
                        &quot;tie_breaker&quot;: 0,
                        &quot;queries&quot;: [
                            &#123;
                                &quot;match&quot;: &#123;
                                    &quot;name.ngram&quot;: &#123;
                                        &quot;query&quot;: &quot;水果&quot;,
                                        &quot;operator&quot;: &quot;OR&quot;,
                                        &quot;analyzer&quot;: &quot;ngramSearchAnalyzer&quot;,
                                        &quot;prefix_length&quot;: 0,
                                        &quot;max_expansions&quot;: 50,
                                        &quot;fuzzy_transpositions&quot;: true,
                                        &quot;lenient&quot;: false,
                                        &quot;zero_terms_query&quot;: &quot;NONE&quot;,
                                        &quot;auto_generate_synonyms_phrase_query&quot;: true,
                                        &quot;boost&quot;: 5
                                    &#125;
                                &#125;
                            &#125;,
                            &#123;
                                &quot;term&quot;: &#123;
                                    &quot;name.SPY&quot;: &#123;
                                        &quot;value&quot;: &quot;水果&quot;,
                                        &quot;boost&quot;: 1
                                    &#125;
                                &#125;
                            &#125;,
                            &#123;
                                &quot;wildcard&quot;: &#123;
                                    &quot;name.SPY&quot;: &#123;
                                        &quot;wildcard&quot;: &quot;*水果*&quot;,
                                        &quot;boost&quot;: 0.8
                                    &#125;
                                &#125;
                            &#125;,
                            &#123;
                                &quot;match_phrase&quot;: &#123;
                                    &quot;name.FPY&quot;: &#123;
                                        &quot;query&quot;: &quot;水果&quot;,
                                        &quot;analyzer&quot;: &quot;fullPinyinSearchAnalyzer&quot;,
                                        &quot;slop&quot;: 0,
                                        &quot;zero_terms_query&quot;: &quot;NONE&quot;,
                                        &quot;boost&quot;: 1
                                    &#125;
                                &#125;
                            &#125;,
                            &#123;
                                &quot;match&quot;: &#123;
                                    &quot;name&quot;: &#123;
                                        &quot;query&quot;: &quot;水果&quot;,
                                        &quot;operator&quot;: &quot;OR&quot;,
                                        &quot;analyzer&quot;: &quot;ikSearchAnalyzer&quot;,
                                        &quot;prefix_length&quot;: 0,
                                        &quot;max_expansions&quot;: 50,
                                        &quot;minimum_should_match&quot;: &quot;100%&quot;,
                                        &quot;fuzzy_transpositions&quot;: true,
                                        &quot;lenient&quot;: false,
                                        &quot;zero_terms_query&quot;: &quot;NONE&quot;,
                                        &quot;auto_generate_synonyms_phrase_query&quot;: true,
                                        &quot;boost&quot;: 1
                                    &#125;
                                &#125;
                            &#125;
                        ],
                        &quot;boost&quot;: 1
                    &#125;
                &#125;
            ],
            &quot;filter&quot;: [
                &#123;
                    &quot;term&quot;: &#123;
                        &quot;deleted&quot;: &#123;
                            &quot;value&quot;: false,
                            &quot;boost&quot;: 1
                        &#125;
                    &#125;
                &#125;
            ],
            &quot;adjust_pure_negative&quot;: true,
            &quot;boost&quot;: 1
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ol>
</details>

<details>
<summary>经纬度查询</summary>

<ol>
<li><p>创建索引</p>
<pre><code class="json">PUT /myindex
&#123;
    &quot;mappings&quot;: &#123;
        &quot;properties&quot;: &#123;
            &quot;name&quot;: &#123;
                &quot;type&quot;: &quot;text&quot;
            &#125;,
            &quot;location&quot;: &#123;
                &quot;type&quot;: &quot;geo_point&quot;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>新增数据</p>
<pre><code class="json">PUT /myindex/_doc/1
&#123;
    &quot;name&quot;: &quot;天安门&quot;,
    &quot;location&quot;: &#123;
        &quot;lon&quot;: 116.403981,
        &quot;lat&quot;: 39.914492
    &#125;
&#125;

PUT /myindex/_doc/2
&#123;
    &quot;name&quot;: &quot;海淀公园&quot;,
    &quot;location&quot;: &#123;
        &quot;lon&quot;: 116.302509,
        &quot;lat&quot;: 39.991152
    &#125;
&#125;

PUT /myindex/_doc/3
&#123;
    &quot;name&quot;: &quot;北京动物园&quot;,
    &quot;location&quot;: &#123;
        &quot;lon&quot;: 116.343184,
        &quot;lat&quot;: 39.947468
    &#125;
&#125;
</code></pre>
</li>
<li><p>查询</p>
<pre><code class="json">// 查找索引内距离北京站(116.433733,39.908404)3000米内的点
POST /myindex/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;geo_distance&quot;: &#123;
            &quot;location&quot;: &#123;
                &quot;lon&quot;: 116.433733,
                &quot;lat&quot;: 39.908404
            &#125;,
            &quot;distance&quot;: 3000,
            &quot;distance_type&quot;: &quot;arc&quot;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">// 查找索引内位于中央民族大学(116.326943,39.95499)以及京站(116.433733,39.908404)矩形的点
POST /myindex/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;geo_bounding_box&quot;: &#123;
            &quot;location&quot;: &#123;
                &quot;top_left&quot;: &#123;
                    &quot;lon&quot;: 116.326943,
                    &quot;lat&quot;: 39.95499
                &#125;,
                &quot;bottom_right&quot;: &#123;
                    &quot;lon&quot;: 116.433446,
                    &quot;lat&quot;: 39.908737
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="json">// 查找索引内位于西苑桥(116.300209,40.003423)，巴沟山水园(116.29561,39.976004)以及北京科技大学(116.364528,39.996348)三角形内的点
POST /myindex/_search
&#123;
    &quot;query&quot;: &#123;
        &quot;geo_polygon&quot;: &#123;
            &quot;location&quot;: &#123;
                &quot;points&quot;: [
                    &#123;
                        &quot;lon&quot;: 116.29561,
                        &quot;lat&quot;: 39.976004
                    &#125;,
                    &#123;
                        &quot;lon&quot;: 116.364528,
                        &quot;lat&quot;: 39.996348
                    &#125;,
                    &#123;
                        &quot;lon&quot;: 116.300209,
                        &quot;lat&quot;: 40.003423
                    &#125;
                ]
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ol>
</details>

<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><p>召回率/recall<br>  比如你搜索一个 java spark，总共有 100 个 doc，能返回多少个 doc 作为结果，就是召回率</p>
</li>
<li><p>精准度/precision<br>  比如你搜索一个 java spark，能不能尽可能让包含 java spark，或者是 java 和 spark 离的很近的 doc，排在最前面</p>
</li>
</ul>
]]></content>
      <categories>
        <category>elasticsearch</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg</title>
    <url>/2025/03/22/ffmpeg/</url>
    <content><![CDATA[<h1 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a><a href="http://ffmpeg.org/">FFmpeg</a></h1><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><h3 id="基本选项"><a href="#基本选项" class="headerlink" title="基本选项"></a>基本选项</h3><table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>参数示例</th>
</tr>
</thead>
<tbody><tr>
<td>-i</td>
<td>指定输入视频文件</td>
<td>-i input.mp4</td>
</tr>
<tr>
<td>-y</td>
<td>覆盖已有文件</td>
<td>-y</td>
</tr>
</tbody></table>
<h3 id="视频选项"><a href="#视频选项" class="headerlink" title="视频选项"></a>视频选项</h3><table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>参数示例</th>
</tr>
</thead>
<tbody><tr>
<td>-vcodec</td>
<td>视频编码格式，取值：”libx264”（libx264 解码器）、”h264”（H.264 编码）</td>
<td>-vcodec libx264</td>
</tr>
<tr>
<td>-s</td>
<td>视频分辨率</td>
<td>-s 540x960</td>
</tr>
<tr>
<td>-r</td>
<td>视频帧速率，单位：帧/秒</td>
<td>-r 25</td>
</tr>
<tr>
<td>-b</td>
<td>视频码率，单位：bit/s 或 bps</td>
<td>-b 800000</td>
</tr>
</tbody></table>
<h3 id="音频选项"><a href="#音频选项" class="headerlink" title="音频选项"></a>音频选项</h3><table>
<thead>
<tr>
<th>参数名</th>
<th>参数说明</th>
<th>参数示例</th>
</tr>
</thead>
<tbody><tr>
<td>-acodec</td>
<td>音频编码，取值：”aac”（AAC 编码）</td>
<td>-acodec aac</td>
</tr>
<tr>
<td>-ac</td>
<td>音频声道个数，取值：”1”（单声道）、”2”（立体声）</td>
<td>-ac 2</td>
</tr>
<tr>
<td>-ar</td>
<td>音频采样频率，单位：Hz</td>
<td>-ar 44100</td>
</tr>
<tr>
<td>-b:a（旧版本写法：-ab）</td>
<td>音频比特率，单位：bit/s 或 bps，一般选择 32、64、96、128</td>
<td>-b:a 128 或 -ab 128</td>
</tr>
</tbody></table>
<ul>
<li>视频文件大小计算公式  <pre><code class="bash">视频文件大小（byte） ≈ 总比特率（bps） / 8 * 播放时长（s） = (视频码率（bps） + 音频码率（bps）) / 8 * 播放时长（s）
# 例如，某视频文件，总比特率为 862 kbps（其中视频码率为 734 kbps，音频码率为 128 kbps），时长为 00:00:15，则文件大小约为 862 kbps / 8 * 15 s = 107.75 KB * 15 s = 1616.25 KB
</code></pre>
</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code class="bash"># 查看视频信息
ffmpeg -i input.mp4

# 视频压缩
# ffmpeg -i input.mp4 -vcodec libx264 -s 540x480 -r 25 -b 800000 -acodec aac -ac 2 -ar 44100 -ab 128 -y output.mp4
ffmpeg -i input.mp4 -vcodec libx264 -r 25 -b 800000 -acodec aac -ac 2 -ar 44100 -ab 128 -y output.mp4

# 视频压缩，并推送至流媒体服务器
ffmpeg \
    -i input.mp4 \
    -vcodec libx264 -r 25 -vf scale=-1:720 \ # 视频分辨率 720p，帧率 25 fps
    # -acodec aac -ac 2 -ar 44100 -b:a 128k \
    -acodec copy \
    -f flv rtmp://127.0.0.1:1935/

# 视频裁剪、压缩
ffmpeg \
    -i &quot;input.mp4&quot; \
    -ss 00:01:00 -t 00:01:00 \ # 从 01:00 开始，截取长度为 01:00 时间的视频
    # -vcodec copy \ # 保持原分辨率
    -vf scale=-1:480 \ # 等比例压缩至 *x480 分辨率
    -acodec copy \
    output.mp4

# 循环推流、[添加时间水印](https://blog.csdn.net/ternence_hsu/article/details/102540626)
ffmpeg \
    -re \ # 表示按帧率发送，推流时一定要加这个参数，否则 ffmpeg 会以最高速率不断发送
    -stream_loop -1 \ # 循环推流次数，-1 表示无限次数
    -i test.h264 \
    # -vcodec copy -acodec copy \
    -vf &quot;settb=AVTB,setpts=&#39;trunc(PTS/1K)*1K+st(1,trunc(RTCTIME/1K))-1K*trunc(ld(1)/1K)&#39;,drawtext=fontsize=20:fontcolor=white:text=&#39;%&#123;localtime&#125;.%&#123;eif\:1M*t-1K*trunc(t*1K)\:d&#125;&#39;&quot; -c:v libx264 -an \ # 添加本地时间水印,打印详细日期并且精确到毫秒
    -f flv \
    -y rtmp://127.0.0.1:1935/live/test

# 将图片合成视频
ffmpeg \
    -loop 1 \ # 循环读取输入文件
    -i input.jpg \ # 指定输入文件
    -t 15 \ # 生成 15 秒的视频
    output.mp4
ffmpeg \
    -f image2 \
    -r 0.2 \ # 输入帧率(在 -i 之前为输入帧率，默认为 25)，如 0.2 表示每秒读取 0.2 张图片，即每张图片播放 5 秒
    -i input-%d.jpg \ # 读取图片如 input-0.jpg, input-1.jpg, input-2.jpg
    -r 10 \ # 输出帧率(在 -i 之前为输入帧率，默认为 25)，即视频帧率
    output.mp4

# 将图片合成视频，实时添加时间水印，并且推流
ffmpeg \
    -re
    -loop 1 \
    -i input.jpg \
    -vf &quot;setpts=PTS,realtime,setpts=PTS,drawtext=fontfile=arial.ttf:x=w-tw:fontcolor=white:fontsize=30:text=&#39;%&#123;localtime\:%H\\\:%M\\\:%S&#125;&#39;&quot; \ # 添加时间水印，按照实时速率
    -vcodec h264 \ # 转换成 H.264 视频格式
    -f flv \
    rtmp://127.0.0.1:1935/live/test
</code></pre>
<h2 id="视频转码"><a href="#视频转码" class="headerlink" title="视频转码"></a>视频转码</h2><pre><code class="bash"># 将 input.avi 转码为 output.mp4
ffmpeg -i input.avi output.mp4

# 将 input.avi 转码为 output.ts
ffmpeg -i input.mp4 output.ts

# 转码为码流原始文件
ffmpeg –i test.mp4 –vcodec h264 –s 352*278 –an –f m4v test.264
ffmpeg –i test.mp4 –vcodec h264 –bf 0 –g 25 –s 352*278 –an –f m4v test.264

# 转码为封装文件
ffmpeg –i test.avi -vcodec mpeg4 –vtag xvid –qsame test_xvid.avi

# 将input.avi转码成output.ts，并设置视频的码率为640kbps（-bf B帧数目控制，-g 关键帧间隔控制，-s 分辨率控制）
ffmpeg -i input.avi -b:v 640k output.ts
</code></pre>
<h2 id="提取音频、视频"><a href="#提取音频、视频" class="headerlink" title="提取音频、视频"></a>提取音频、视频</h2><pre><code class="bash"># 提取音频
ffmpeg -i test.mp4 -acodec copy -vn output.aac # 默认 mp4 的 audio codec 是 aac
ffmpeg -i test.mp4 -acodec aac -vn output.aac # 如果不是 aac 格式，可以都转为 aac 

# 提取视频
ffmpeg -i input.mp4 -vcodec copy -an output.mp4
</code></pre>
<h2 id="视频剪切"><a href="#视频剪切" class="headerlink" title="视频剪切"></a>视频剪切</h2><pre><code class="bash"># 从时间为 00:00:15 开始，截取 5 秒钟的视频
ffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4
</code></pre>
<blockquote>
<p>-ss 表示开始切割的时间，-t 表示要切多少</p>
</blockquote>
<h2 id="码率控制"><a href="#码率控制" class="headerlink" title="码率控制"></a>码率控制</h2><pre><code class="bash"># 把码率从原码率（如 10 Mbps）转成 2 Mbps 码率，这样其实也间接让文件变小了
# ffmpeg -i input.mp4 -b:v 2000k output.mp4
ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4
ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4
</code></pre>
<h2 id="视频编码格式转换"><a href="#视频编码格式转换" class="headerlink" title="视频编码格式转换"></a>视频编码格式转换</h2><pre><code class="bash"># 比如一个视频的编码是 MPEG4，先转成 H264 编码
ffmpeg -i input.mp4 -vcodec h264 output.mp4
# H264 编码转成 MPEG4
ffmpeg -i input.mp4 -vcodec mpeg4 output.mp4

# # 如果 ffmpeg 编译时，添加了外部的 x265 或者 X264，那也可以用外部的编码器来编码
# ffmpeg -i input.mp4 -c:v libx265 output.mp4
# ffmpeg -i input.mp4 -c:v libx264 output.mp4
</code></pre>
<h2 id="只提取视频-ES-数据"><a href="#只提取视频-ES-数据" class="headerlink" title="只提取视频 ES 数据"></a>只提取视频 ES 数据</h2><pre><code class="bash">ffmpeg –i input.mp4 –vcodec copy –an –f m4v output.h264
</code></pre>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><pre><code class="bash"># 将输入的 1920 x 1080 缩小到 960 x 540 输出
ffmpeg -i input.mp4 -vf scale=960:540 output.mp4 # 如果540不写，写成-1，即scale=960:-1, 那也是可以的，ffmpeg会通知缩放滤镜在输出时保持原始的宽高比

# 为视频添加 logo
ffmpeg -i input.mp4 -i logo.png -filter_complex overlay output.mp4 # 左上角位置
# ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4 # 右上角位置
# ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4 # 左下角位置
# ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4 # 右下角位置

# 去掉视频的 logo
ffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4 
# 语法：-vf delogo=x:y:w:h[:t[:show]]
# x:y 离左上角的坐标
# w:h logo 的宽和高
# t: 矩形边缘的厚度默认值 4
# show：若设置为 1 有一个绿色的矩形，默认值 0
</code></pre>
<h2 id="截取视频图像"><a href="#截取视频图像" class="headerlink" title="截取视频图像"></a>截取视频图像</h2><pre><code class="bash">ffmpeg -i input.mp4 -r 1 -q:v 2 -f image2 pic-%03d.jpeg

# 从 input.mp4 的第 20s 时间开始，往下 10s，即 20 ~ 30s 这 10 秒钟之间，每隔 1s 就抓一帧，总共会抓 10 帧
ffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg 
</code></pre>
<blockquote>
<p>-r 表示每一秒几帧<br>-q:v 表示存储 jpeg 的图像质量，一般 2 是高质量。</p>
</blockquote>
<h2 id="序列帧与视频的相互转换"><a href="#序列帧与视频的相互转换" class="headerlink" title="序列帧与视频的相互转换"></a>序列帧与视频的相互转换</h2><pre><code class="bash"># 把 darkdoor.[001-100].jpg 序列帧和 001.mp3 音频文件利用 mpeg4 编码方式合成视频文件 darkdoor.avi
ffmpeg -i 001.mp3 -i darkdoor.%3d.jpg -s 1024x768 -author fy -vcodec mpeg4 darkdoor.avi

# 还可以把视频文件导出成 jpg 序列帧
ffmpeg -i bc-cinematic-en.avi example.%d.jpg
</code></pre>
<h2 id="抓屏"><a href="#抓屏" class="headerlink" title="抓屏"></a>抓屏</h2><pre><code class="bash"># 最简单的抓屏
ffmpeg -f gdigrab -i desktop out.mpg

# 以 15 的帧率抓屏 20 秒，保存为视频格式是 vp9 的 mkv 文件
ffmpeg -f gdigrab -t 20 -r 15 -i desktop -vcodec libvpx-vp9 capture-vp9.mkv

# 以 15 的帧率抓屏 10 秒，保存为视频格式是 vp9，分辨率是 720 x 420 的 mkv 文件
ffmpeg -f gdigrab -t 10 -r 15 -i desktop -vcodec libvpx-vp9 -s 720x420 vp9-720-420.mkv

# 以 15 的帧率抓屏 20 秒，抓屏范围，以点(100, 60)开始，大小 600 x 480，保存为视频格式是 264 的 mp4 文件
ffmpeg -f gdigrab -video_size 600x480 -offset_x 100 -offset_y 60 -t 20 -r 15 -i desktop -vcodec libx264 x264.mp4

# 抓屏 10 秒，并生成 gif 图片
ffmpeg -f gdigrab -t 10 -r 15 -i desktop -pix_fmt rgb24 capture.gif
</code></pre>
<h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><ul>
<li><p>对视频进行TS切片（转化成HLS）</p>
<ul>
<li><p>直接切片（hls）<br>  <code>ffmpeg -i video.mp4 -c:v libx264 -c:a aac -strict -2 -f hls -hls_list_size 0 -hls_time 5 video.m3u8</code></p>
<blockquote>
<ul>
<li><code>-hls_time n</code> 设置每片的长度，默认值为 2。单位为秒  </li>
<li><code>-hls_list_size n</code> 设置播放列表保存的最多条目，设置为 0 会保存有所片信息，默认值为 5  </li>
<li><code>-hls_wrap n</code> 设置多少片之后开始覆盖，如果设置为 0 则不会覆盖，默认值为 0。这个选项能够避免在磁盘上存储过多的片，而且能够限制写入磁盘的最多的片的数量  </li>
<li><code>-hls_start_number n</code> 设置播放列表中 sequence number 的值为 number，默认值为 0</li>
</ul>
</blockquote>
</li>
<li><p>转码为 ts 文件并生成 m3u8（segment）</p>
<ol>
<li><p>将 mp4 转为完整的 ts<br> <code>ffmpeg -i out.mp4 -c copy -bsf h264_mp4toannexb output.ts</code></p>
</li>
<li><p>将 ts 切片，并生成 m3u8 文件<br> <code>ffmpeg -i output.ts -c copy -map 0 -f segment -segment_list playlist.m3u8 -segment_time 10 output%03d.ts</code></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>将文件当做直播送至 live<br>  <code>ffmpeg -re -i video.mp4 -c copy -f flv rtmp://127.0.0.1/live/stream_name</code><br>  <code>ffmpeg -re -i video.mp4  -vcodec copy -acodec copy -f rtsp rtsp://127.0.0.1/live/stream_name</code></p>
</li>
<li><p>读取摄像头、话筒的数据</p>
<ul>
<li><p>使用 VFW 读取摄像头的数据（采集 10秒，采集设备为 vfwcap 类型设备，第 0 个 vfwcap 采集设备（如果系统有多个 vfw 的视频采集设备，可以通过 -i num 来选择），每秒 8 帧，输出方式为文件，格式为 mp4）<br>  <code>ffmpeg -t 10 -f vfwcap -i 0 -r 8 -f mp4 cap.mp4</code></p>
</li>
<li><p>使用 DirectShow 读取摄像头的数据  </p>
<ol>
<li><span id="query_device">列出所有设备</span>，查找设备名称（如摄像头为”WebCam SC-0311139N”，话筒为”楹﹀厠椋?(Realtek High Definition Audio)”(ANSI 乱码”楹﹀厠椋?”转 UTF-8 之后为”麦克风”)）<br> <code>ffmpeg -list_devices true -f dshow -i dummy</code></li>
<li>获取摄像头数据  <ul>
<li>从摄像头读取数据并编码为 H.264，最后保存成 mycamera.mkv<br>  <code>ffmpeg -f dshow -i video=&quot;WebCam SC-0311139N&quot; -vcodec libx264 mycamera.mkv</code></li>
<li>获取摄像头数据，编码为 H.264，封装为 UDP 并发送至组播地址<br>  <code>ffmpeg -f dshow -i video=&quot;WebCam SC-0311139N&quot; -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f h264 udp://233.233.233.223:6666</code></li>
<li>获取摄像头数据，编码为 H.264，封装为 RTP 并发送至组播地址<br>  <code>ffmpeg -f dshow -i video=&quot;WebCam SC-0311139N&quot; -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f rtp rtp://233.233.233.223:6666&gt;test.sdp</code></li>
<li>获取摄像头数据，编码为 H.264，并发送至 RTMP 服务器<br>  <code>ffmpeg -f dshow -i video=&quot;WebCam SC-0311139N&quot; -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://127.0.0.1/live/livestream</code></li>
<li>采集当前摄像头及音频数据，视频 h264、音频 faac 压缩后发布至 RTMP 服务器<br>  <code>ffmpeg -f dshow -s 640*480 -i video=&quot;WebCam SC-0311139N&quot;:audio=&quot;麦克风 (Realtek High Definition Audio)&quot; -vcodec libx264 -b 600k -acodec libfaac -ab 128k -f flv rtmp://192.168.1.200/live/video</code></li>
</ul>
</li>
</ol>
</li>
<li><p>屏幕录制</p>
<ul>
<li>linux 下使用 x11grab 录制屏幕<br>  <code>ffmpeg -f x11grab -s 1600x900 -r 50 -vcodec libx264 –preset:v ultrafast –tune:v zerolatency -crf 18 -f mpegts udp://localhost:1234</code>  </li>
<li>将屏幕录制后编码为 H.264 并保存为本地文件（在 Windows 平台下，使用 -dshow 取代 x11grab）<br>  <code>ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot; -r 5 -vcodec libx264 -preset:v ultrafast -tune:v zerolatency MyDesktop.mkv</code></li>
<li>将屏幕录制后编码为 H.264 并封装成 UDP 发送到组播地址<br>  <code>ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot; -r 5 -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f h264 udp://233.233.233.223:6666</code></li>
<li>将屏幕录制后编码为 H.264 并封装成 RTP 并发送到组播地址<br>  <code>ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot; -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f rtp rtp://233.233.233.223:6666&gt;test.sdp</code></li>
<li>编码为 H.264，发布 RTMP<br>  <code>ffmpeg -f dshow -i video=&quot;WebCam SC-0311139N&quot; -vcodec libx264 -preset:v ultrafast -tune:v zerolatency -f flv rtmp://127.0.0.1/live/livestream</code></li>
</ul>
</li>
<li><p>gdigrab 屏幕录制（另一种屏幕录制的方式）<br>  简单的抓屏<br>  <code>ffmpeg -f gdigrab -i desktop out.mpg</code><br>  从屏幕的（10,20）点处开始，抓取 640 x 480 的屏幕，设定帧率为 5<br>  <code>ffmpeg -f gdigrab -framerate 5 -offset_x 10 -offset_y 20 -video_size 640x480 -i desktop out.mpg</code></p>
</li>
<li><p>录制视频、音频（按 q 键停止录制）</p>
<pre><code class="bash"># 查看可用设备名字，如 &quot;WebCam SC-0311139N&quot;、&quot;麦克风 (Realtek High Definition Audio)&quot;
# ffmpeg -list_devices true -f dshow -i dummy
# 查看（视频录制）设备的可选参数
# ffmpeg -f dshow -list_options true -i video=&quot;WebCam SC-0311139N&quot;

# 录制视频（摄像头）
ffmpeg -f dshow -rtbufsize 702000k -i video=&quot;WebCam SC-0311139N&quot; v-out.mp4 # &quot;WebCam SC-0311139N&quot; 为设备名称

# 录制声音
ffmpeg -f dshow -i audio=&quot;麦克风 (Realtek High Definition Audio)&quot; a-out.aac # &quot;麦克风 (Realtek High Definition Audio)&quot; 为设备名称
ffmpeg -f dshow -i audio=&quot;@device_cm_&#123;33D9A762-90C8-11D0-BD43-00A0C911CE86&#125;\wave_&#123;2F4C5655-04D4-4202-B399-8515DE44DD04&#125;&quot; a-out.aac # &quot;@device_cm_&#123;33D9A762-90C8-11D0-BD43-00A0C911CE86&#125;\wave_&#123;2F4C5655-04D4-4202-B399-8515DE44DD04&#125;&quot; 为 Alternative name

# 同时录制声音和视频（摄像头）
ffmpeg -f dshow -i video=&quot;screen-capture-recorder&quot;:audio=&quot;virtual-audio-capturer&quot; av-out.mp4
ffmpeg -f gdigrab -video_size 1366x768 -framerate 30 -pixel_format yuv420p -i video=&quot;screen-capture-recorder&quot;:audio=&quot;virtual-audio-capturer&quot; av-out.mp4

# 同时录制音频和视频（桌面）
ffmpeg -f gdigrab -i desktop -f dshow -i audio=&quot;麦克风 (Realtek High Definition Audio)&quot; av-out.mp4
</code></pre>
</li>
</ul>
</li>
<li><p>分离视频音频流</p>
<pre><code class="bash">ffmpeg -i input_file -vcodec copy -an output_file_video　　//分离视频流
ffmpeg -i input_file -acodec copy -vn output_file_audio　　//分离音频流
</code></pre>
</li>
<li><p>视频解复用</p>
<pre><code class="bash">ffmpeg –i test.mp4 –vcodec copy –an –f m4v test.264
ffmpeg –i test.avi –vcodec copy –an –f m4v test.264
</code></pre>
</li>
<li><p>视频封装</p>
<pre><code class="bash">ffmpeg –i video_file –i audio_file –vcodec copy –acodec copy output_file
</code></pre>
</li>
<li><p>视频剪切</p>
<pre><code class="bash">ffmpeg –i test.avi –r 1 –f image2 image-%3d.jpeg # 提取图片
ffmpeg -ss 0:1:30 -t 0:0:20 -i input.avi -vcodec copy -acodec copy output.avi # 剪切视频
</code></pre>
<blockquote>
<p>-r 提取图像的频率，-ss 开始时间，-t 持续时间</p>
</blockquote>
</li>
<li><p>视频录制<br>  <code>ffmpeg –i rtsp://192.168.3.205:5555/test –vcodec copy out.avi</code></p>
</li>
<li><p>YUV序列播放<br>  <code>ffplay -f rawvideo -video_size 1920x1080 input.yuv</code></p>
</li>
<li><p>YUV序列转AVI<br>  <code>ffmpeg –s w*h –pix_fmt yuv420p –i input.yuv –vcodec mpeg4 output.avi</code></p>
</li>
<li><p>将直播媒体保存至本地文件<br>  <code>ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</code></p>
</li>
<li><p>将其中一个直播流，视频改用 h264 压缩，音频不变，送至另外一个直播服务流<br>  <code>ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv rtmp://server/live/h264Stream</code> </p>
</li>
<li><p>将其中一个直播流，视频改用 h264 压缩，音频改用 faac 压缩，送至另外一个直播服务流<br>  <code>ffmpeg -i rtmp://server/live/originalStream -c:a libfaac -ar 44100 -ab 48k -c:v libx264 -vpre slow -vpre baseline -f flv rtmp://server/live/h264Stream</code></p>
</li>
<li><p>将其中一个直播流，视频不变，音频改用 faac 压缩，送至另外一个直播服务流<br>  <code>ffmpeg -i rtmp://server/live/originalStream -acodec libfaac -ar 44100 -ab 48k -vcodec copy -f flv rtmp://server/live/h264_AAC_Stream</code></p>
</li>
<li><p>将一个 JPG 图片经过 h264 压缩循环输出为 mp4 视频<br>  <code>ffmpeg.exe -i INPUT.jpg -an -vcodec libx264 -coder 1 -flags +loop -cmp +chroma -subq 10 -qcomp 0.6 -qmin 10 -qmax 51 -qdiff 4 -flags2 +dct8x8 -trellis 2 -partitions +parti8x8+parti4x4 -crf 24 -threads 0 -r 25 -g 25 -y OUTPUT.mp4</code></p>
</li>
<li><p>将普通流视频改用 h264 压缩，音频不变，送至高清流服务(新版本 FMS live=1)<br>  <code>ffmpeg -i rtmp://server/live/originalStream -c:a copy -c:v libx264 -vpre slow -f flv &quot;rtmp://server/live/h264Stream live=1〃</code></p>
</li>
<li><p>最简单的抓屏<br>  <code>ffmpeg -f gdigrab -i desktop out.mpg</code></p>
</li>
<li><p>从屏幕的（10,20）点处开始，抓取 640x480 的屏幕，设定帧率为 5<br>  <code>ffmpeg -f gdigrab -framerate 5 -offset_x 10 -offset_y 20 -video_size 640x480 -i desktop out.mpg </code></p>
</li>
<li><p>ffmpeg 从视频中生成 gif 图片<br>  <code>ffmpeg -i capx.mp4 -t 10 -s 320x240 -pix_fmt rgb24 jidu1.gif</code></p>
</li>
<li><p>ffmpeg 将图片转换为视频<br>  假如你的图片在c:\temp\下面。那么通过下面的命令就可以将这个目录下面的图片转换成视频。这里面有个要求就是你的图片全部是自然数为文件名， 001, 002, 003这样的。前面要几个0取决于你的图片的个数，如109张，那么就是3-1=2个0，从001 到109，如果是1009张就是0001到1009.<br>  <code>ffmpeg -f image2 -i c:\temp\d.jpg test.mp4</code><br>  你可以指定编码格式<br>  <code>ffmpeg -f image2 -i c:\temp\d.jpg -vcodec libx264 test.mp4</code><br>  也许你还想指定输出帧率<br>  <code>ffmpeg -f image2 -i c:\temp\d.jpg -vcodec libx264 -r 10  test.mp4</code><br>  这样输出的test.mp4就是每秒播放10帧了<br>  如果你要指定码率<br>  <code>ffmpeg -f image2 -i c:\temp\d.jpg -vcodec libx264 -r 10 -b 200k  test.mp4</code><br>  注意这里的200k的单位bit/s.<br>  也许你要问那么到底最后生成的文件的参数都是什么样子，比如我们刚才设置的参数，还有我们没有设置的参数<br>  那么这个命令就可以帮你搞定<br>  <code>ffmpeg -i test.mp4</code></p>
</li>
<li><p>将一个高清流，复制为几个不同视频清晰度的流重新发布，其中音频不变<br>  <code>ffmpeg -re -i rtmp://server/live/high_FMLE_stream -acodec copy -vcodec x264lib -s 640×360 -b 500k -vpre medium -vpre baseline rtmp://server/live/baseline_500k -acodec copy -vcodec x264lib -s 480×272 -b 300k -vpre medium -vpre baseline rtmp://server/live/baseline_300k -acodec copy -vcodec 264lib -s 320×200 -b 150k -vpre medium -vpre baseline rtmp://server/live/baseline_150k -acodec libfaac -vn -ab 48k rtmp://server/live/audio_only_AAC_48k</code></p>
</li>
<li><p>功能同上一样，只是采用 -x264opts 选项<br>  <code>ffmpeg -re -i rtmp://server/live/high_FMLE_stream -c:a copy -c:v x264lib -s 640×360 -x264opts bitrate=500:profile=baseline:preset=slow rtmp://server/live/baseline_500k -c:a copy -c:v x264lib -s 480×272 -x264opts bitrate=300:profile=baseline:preset=slow rtmp://server/live/baseline_300k -c:a copy -c:v x264lib -s 320×200 -x264opts bitrate=150:profile=baseline:preset=slow rtmp://server/live/baseline_150k -c:a libfaac -vn -b:a 48k rtmp://server/live/audio_only_AAC_48k</code></p>
</li>
<li><p>提取视频的 YUV 原始数据<br>  <code>ffmpeg -i input.mp4 output.yuv</code></p>
</li>
<li><p>抽取某一帧 YUV：抽出 jpeg 图片，然后把 jpeg 转为 YUV<br>  <code>ffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg</code><br>  <code>ffmpeg -i pic-001.jpeg -s 1440x1440 -pix_fmt yuv420p xxx3.yuv</code></p>
</li>
</ul>
<blockquote>
<p>常用参数说明：</p>
<ul>
<li>主要参数：  <pre><code>-i 设定输入流    
-f 设定输出格式  
-ss 开始时间 
</code></pre>
</li>
<li>视频参数：<br>  -b 设定视频流量，默认为200Kbit/s<br>  -r 设定帧速率，默认为25<br>  -s 设定画面的宽与高<br>  -aspect 设定画面的比例<br>  -vn 不处理视频<br>  -vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器</li>
<li>音频参数：<br>  -ar 设定采样率<br>  -ac 设定声音的Channel数<br>  -acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器<br>  -an 不处理音频</li>
</ul>
</blockquote>
<h1 id="FFplay"><a href="#FFplay" class="headerlink" title="FFplay"></a>FFplay</h1><ul>
<li><p>设置代理并播放</p>
<pre><code class="bash">export http_proxy=http://xxx:80
export https_proxy=http://xxx:80

ffplay &quot;https://xxxx/xxx.m3u8&quot;
</code></pre>
</li>
<li><p>播放 test.mp4 ，播放完成后自动退出<br>  <code>ffplay -autoexit test.mp4</code></p>
</li>
<li><p>以 320 x 240 的大小播放 test.mp4<br>  <code>ffplay -x 320 -y 240 test.mp4</code></p>
</li>
<li><p>将窗口标题设置为 “myplayer”，循环播放 2 次<br>  <code>ffplay -window_title myplayer -loop 2 test.mp4</code></p>
</li>
<li><p>播放 双通道 32K 的 PCM 音频数据<br>  <code>ffplay -f s16le -ar 32000 -ac 2 test.pcm</code></p>
</li>
<li><p>直接播放摄像头的数据（”WebCam SC-0311139N”为<a href="#query_device">设备名称</a>）<br>  <code>ffplay -f dshow -i video=&quot;WebCam SC-0311139N&quot;</code></p>
</li>
<li><p>播放流<br>  <code>ffplay rtmp://127.0.0.1:1935/live/oceans</code><br>  <code>ffplay http://127.0.0.1:80/hls/oceans.m3u8</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang</title>
    <url>/2025/03/22/golang/</url>
    <content><![CDATA[<h1 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><p>安装 Go</p>
<ul>
<li>标准安装<ol>
<li>下载二进制包<br> <code>curl -OkL https://golang.google.cn/dl/go1.18.linux-amd64.tar.gz</code><blockquote>
<ul>
<li><a href="https://studygolang.com/dl/golang/go1.16.3.windows-amd64.zip">window 版本下载</a></li>
</ul>
</blockquote>
</li>
<li>将下载的二进制包解压至 /usr/local目录<br> <code>tar -C /usr/local -xzf go*.tar.gz</code></li>
<li>将 /usr/local/go/bin 目录添加至 PATH 环境变量<br> <code>export PATH=$PATH:/usr/local/go/bin</code></li>
</ol>
</li>
</ul>
</li>
<li><p><a href="https://github.com/visualfc/liteide">LiteIDE</a></p>
<pre><code>http://sourceforge.mirrorservice.org/l/li/liteide/x36/liteidex36.linux64-qt5.5.1.tar.gz
http://sourceforge.mirrorservice.org/l/li/liteide/x36/liteidex36.windows-qt5.9.5.zip
</code></pre>
</li>
<li><p>国内加速</p>
<pre><code class="bash">export GO111MODULE=auto
# export GOPROXY=&quot;https://goproxy.io&quot;
export GOPROXY=&quot;https://mirrors.aliyun.com/goproxy/&quot;
</code></pre>
</li>
<li><p>获取第三方库</p>
<pre><code class="bash"># go get github.com/go-sql-driver/mysql
go install github.com/go-sql-driver/mysql@latest
</code></pre>
</li>
</ul>
<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><ol>
<li><p>新建文件 greeting.go 并编辑内容如下</p>
<pre><code class="golang">package main

import &quot;fmt&quot;

func main() &#123;
    fmt.Println(&quot;hello, world&quot;)
&#125;
</code></pre>
</li>
<li><p>直接运行<br> <code>go run greeting.go</code></p>
</li>
<li><p>编译为可执行文件<br> <code>go build greeting.go</code></p>
</li>
</ol>
<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><ul>
<li><p>Linux 下编译 Mac、Windows 平台的 64 位可执行程序</p>
<pre><code class="bash">CGO_ENABLED=0 # 编译成单个可执行文件
GOOS=darwin # Mac
GOARCH=amd64 # x64
go build main.go # 编译
</code></pre>
<pre><code class="bash">CGO_ENABLED=0
GOOS=windows # Windows
GOARCH=amd64 # x64
go build main.go # 编译
</code></pre>
</li>
<li><p>Windows 下编译 Mac、Linux 平台的 64 位可执行程序</p>
<pre><code class="batch">SET CGO_ENABLED=0
SET GOOS=darwin3
SET GOARCH=amd64
go build main.go
</code></pre>
<pre><code class="batch">SET CGO_ENABLED=0
SET GOOS=linux
SET GOARCH=amd64
go build main.go
</code></pre>
</li>
<li><p>Mac 下编译 Linux、Windows 平台的 64 位可执行程序</p>
<pre><code class="bash">CGO_ENABLED=0
GOOS=linux
GOARCH=amd64
go build main.go
</code></pre>
<pre><code class="bash">CGO_ENABLED=0
GOOS=windows
GOARCH=amd64
go build main.go
</code></pre>
</li>
</ul>
<blockquote>
<p>参数描述：</p>
<ul>
<li>CGO_ENABLED<br>当 <code>CGO_ENABLED=1</code>， 进⾏编译时， 会将⽂件中引⽤libc的库（⽐如常⽤的 net 包），以动态链接的⽅式⽣成⽬标⽂件。<br>当 <code>CGO_ENABLED=0</code>， 进⾏编译时， 则会把在⽬标⽂件中未定义的符号（外部函数）⼀起链接到可执⾏⽂件中。</li>
<li>GOOS<br>目标可执行程序运行操作系统，支持 <code>darwin</code>、<code>freebsd</code>、<code>linux</code>、<code>windows</code></li>
<li>GOARCH<br>目标可执行程序操作系统构架，包括 <code>386</code>、<code>amd64</code>、<code>arm</code></li>
</ul>
</blockquote>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li><p>基本数据类型</p>
<ul>
<li><p>布尔型<br>  布尔型的值只可以是常量 <code>true</code> 或者 <code>false</code>（默认为 false）</p>
<pre><code class="go">var a bool = true
</code></pre>
</li>
<li><p>数字类型<br>  整型 int 和浮点型 float32、float64，支持复数，其中位的运算采用补码</p>
<pre><code class="go">var a int; // 32 位有符号整数
</code></pre>
<ul>
<li>整型<table>
<thead>
<tr>
<th>位长度（bit）</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td><code>int8</code> (-128 - 127)</td>
<td><code>uint8</code> (0 - 255)</td>
</tr>
<tr>
<td>16</td>
<td><code>int16</code> (-32768 - 32767)</td>
<td><code>uint16</code> (0 - 65535)</td>
</tr>
<tr>
<td>32</td>
<td><code>int32</code> (-2147483648 - 2147483647)</td>
<td><code>uint32</code> (0 - 4294967295)</td>
</tr>
<tr>
<td>64</td>
<td><code>int64</code> (-9223372036854775808 - 9223372036854775807)</td>
<td><code>uint64</code> (0 - 18446744073709551615)</td>
</tr>
</tbody></table>
</li>
<li>浮点型<table>
<thead>
<tr>
<th>位长度（bit）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>32</td>
<td><code>float32</code></td>
</tr>
<tr>
<td>64</td>
<td><code>float64</code></td>
</tr>
</tbody></table>
</li>
<li>复数<table>
<thead>
<tr>
<th>位长度（bit）</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>32</td>
<td><code>complex64</code></td>
</tr>
<tr>
<td>64</td>
<td><code>complex128</code></td>
</tr>
</tbody></table>
</li>
<li>其他<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>byte</code></td>
<td>同 uint8</td>
</tr>
<tr>
<td><code>rune</code></td>
<td>同 int32</td>
</tr>
<tr>
<td><code>uint</code></td>
<td>即 uint32</td>
</tr>
<tr>
<td><code>int</code></td>
<td>即 int32</td>
</tr>
<tr>
<td><code>uintptr</code></td>
<td>无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>字符串类型<br>  字符串的字节使用 UTF-8 编码标识 Unicode 文本（默认值为空字符串）</p>
<pre><code class="go">const b string = &quot;abc&quot; // 显式指定 string 类型
const b = &quot;abc&quot; // 隐式指定 string 类型
</code></pre>
</li>
<li><p>派生类型</p>
<ul>
<li><p>指针类型（Pointer）  </p>
<ul>
<li>chan，即 Channel</li>
<li>map</li>
<li>slice，即切片</li>
<li>函数，如 <code>fun := func(s string) string &#123; return &quot;modify&quot; + s &#125;</code></li>
<li>interface，一个类型为 interface{} 或者 interface 接口的变量可能是指针变量，也可能是普通变量</li>
<li>function type，如 <code>type Func func(string)</code><br>其它非指针类型有：struct、基本数据类型、数组（区别切片）</li>
</ul>
</li>
<li><p>数组类型（[len]byte）</p>
</li>
<li><p>结构化类型（struct）</p>
<pre><code class="go">type User struct &#123;
    Name    string
    Gender  bool
    Age     int
    Address string
    Parents []User
&#125;

// 方法一：基本的实例化：结构体本身是一种类型，可以像整型、字符串等类型一样，以 var 的方式声明结构体即可完成实例化
var user User
user.Name = &quot;zhangsan&quot;
user.Age = 20

// 方法二：创建指针类型的结构体：使用 new 关键字对类型（包括结构体、整型、浮点数、字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体
user2 := new(User)
user2.Name = &quot;lisi&quot;
user2.Age = 21

// 方法三：取结构体的地址实例化：对结构体进行 &amp; 取地址操作时，视为对该类型进行一次 new 的实例化操作
user3 := &amp;User&#123;&#125;
user3.Name = &quot;wangwu&quot;
user3.Age = 22
</code></pre>
<pre><code class="go">// 匿名结构体
user := struct &#123;
    name string
    age int
&#125; &#123;
    name: &quot;zhangsan,
    age: 18
&#125;
</code></pre>
</li>
<li><p>Channel 类型</p>
</li>
<li><p>函数类型</p>
</li>
<li><p>切片类型</p>
</li>
<li><p>接口类型（interface）</p>
</li>
<li><p>Map 类型（map）</p>
<pre><code class="go">var m map[string]int // 定义 map
m = make(map[string]int) // 初始化 map
m[&quot;a&quot;] = 1 // 赋值

v, ok = m[&quot;a&quot;]
fmt.Println(v, ok) // 1 true

v2, ok2 = m[&quot;c&quot;] // 无法取出 c 的值
fmt.Println(v, ok) // 0 false
</code></pre>
<pre><code class="go">var m = map[string]int &#123;
   &quot;a&quot;: 1,
   &quot;b&quot;: 2
&#125;
fmt.Println(m) // map[a:1 b:2]
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="https://blog.csdn.net/gaobinzhan/article/details/106109160">数组和切片</a></p>
<ul>
<li><p>数组：容量不可伸缩，两个数组可以比较</p>
<pre><code class="go">// 数组初始化
// var balance = [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;
// balance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;
balance := [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; // 使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度

len(balance) // 获取数组长度
</code></pre>
<p>  声明</p>
<pre><code class="go">var a [3]int // 声明并初始化为默认零值
a[0] = 1
b := [3]int&#123;1, 2, 3&#125;           // 声明同时初始化
c := [2][2]int&#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125; // 多维数组初始化
t.Log(a[0], a[2])
t.Log(b[2])
t.Log(c[1][1])
</code></pre>
<p>  遍历</p>
<pre><code class="go">arr := [...]int&#123;1, 2, 3, 4, 5, 6&#125; // 自动判断长度

for i := 0; i &lt; len(arr); i++ &#123; // 典型写法遍历数组
    t.Log(arr[i])
&#125;

for idx, e := range arr &#123; // 相当于其它语言的foreach
    t.Log(idx, e)
&#125;

for _, e := range arr &#123; // 我们可能用不到 idx 但go语言定义一个值不去使用编译会不通过 使用_代表不关心这个结果，来占位
    t.Log(e)
&#125;
</code></pre>
<p>  截取，格式：a[开始索引(包含):结束索引(不包含)]</p>
<pre><code class="go">arr := [...]int&#123;1, 2, 3, 4, 5, 6&#125;
// a[开始索引(包含):结束索引(不包含)]
t.Log(arr[0:1]) // 1
t.Log(arr[2:]) // 3 4 5 6
t.Log(arr[1:len(arr)]) // 2 3 4 5 6
t.Log(arr[1:3]) // 2 3
</code></pre>
</li>
<li><p>切片：容量可以伸缩，两个切片不能比较<br>  声明</p>
<pre><code class="go">var s0 []int            // 定义看起来特别像数组，但没有指定长度
t.Log(len(s0), cap(s0)) // 0 0
s0 = append(s0, 1)
t.Log(len(s0), cap(s0)) // 1 1

s1 := []int&#123;1, 2, 3, 4&#125; // 初始化一个切片
t.Log(len(s1), cap(s1)) // 4 4

// []type,len,cap 其中len个元素会被初始化为默认零值，未初始化元素不可以访问
s2 := make([]int, 3, 5)    // len为3 cap为5
t.Log(len(s2), cap(s2))    // 3 5
t.Log(s2[0], s2[1], s2[2]) // 成功被初始化 结果：0 0 0
//t.Log(s2[0], s2[1], s2[2], s2[3]) // 出现了一个错误 index out of range [3]
s2 = append(s2, 1)
t.Log(s2[0], s2[1], s2[2], s2[3]) // 0 0 0 1
t.Log(len(s2), cap(s2))
</code></pre>
<p>  遍历</p>
<pre><code class="go">s := []int&#123;&#125;
for i := 0; i &lt; 10; i++ &#123;
    s = append(s, i) // 为什么重新赋值给s,是因为结构体指向的连续存储空间进行了变化,并把原有的连续存储空间拷贝到新的连续存储空间
    t.Log(len(s), cap(s))
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>循环</p>
<pre><code class="go">sum := 0;
for index := 0; index &lt; 10; index++ &#123;
    sum += index
    // break
    // continue
&#125;
fmt.Println(&quot;sum is equal to&quot;, sum)
</code></pre>
<pre><code class="go">var user = map[string]string &#123;
    &quot;name&quot;: &quot;zhangsan&quot;,
    &quot;age&quot;: &quot;20&quot;
&#125;
for k, v := range user &#123; // 遍历 map 类型
    fmt.Println(&quot;map&#39;s key:&quot;, k)
    fmt.Println(&quot;map&#39;s value:&quot;, v)
&#125;
</code></pre>
</li>
<li><p>并发</p>
<ul>
<li>协程（即轻量级线程）/goroutine<pre><code class="go">import (
    &quot;fmt&quot;
    &quot;time&quot;
)
func say(s string) &#123;
    for i := 0; i &lt; 5; i++ &#123;
        time.Sleep(100 * time.Millisecond)
        fmt.Println(s)
    &#125;
&#125;
func main() &#123;
    go say(&quot;world&quot;) // 使用 go 语句开启一个新的运行期线程（即 goroutine），以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间
    say(&quot;hello&quot;)
&#125;
</code></pre>
</li>
<li>chan（类似于 Java 的 BlockingQueue）<pre><code class="go">import (
    &quot;fmt&quot;
)
func main() &#123;
    c := make(chan int, 10) // 创建一个（双向）通道，指定缓冲区大小位 10
    go fibonacci(cap(c), c)
    for i := range c &#123; // range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不会结束，从而在接收第 11 个数据的时候就阻塞了。
        fmt.Println(i)
    &#125;
&#125;
func fibonacci(n int, c chan int) &#123;
    x, y := 0, 1
    for i := 0; i &lt; n; i++ &#123;
        c &lt;- x // 把变量 x 发送到通道 c
        x, y = y, x + y
    &#125;
    close(c) // 关闭通道
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>延迟调用 defer<br>  defer 修饰的语句会被延迟执行，在 defer 所在的函数返回或执行结束前，会将 defer 语句的按照逆序进行执行（类似栈，即后进先出）。Go 语言中的 defer 类似于 Java 或 C# 的 finally 语句块，一般用于释放某些已分配的资源，典型的例子就是对一个互斥解锁，或者关闭一个文件。</p>
<pre><code class="go">func main() &#123;
    fmt.Println(&quot;defer begin&quot;)
    // 将defer放入延迟调用栈
    defer fmt.Println(1)
    defer fmt.Println(2)
    // 最后一个放入, 位于栈顶, 最先调用
    defer fmt.Println(3)
    fmt.Println(&quot;defer end&quot;)
&#125;

// 代码输出如下
// defer begin
// defer end
// 3
// 2
// 1
</code></pre>
</li>
</ul>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><ul>
<li><p>定时任务</p>
<pre><code class="go">import &quot;time&quot;
ticker := time.NewTicker(time.Minute * 1)
go func() &#123;
    // 每隔一分钟打印当前时间
    for _ = range ticker.C &#123;
        fmt.Printf(&quot;\rnow time is %v&quot;, time.Now())
    &#125;
&#125;()
</code></pre>
</li>
<li><p>正则</p>
<pre><code class="go">import &quot;regexp&quot;

re, _ := regexp.Compile(&quot;[a-z]&#123;2,4&#125;&quot;)

a := &quot;I am learning Go language&quot;

// 查找符合正则的第一个
one := re.Find([]byte(a))
fmt.Println(string(one)) // am

// 查找符合正则的所有 slice
all := re.FindAll([]byte(a), -1) // n (这里是 -1) 小于 0,表示返回全部符合的字符串，不然就是返回指定的长度
fmt.Println(all)
</code></pre>
</li>
<li><p>json</p>
<pre><code class="go">import &quot;encoding/json&quot;

type User struct &#123;
    Name    string `json:&quot;name&quot;`
    Gender  bool   `json:&quot;gender,omitempty&quot;` // &quot;omitempty&quot; 表示该字段如果没有提供，在序列化成 json 的时候就不要包含其默认值
    Age     int    `json:&quot;age&quot;`
    Address string `json:&quot;-&quot;` // &quot;-&quot; 表示不进行序列化
&#125;

user := &amp;User&#123;&#125;
user.Name = &quot;zhangsan&quot;
user.Gender = true
user.Age = 22
user.Address = &quot;earth&quot;

// 序列化
data, _ := json.Marshal(user)
fmt.Println(string(data)) // &#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;gender&quot;:true,&quot;age&quot;:22&#125;

// 反序列化
u := &amp;User&#123;&#125;
err := json.Unmarshal([]byte(data), u)
if err != nil &#123;
    panic(err)
&#125;
fmt.Println(*u) // &#123;zhangsan true 22 &#125;
</code></pre>
</li>
<li><p>embed（需 goland 版本 ≥ 1.16）</p>
<pre><code class="go">package main

import (
    &quot;embed&quot;
    &quot;net/http&quot;
)

//go:embed js/* css/* img/* *.html robot.txt
var fileList embed.FS

func main() &#123;
    http.Handle(&quot;/&quot;, http.FileServer(http.FS(fileList)))
    http.ListenAndServe(&quot;:8080&quot;, nil)
&#125;
</code></pre>
<blockquote>
<p>原理是使用 <code>//go:embed</code> 标签来完成  </p>
<ol>
<li>文件不是 utf8 编码时，输出内容为中文会乱码</li>
<li>测试过嵌入文件只能为源码文件同级目录和子目录下的文件，其他目录的绝对路径或相对路径会报错</li>
<li>如果路径包含空格可以使用双引号或反引号括起来</li>
<li>变量的类型只能是 <code>string</code>、<code>[]byte</code>、<code>embed.FS</code>，即使是这三个类型的别名也不行</li>
</ol>
</blockquote>
</li>
<li><p>unsafe</p>
<pre><code class="go">import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

var flag bool
var n1 int64 = 10
var name string = &quot;小白&quot;

fmt.Printf(&quot;int的字节大小&quot;, unsafe.Sizeof(n1)) // 获取 int 的字节大小
fmt.Println()
fmt.Printf(&quot;string的字节大小&quot;, unsafe.Sizeof(name))
fmt.Println()
fmt.Printf(&quot;bool的字节大小&quot;, unsafe.Sizeof(flag))
</code></pre>
</li>
<li><p>runtime</p>
<pre><code class="go">import (
    &quot;fmt&quot;
    &quot;runtime&quot;
)

var m runtime.MemStats
runtime.ReadMemStats(&amp;m)

fmt.Printf(&quot;%+v\n&quot;, m) // 获取内存信息
fmt.Printf(&quot;os %d\n&quot;, m.Sys)
</code></pre>
</li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul>
<li><p>http 静态服务器</p>
<pre><code class="golang">package main

import (&quot;net/http&quot;)

func main() &#123;
    http.Handle(&quot;/&quot;, http.FileServer(http.Dir(&quot;.&quot;)))
    http.ListenAndServe(&quot;:8080&quot;, nil)
&#125;
</code></pre>
</li>
<li><p>http 服务器</p>
<pre><code class="golang">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;strings&quot;
    &quot;log&quot;
)

func main() &#123;
    http.HandleFunc(&quot;/greeting&quot;, func (w http.ResponseWriter, r *http.Request) &#123;
        r.ParseForm() // 解析参数，默认是不会解析的
        fmt.Println(r.Form) // 这些信息是输出到服务器端的打印信息
        fmt.Println(&quot;path&quot;, r.URL.Path)
        fmt.Println(&quot;scheme&quot;, r.URL.Scheme)
        fmt.Println(r.Form[&quot;url_long&quot;])
        for k, v := range r.Form &#123;
            fmt.Println(&quot;key:&quot;, k)
            fmt.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;))
        &#125;
        fmt.Fprintf(w, &quot;&lt;html&gt;&lt;body&gt;hello, world&lt;/body&gt;&lt;/html&gt;&quot;) // 这个写入到 w 的是输出到客户端的
    &#125;)

    err := http.ListenAndServe(&quot;:8080&quot;, nil) // 设置监听的端口
    if err != nil &#123;
        log.Fatal(&quot;Fail to start server&quot;, err)
    &#125;
&#125;
</code></pre>
<pre><code class="go">package main

import (
    &quot;io&quot;
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    // &quot;html&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;net/http&quot;
)

type Order struct &#123;
    AppId      string `json:&quot;appid&quot;`
    MchId      string `json:&quot;mch_id&quot;`
    OutTradeNo string `json:&quot;out_trade_no&quot;`
    TotalFee   int    `json:&quot;total_fee&quot;`
    NonceStr   string `json:&quot;nonce_str&quot;`
    Sign       string `json:&quot;sign&quot;`
    SignType   string `json:&quot;sign_type&quot;`
&#125;

type Result struct &#123;
    Code string `json:&quot;code&quot;`
    Msg  string `json:&quot;msg&quot;`
&#125;

func main() &#123;
    // curl http://127.0.0.1:8002/pay/unifiedorder -XPOST -d &#39;&#123;&quot;appid&quot;:&quot;1&quot;,&quot;mch_id&quot;:&quot;1&quot;,&quot;out_trade_no&quot;:&quot;1&quot;,&quot;total_fee&quot;:1&#125;&#39;
    http.HandleFunc(&quot;/pay/unifiedorder&quot;, func (w http.ResponseWriter, r *http.Request) &#123;
        // fmt.Fprintf(w, &quot;the url is %q&quot;, html.EscapeString(r.URL.Path))
        if r.Method == &quot;POST&quot; &#123;
            b, err := ioutil.ReadAll(r.Body)
            if err != nil &#123;
                log.Println(&quot;Read failed&quot;, err)
            &#125;
            defer r.Body.Close()

            order := &amp;Order&#123;&#125;
            err = json.Unmarshal(b, order)
            if err != nil &#123;
                log.Println(&quot;Json unmarshal error&quot;, err)
            &#125;
            log.Println(&quot;order&quot;, order)

            result := &amp;Result&#123;&#125;
            result.Code = &quot;SUCCESS&quot;
            result_json, _ := json.Marshal(result)
            io.WriteString(w, string(result_json))
        &#125; else &#123;
            fmt.Fprintf(w, &quot;The method &quot; + r.Method + &quot; was not support&quot;)
        &#125;
    &#125;)
    log.Fatal(http.ListenAndServe(&quot;:8002&quot;, nil))
&#125;
</code></pre>
</li>
<li><p>http 请求</p>
<pre><code class="golang">import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;net/http&quot;
    &quot;time&quot;
)

client := http.Client&#123;
    Timeout: 5 * time.Second,
&#125;
resp, err := client.Get(&quot;http://www.baidu.com&quot;)
// resp, err := http.Get(&quot;http://www.baidu.com&quot;)
if err != nil &#123;
    fmt.Println(err)
    return
&#125;
html, _ := ioutil.ReadAll(resp.Body)
fmt.Println(string(html))
</code></pre>
</li>
</ul>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><ul>
<li><p><a href="https://github.com/mattn/go-sqlite3">sqlite3</a></p>
<ol>
<li><p>下载</p>
<pre><code class="bash">go get github.com/mattn/go-sqlite3
</code></pre>
</li>
<li><p>示例</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
    &quot;database/sql&quot;
    _ &quot;github.com/mattn/go-sqlite3&quot;
)

func main() &#123;
    // 打开/创建
    db, err := sql.Open(&quot;sqlite3&quot;, &quot;./my.db&quot;)

    // 创建表
    _, err = db.Exec(`
        create table if not exists user (
            uid integer primary key autoincrement,
            name varchar(128) null,
            birthday date null
        );
    `)

    // 新增
    stmt, err := db.Prepare(&quot;insert into user(name, birthday) values(?, ?)&quot;)
    if err != nil &#123;
        panic(err)
    &#125;
    res, err := stmt.Exec(&quot;luffy&quot;, &quot;2012-12-09&quot;) // res 为返回结果
    if err != nil &#123;
        panic(err)
    &#125;
    id, err := res.LastInsertId() // 可以通过 res 取自动生成的 id
    if err != nil &#123;
        panic(err)
    &#125;
    fmt.Println(&quot;insert success with id is&quot;, id)

    // 更新
    stmt, err = db.Prepare(&quot;update user set name = ? where uid = ?&quot;)
    if stmt == nil || err != nil &#123;
        panic(err)
    &#125;
    _, err = stmt.Exec(&quot;zhangsan&quot;, 1)
    if err != nil &#123;
        panic(err)
    &#125;

    // 查询
    rows, err := db.Query(&quot;select * from user&quot;)
    if err != nil &#123;
        panic(err)
    &#125;
    defer rows.Close()
    for rows.Next() &#123;
        var uid int
        var name string
        var birth time.Time
        err = rows.Scan(&amp;uid, &amp;name, &amp;birth)
        if err != nil &#123;
            panic(err)
        &#125;
        fmt.Printf(&quot;&#123; \&quot;uid\&quot;: %d, \&quot;name\&quot;: \&quot;%s\&quot;, \&quot;birthday\&quot;: \&quot;%s\&quot; &#125;\n&quot;, uid, name, birth)
    &#125;

    // 删除
    stmt, err = db.Prepare(&quot;delete from user where uid = ?&quot;)
    if err != nil &#123;
        panic(err)
    &#125;
    res, err = stmt.Exec(id)
    if err != nil &#123;
        panic(err)
    &#125;

    // 关闭
    db.Close()
&#125;
</code></pre>
</li>
</ol>
</li>
<li><p><a href="https://github.com/gin-gonic/gin">Gin</a>（需要 Go 版本 ≥ 1.6）</p>
<ol>
<li><p>下载并安装</p>
<pre><code class="bash"># 加速
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn,direct

go mod init myapp

# 下载、安装 Gin
go get -u github.com/gin-gonic/gin
</code></pre>
</li>
<li><p>示例</p>
<pre><code class="go">package main

import &quot;github.com/gin-gonic/gin&quot;

func main() &#123;
    r := gin.Default()
    r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123;
        c.JSON(200, gin.H&#123;
            &quot;message&quot;: &quot;pong&quot;,
        &#125;)
    &#125;)
    r.Run() // listen and serve on 0.0.0.0:8080
&#125;
</code></pre>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
    &quot;github.com/gin-gonic/gin&quot;
)

type Login struct &#123;
    Name string `form:&quot;name&quot; json:&quot;name&quot; xml:&quot;name&quot;  binding:&quot;required&quot;`
    Pass string `form:&quot;pass&quot; json:&quot;pass&quot; xml:&quot;pass&quot; binding:&quot;required&quot;`
&#125;

func main() &#123;
    router := gin.Default()

    // curl http://127.0.0.1:8002/greeting/luffy
    router.GET(&quot;/greeting/:name&quot;, func(c *gin.Context) &#123;
        name := c.Param(&quot;name&quot;) // 获取 URL 参数
        c.String(http.StatusOK, &quot;hello, %s&quot;, name)
    &#125;)

    // curl -XPOST http://127.0.0.1:8002/parameter/Andy?q=Bob -d &#39;f=Charlie&#39;
    // curl -XPOST &quot;http://127.0.0.1:8002/parameter/Andy?qm[a]=Bob&amp;qm[b]=Emma&quot; -d &#39;fm[a]=Charlie&amp;fm[b]=Frank&#39;
    router.POST(&quot;/parameter/:p&quot;, func(c *gin.Context) &#123;
        p := c.Param(&quot;p&quot;) // 获取 URL 参数
        q := c.Query(&quot;q&quot;) // 获取 URL 后面拼接的参数
        d := c.DefaultQuery(&quot;d&quot;, &quot;Dick&quot;) // 获取 URL 后面拼接的参数，如果没有入参，则使用默认值 Dick
        f := c.PostForm(&quot;f&quot;) // 获取 form 表单参数
        qm := c.QueryMap(&quot;qm&quot;) // 获取 URL 后面拼接的参数，返回 Map
        fm := c.PostFormMap(&quot;fm&quot;) // 获取 form 表单参数，返回 Map
        c.JSON(200, gin.H&#123;
            &quot;p&quot;: p,
            &quot;q&quot;: q,
            &quot;d&quot;: d,
            &quot;f&quot;: f,
            &quot;qm&quot;: qm,
            &quot;fm&quot;: fm,
        &#125;)
    &#125;)

    // curl -XPOST http://127.0.0.1:8002/login -H &quot;Content-Type: application/json&quot; -d &#39;&#123; &quot;name&quot;: &quot;admin&quot;, &quot;pass&quot;: &quot;123&quot; &#125;&#39;
    router.POST(&quot;/login&quot;, func(c *gin.Context) &#123;
        var user Login
        if err := c.ShouldBindJSON(&amp;user); err != nil &#123;
            c.JSON(http.StatusBadRequest, gin.H&#123;&quot;error&quot;: err.Error()&#125;)
            return
        &#125;
        if user.Name != &quot;admin&quot; || user.Pass != &quot;123&quot; &#123;
            c.JSON(http.StatusUnauthorized, gin.H&#123; &quot;status&quot;: &quot;unauthorized&quot; &#125;)
            return
        &#125;
        c.JSON(http.StatusOK, gin.H&#123; &quot;status&quot;: &quot;you are logged in&quot; &#125;)
    &#125;)

    router.MaxMultipartMemory = 8 &lt;&lt; 20  // Set a lower memory limit for multipart forms (default is 32 MiB)
    // curl http://127.0.0.1:8002/upload -F &quot;file=@data.zip&quot;
    // curl -X POST http://127.0.0.1:8002/upload -F &quot;file=@data.zip&quot; -H &quot;Content-Type: multipart/form-data&quot;
    router.POST(&quot;/upload&quot;, func(c *gin.Context) &#123; // 单文件上传
        file, _ := c.FormFile(&quot;file&quot;)
        fmt.Println(&quot;upload with filename&quot;, file.Filename)
        c.SaveUploadedFile(file, &quot;./&quot; + file.Filename) // 保存文件至指定位置
        c.String(http.StatusOK, fmt.Sprintf(&quot;&#39;%s&#39; uploaded&quot;, file.Filename))
    &#125;)
    // curl -X POST http://127.0.0.1:8002/uploads -F &quot;upload[]=@data1.zip&quot; -F &quot;upload[]=@data2.zip&quot; -H &quot;Content-Type: multipart/form-data&quot;
    router.POST(&quot;/uploads&quot;, func(c *gin.Context) &#123; // 多文件上传
        form, _ := c.MultipartForm()
        files := form.File[&quot;upload[]&quot;]
        for _, file := range files &#123;
            fmt.Println(&quot;upload with filename %s&quot;, file.Filename)
            c.SaveUploadedFile(file, &quot;./&quot;)
        &#125;
        c.String(http.StatusOK, fmt.Sprintf(&quot;%d files uploaded&quot;, len(files)))
    &#125;)

    v1 := router.Group(&quot;/v1&quot;) // 分组
    &#123;
        // curl http://127.0.0.1:8002/v1/greeting
        v1.GET(&quot;/greeting&quot;, greeting)
        v1.POST(&quot;/greeting2&quot;, greeting)
    &#125;

    router.Run(&quot;:8002&quot;)
&#125;

func greeting(c *gin.Context) &#123;
    c.String(http.StatusOK, &quot;hello, world&quot;)
&#125;
</code></pre>
</li>
</ol>
</li>
<li><p><a href="https://github.com/robertkrimen/otto">otto</a></p>
<pre><code class="go">import &quot;github.com/robertkrimen/otto&quot;

vm := otto.New()
// 执行 js 代码
vm.Run(`
    abc = 2 + 2;
    console.log(&quot;The value of abc is &quot; + abc); // 4
`)

// 获取变量值
if value, err := vm.Get(&quot;abc&quot;); err == nil &#123;
    if value_int, err := value.ToInteger(); err == nil &#123;
        fmt.Printf(&quot;&quot;, value_int, err)
    &#125;
&#125;

// 变量赋值
vm.Set(&quot;def&quot;, 11)
vm.Run(`
    console.log(&quot;The value of def is &quot; + def);
    // The value of def is 11
`)
vm.Set(&quot;xyzzy&quot;, &quot;Nothing happens.&quot;)
vm.Run(`
    console.log(xyzzy.length); // 16
`)

// 获取表达式值
value, _ = vm.Run(&quot;xyzzy.length&quot;)
&#123;
    // value is an int64 with a value of 16
    value, _ := value.ToInteger()
&#125;
</code></pre>
</li>
<li><p><a href="https://github.com/dop251/goja">goja</a></p>
<pre><code class="go">import (
    &quot;github.com/dop251/goja&quot;
    &quot;github.com/dop251/goja_nodejs/require&quot;
)

registry := require.NewRegistryWithLoader(func(path string) ([]byte, error) &#123; // 创建自定义 require loader（registry 每次重新生成，防止 module 被缓存，从而导致 module 修改后不生效）
    rows, err := Db.Query(&quot;select jscontent from script where name = ?&quot;, path)
    if err != nil &#123;
        panic(err.Error())
        return nil, err
    &#125;
    defer rows.Close()
    if rows.Next() == false &#123;
        return nil, errors.New(&quot;The module was not found.&quot;)
    &#125;
    script := Script&#123;&#125;
    err = rows.Scan(&amp;script.JsContent)
    return []byte(script.JsContent), err
&#125;)

vm := goja.New()

_ = registry.Enable(vm) // 启用自定义 require loader 

vm.Set(&quot;exports&quot;, vm.NewObject())

time.AfterFunc(60000 * time.Millisecond, func() &#123; // 允许脚本最大执行的时间为 60 秒
    vm.Interrupt(&quot;The script executed timeout.&quot;)
&#125;)

// res, err := vm.RunString(&quot;require(&#39;./&quot; + name + &quot;&#39;).main();&quot;)

_, err = vm.RunString(script.JsContent)
if err != nil &#123;
    panic(err)
    return
&#125;
main, isFunction := goja.AssertFunction(vm.Get(&quot;main&quot;)) // 执行 js 中的 main 函数
if !isFunction &#123;
    panic(errors.New(&quot;The function main can not be found.&quot;))
    return
&#125;
res, err := main(goja.Undefined(), vm.ToValue(&quot;this is parameter&quot;))
</code></pre>
</li>
</ul>
<h2 id="第三方应用"><a href="#第三方应用" class="headerlink" title="第三方应用"></a>第三方应用</h2><ul>
<li><p>使用 <a href="https://github.com/rogercoll/httpdump">httpdump</a> 抓包 HTTP 报文</p>
<pre><code class="bash">apt install libpcap-dev
# yum install libpcap-devel

go install github.com/rogercoll/httpdump@latest
</code></pre>
<pre><code class="bash">httpdump

httpdump -level all -port 80

# parse pcap file
sudo tcpdump -wa.pcap tcp
httpdump -file a.pcap

# capture specified device:
httpdump -device eth0

# filter by ip and/or port
httpdump -port 80  # filter by port
httpdump -ip 101.201.170.152 # filter by ip
httpdump -ip 101.201.170.152 -port 80 # filter by ip and port
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/22/hello-world/</url>
    <content><![CDATA[<p>Hello, world</p>
]]></content>
  </entry>
  <entry>
    <title>Javascript</title>
    <url>/2025/03/22/javascript/</url>
    <content><![CDATA[<h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a><a href="http://www.w3school.com.cn/js/index.asp">Javascript</a></h1><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul>
<li><p>开启内容编辑</p>
<pre><code class="javascript">javascript:document.body.contentEditable=&quot;true&quot;; // &quot;false&quot; if you want to diable
document.designMode=&quot;on&quot;;
</code></pre>
</li>
<li><p>提示消息框<br>  <code>var name = prompt(&quot;please input your name&quot;, &quot;luffy&quot;);</code><br>  确认消息框<br>  <code>var isOK = window.confirm(&quot;Are you OK?&quot;);</code></p>
</li>
<li><p>获取页面高度</p>
<pre><code class="javascript">// console.info(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
var height = Math.max(
    Math.max(document.body.scrollHeight, document.documentElement.scrollHeight),
    Math.max(document.body.offsetHeight, document.documentElement.offsetHeight),
    Math.max(document.body.clientHeight, document.documentElement.clientHeight)
);
</code></pre>
</li>
<li><p>打开新窗口</p>
<pre><code class="javascript">// let c = window.open(&quot;http://www.baidu.com&quot;, &quot;_blank&quot;);
let c = window.open(&quot;&quot;, &quot;&quot;, &quot;width=360,height=640&quot;); // 子窗口 window 对象
c.document.write(&quot;hello, world&quot;);
c.focus();
</code></pre>
<pre><code class="javascript">let p = window.opener; // 父窗口 window 对象
</code></pre>
</li>
<li><p>下载文件</p>
<pre><code class="javascript">fetch(&quot;/img/flexible/logo/pc/result.png&quot;).then(res =&gt; res.blob().then(blob =&gt; &#123;
    var url = window.URL.createObjectURL(blob);
    var filename = &quot;baidu.png&quot;;
    var a = document.createElement(&quot;a&quot;);
    a.href = url;
    a.download = filename;
    a.click();
    window.URL.revokeObjectURL(url); // 释放 url 对象内存
&#125;)); 
</code></pre>
</li>
<li><p>拖拽文件</p>
<pre><code class="javascript">let div = document.createElement(&quot;div&quot;);
div.style.width = &quot;400px&quot;;
div.style.height = &quot;300px&quot;;
div.style.border = &quot;dashed&quot;;

div.ondragenter = div.ondragover = div.ondragleave = function(e) &#123;
    e.preventDefault();
&#125;;
div.ondrop = function(e) &#123;
    e.preventDefault();

    let file = e.dataTransfer.files[0];

    let reader = new FileReader();
    reader.readAsBinaryString(file);
    reader.onload = function() &#123;
        let arr = new Uint8Array(this.result.length);
        for (let i = 0; i &lt; this.result.length; i++) &#123;
            arr[i] = this.result.charCodeAt(i);
        &#125;
        let url = window.URL.createObjectURL(new Blob([arr]));
        let a = document.createElement(&quot;a&quot;);
        a.href = url;
        a.download = file.name;
        a.click();
        window.URL.revokeObjectURL(url);
    &#125;
&#125;;

document.body.appendChild(div);
</code></pre>
</li>
<li><p>Blob 切分、合并</p>
<pre><code class="javascript">let blob = e.dataTransfer.files[0]; // some file from user...

let cursor = 0,
    arr = [];
while(cursor &lt; blob.size) &#123;
    let b = blob.slice(cursor, cirsor += 1 * 1024 * 1024); // 切分，分片不超过 1 MB
    arr.push(b);
&#125;

let merged = new Blob(arr); // 合并
</code></pre>
</li>
<li><p>FileReader</p>
<pre><code class="javascript">let file = e.dataTransfer.files[0];

let reader = new FileReader();

var url = null, blob = null;

// 读取为 URL 对象
reader.readAsDataURL(file);
reader.onload = function(e) &#123;
    // url = e.target.result;
    url = this.result;
    
    // 下载
    let a = document.createElement(&quot;a&quot;);
    a.href = url;
    a.download = file.name;
    a.click();
&#125;

// 读取为 ArrayBuffer 对象
reader.readAsArrayBuffer(file);
reader.onload = function() &#123;
    blob = new Blob([this.result]); // ArrayBuffer 转 Blob

    url = window.URL.createObjectURL(blob); // Blob 转 URL
    window.URL.revokeObjectURL(url); // 需要释放 URL
&#125;

// 读取为 BinaryString 字符串
reader.readAsBinaryString(file);
reader.onload = function() &#123;
    let arr = new Uint8Array(this.result.length);
    for (let i = 0; i &lt; this.result.length; i++) &#123;
        arr[i] = this.result.charCodeAt(i);
    &#125;
    blob = new Blob([arr]); // BinaryString 转 Blob
&#125;
</code></pre>
</li>
<li><p>HTML 编码（转义）、解码</p>
<pre><code class="javascript">function htmlEncode(str) &#123;
    var div = document.createElement(&quot;div&quot;);
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
&#125;
function htmlDecode(str) &#123;
    var div = document.createElement(&quot;div&quot;);
    div.innerHTML = str;
    return div.innerHTML;
&#125;
</code></pre>
</li>
<li><p>Base64 编码、解码</p>
<pre><code class="javascript">// 编码
window.btoa(&quot;china is so nb&quot;) // &quot;Y2hpbmEgaXMgc28gbmI=&quot;

// 解码
window.atob(&quot;Y2hpbmEgaXMgc28gbmI=&quot;) // &quot;china is so nb&quot;
</code></pre>
</li>
<li><p>使用 canvas 处理图片</p>
<pre><code class="javascript">// document.body.innerHTML = &quot;&quot;;

let input = document.createElement(&quot;input&quot;);
input.type = &quot;file&quot;;
input.name = &quot;picture&quot;;
document.body.appendChild(input);

let canvas = document.createElement(&quot;canvas&quot;);
document.body.appendChild(canvas);

let image = new Image();
image.onload = function () &#123;
    canvas.width = image.width;
    canvas.height = image.height;

    let context = canvas.getContext(&quot;2d&quot;);
    context.drawImage(image, 0, 0);

    let imageData = context.getImageData(0, 0, image.width, image.height); // 获取图像信息

    for (y = 0; y &lt; imageData.height; y++) &#123; // 图像的高/像素
        for (x = 0; x &lt; imageData.width; x++) &#123; // 图像的宽/像素
            let idx = (imageData.width * y + x) * 4; // 像素点在 ImageData.data: Uint8ClampedArray 中的位置（每连续四个值为一个像素的 RGBA 值）

            let r = imageData.data[idx + 0], // red
                g = imageData.data[idx + 1], // green
                b = imageData.data[idx + 2], // blue
                a = imageData.data[idx + 3]; // alpha

            let gray = 0.299 * r + 0.578 * g + 0.114 * b; // 计算灰度值
            imageData.data[idx + 0] = imageData.data[idx + 1] = imageData.data[idx + 2] = gray;
        &#125;
    &#125;

    context.putImageData(imageData, 0, 0); // 设置图像信息
    
    // canvas.toDataURL(&quot;image/webp&quot;, 0.8) // 转换成 webp 格式（默认为 image/png，其它可选有 image/jpeg），质量为 0.8（默认为 0.92，取值范围为 0-1）
&#125;;

input.onchange = function(e) &#123;
    var reader = new FileReader();
    // reader.readAsDataURL(e.target.files[0]);
    reader.readAsDataURL(this.files[0]);
    reader.onload = function(e) &#123;
        // image.src = e.target.result;
        image.src = this.result;
    &#125;
&#125;;
</code></pre>
</li>
<li><p>屏幕、应用窗口、页面捕捉</p>
<pre><code class="javascript">let video = document.createElement(&quot;video&quot;);
video.controls = true;
video.autoplay = true;
video.playsinline = true;
video.muted = false;
video.volume = 0;
document.body.appendChild(video);

(navigator.mediaDevices || navigator).getDispayMedia(&#123;
    video: true
&#125;).then(stream =&gt; &#123;
    video.srcObject = stream;
&#125;).catch(err =&gt; &#123;
    console.error(err.message);
&#125;);
</code></pre>
</li>
<li><p>双向绑定（仿 vue 实现）</p>
</li>
<li><p>有限状态机</p>
</li>
<li><p>语音朗读</p>
<pre><code class="javascript">let voice = window.speechSynthesis.getVoices().filter(v =&gt; v.lang === &quot;zh-CN&quot; &amp;&amp; v.localService === true &amp;&amp; v.default === true).pop();

let utterance = new SpeechSynthesisUtterance(&quot;hello, world&quot;);
utterance.voice = voice;
// utterance.pitch
// utterance.rate
window.speechSynthesis.speak(utterance);
</code></pre>
</li>
<li><p>获取地理位置信息</p>
<pre><code class="javascript">navigator.geolocation.getCurrentPosition(function (position) &#123;
    console.debug(&quot;The current position is&quot;, position);
&#125;, function (error) &#123;
    console.error(&quot;Can not get current position&quot;, error.message);
&#125;, &#123;
    enableHighAccuracy: false, // 位置是否精确获取
    timeout: 8000, // 获取位置允许的最长时间，默认为 infinity
    maximumAge: 1000 // 多久更新获取一次位置，位置可以缓存的最大时间，默认为 0
&#125;);
</code></pre>
</li>
<li><p>异步动态加载 js</p>
<pre><code class="javascript">const require = function (src) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        if (window.modules == null) &#123;
            window.modules = [];
        &#125;
        if (window.modules.indexOf(src) === -1) &#123;
            let script = document.createElement(&quot;script&quot;);
            script.src = src;
            script.onload = function () &#123;
                resolve(src);
                window.modules.push(src);
            &#125;;
            document.body.appendChild(script);
        &#125;
    &#125;);
&#125;;
require(&quot;https://cdn.jsdelivr.net/mark.js/latest/&quot;).then(s =&gt; &#123; console.debug(&quot;loaded success&quot;, s) &#125;);
</code></pre>
</li>
<li><p>修改浏览器 UA（即 User Agent）</p>
<pre><code class="javascript">Object.defineProperty(navigator, &quot;platform&quot;, &#123;
    get: function () &#123;
        return &quot;Android&quot;;
    &#125;
&#125;);

navigator.platform // Android
</code></pre>
</li>
<li><p>网页的宽度自动适应手机屏幕的宽度</p>
<pre><code class="html">&lt;head&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&gt;
&lt;/head&gt;
</code></pre>
<blockquote>
<ol>
<li>width=device-width ：表示宽度是设备屏幕的宽度</li>
<li>initial-scale=1.0：表示初始的缩放比例，1.0 就是占网页的 100%</li>
<li>minimum-scale=1.0：表示最小的缩放比例</li>
<li>maximum-scale=1.0：表示最大的缩放比例</li>
<li>user-scalable=no：表示用户是否可以调整缩放比例</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li><p>闭包</p>
<pre><code class="javascript">(function() &#123;
    // 闭包函数内容
&#125;)(); // 在定义后调用外层函数
</code></pre>
</li>
<li><p>计算的属性名称</p>
<pre><code class="javascript">var foo = &#123;
    [`bar` + 1]: `baz`
&#125;; // &#123;&quot;bar1&quot;:&quot;baz&quot;&#125;
</code></pre>
</li>
<li><p>按照指定的周期(以毫秒计)来调用函数或计算表达式</p>
<pre><code class="javascript">// 每隔1秒打印一次当前时间
var obj = setInterval(function()&#123;
    console.info(new Date());
&#125;, 1000);
// 取消由 setInterval() 设置的 timeout
clearInterval(obj);
</code></pre>
</li>
<li><p>在指定的毫秒数后调用函数或计算表达式</p>
<pre><code class="javascript">// 5 秒后打印 &quot;hello, world&quot;
var obj = setTimeout(function()&#123;
    console.info(&quot;hello, world&quot;);
&#125;, 5000);
// 取消由 setTimeout() 方法设置的 timeout
clearTimeout(obj);
</code></pre>
</li>
<li><p>中文字符串转换为 unicode 码</p>
<pre><code class="javascript">var u = escape(&quot;中文&quot;).toLowerCase().replace(/%u/g, &quot;\\u&quot;);
console.info(u);
</code></pre>
</li>
<li><p>URL 编码、解码</p>
<pre><code class="javascript">var e = encodeURI(&quot;xxx&quot;); // 转义空格
car e = encodeURIComponent(&quot;xxx&quot;); // 转义所有非字母数字字符
var d = decodeURI(&quot;xxx&quot;);
var d = decodeURIComponent(&quot;xxx&quot;);
</code></pre>
</li>
<li><p>Number 和 BigInt</p>
<pre><code class="javascript">// 显示 Number 类型最大值，不使用科学记数法
console.info(Number.MAX_VALUE.toLocaleString());
</code></pre>
<pre><code class="javascript">0.1 + 0.2 // 0.30000000000000004

0.1 + 0.2 === 0.3000000000000000[2-7] // true
0.1 + 0.2 === 0.3000000000000000[0189] // false
</code></pre>
<blockquote>
<p>js 中，Number 类型是用双精度 64 位浮点格式表示，只能安全表示 Number.MIN_SAFE_INTEGER (-2 ^ 53 - 1) ~ Number.MAX_SAFE_INTEGER (2 ^ 53 - 1) 之间的整数，解决方案是使用 BigInt 类型表示，如 9n 或 BigInt(“9”)</p>
</blockquote>
</li>
<li><p>字符串与整数互转以及移位操作 byte 截取 bit</p>
<blockquote>
<p>JavaScript 的所有位操作都是先将操作对象转化为 32 位有符号数进行的。详见 Ecma-262 规范（JavaScript 的正式名称是 “ECMAScript”，其语法由 Ecma-262 规范描述）。</p>
</blockquote>
<pre><code class="javascript">// 显示整数 &quot;257&quot; 的十进制形式
console.info((257).toString(2)); // &quot;100000001&quot;
// 取二进制形式的低八位（即 &quot;00000001 00000001&quot; 中后八位 &quot;00000001&quot;）
console.info((257 &amp; 0xff).toString(2)); // &quot;1&quot;

// 将二进制字符串 &quot;10101010&quot; 转换为无符号整数i
var i = parseInt(&quot;10101010&quot;, 2); // &quot;170&quot;
// i = parseInt(&quot;-10101010&quot;, 2); // &quot;-170&quot;

// 将整数i右移5位并转换为二进制字符串，即截取二进制字符串 &quot;10101010&quot; 前3位（&quot;101&quot;）
console.info((i &gt;&gt; (8 - 3)).toString(2));

// 显示 &quot;-5&quot; 的二进制表示形式（&quot;11111011&quot;）
console.info((-5 &amp; 0xff).toString(2));
// 对 &quot;5&quot; 进行按位非操作，并显示其二进制表示形式（&quot;11111011&quot;）
console.info((~5 &amp; 0xff).toString(2));

console.assert(~255 + 1 == 255 * -1);

// 通过使用无符号右移运算符，位动位数为0，可以将32位有符号整数，转化为32位无符号整数，即&quot;unsigned = signed &gt;&gt;&gt; 0;&quot;
console.info(-5 &gt;&gt;&gt; 0); // &quot;4294967291&quot;
// 通过使用左移运算符，位动位数为0，可以将32位无符号整数，转化为32位有符号整数，即&quot;signed = unsigned &lt;&lt; 0;&quot;
console.info(4294967291 &lt;&lt; 0); // &quot;-5&quot;

// 将8位有符号整数，转化为8位无符号整数
console.info(-5 &gt;&gt;&gt; 0 &amp; 0xff); // &quot;251&quot;，二进制为&quot;11111011&quot;
// &lt;=&gt; console.info(parseInt((-5 &amp; 0xff).toString(2), 2));
// 将8位无符号整数，转化为8位有符号整数
(function(uint8_value) &#123;
    return (uint8_value &amp; 0xff) &gt;&gt; 7 == 1 ? ((~uint8_value &amp; 0xff) + 1) * -1 : uint8_value;
    // 第一位为符号位，剩余七位为数值位。1表示负数，其值等于所有位取反加1；0表示正数，所有位直接转化为十进制即为值大小。
&#125;)(251); // &quot;-5&quot;，将所有位（251，二进制为&quot;11111011&quot;）按位取反（&quot;00000100&quot;）并加1（&quot;00000101&quot;，即十进制5），由于&quot;11111011&quot;第一位为1，表示负数，因此结果为&quot;-5&quot;
</code></pre>
</li>
<li><p>字符与 ascii 码互转</p>
<pre><code class="javascript">&quot;a&quot;.charCodeAt() // 97

String.fromCharCode(97) // &quot;a&quot;
String.fromCharCode(97, 98) // &quot;ab&quot;
// String.fromCharCode(...[97, 98]) // &quot;ab&quot;
String.fromCharCode.apply(null, [97, 98]) // &quot;ab&quot;
</code></pre>
</li>
<li><p>模板字面量与标签函数</p>
<pre><code class="javascript">let name = &quot;world&quot;;

// 模板字面量   
let str = `hello, $&#123;name&#125;`;
console.log(str); // hello, world

// 标签函数
let greeting = (name) =&gt; &#123;
    return `hello, $&#123;name&#125;`;
&#125;;
greeting`world`; // hello, world
</code></pre>
</li>
<li><p>可选链</p>
<pre><code class="javascript">const obj = &#123;
    prop: &#123;
        a: &quot;value&quot;
    &#125;
&#125;

// Optional Chaining
obj.foo?.a // undefined
</code></pre>
</li>
<li><p>丢弃小数部分，保留整数部分<br>  <code>var r = parseInt(5/2);</code><br>  向上取整，有小数就整数部分加 1<br>  <code>var r = Math.ceil(5/2);</code><br>  四舍五入<br>  <code>var r = Math.round(5/2);</code><br>  向下取整<br>  <code>var r = Math.floor(5/2);</code>  </p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">abs(x)</td>
<td align="left">返回数的绝对值</td>
</tr>
<tr>
<td align="left">acos(x)</td>
<td align="left">返回数的反余弦值</td>
</tr>
<tr>
<td align="left">asin(x)</td>
<td align="left">返回数的反正弦值</td>
</tr>
<tr>
<td align="left">atan(x)</td>
<td align="left">以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值</td>
</tr>
<tr>
<td align="left">atan2(y, x)</td>
<td align="left">返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）</td>
</tr>
<tr>
<td align="left">ceil(x)</td>
<td align="left">对数进行上舍入</td>
</tr>
<tr>
<td align="left">cos(x)</td>
<td align="left">返回数的余弦</td>
</tr>
<tr>
<td align="left">exp(x)</td>
<td align="left">返回 e 的指数</td>
</tr>
<tr>
<td align="left">floor(x)</td>
<td align="left">对数进行下舍入</td>
</tr>
<tr>
<td align="left">log(x)</td>
<td align="left">返回数的自然对数（底为 e）</td>
</tr>
<tr>
<td align="left">max(x, y)</td>
<td align="left">返回 x 和 y 中的最高值</td>
</tr>
<tr>
<td align="left">min(x, y)</td>
<td align="left">返回 x 和 y 中的最低值</td>
</tr>
<tr>
<td align="left">pow(x, y)</td>
<td align="left">返回 x 的 y 次幂</td>
</tr>
<tr>
<td align="left">random()</td>
<td align="left">返回 0 ~ 1 之间的随机数</td>
</tr>
<tr>
<td align="left">round(x)</td>
<td align="left">把数四舍五入为最接近的整数</td>
</tr>
<tr>
<td align="left">sin(x)</td>
<td align="left">返回数的正弦</td>
</tr>
<tr>
<td align="left">sqrt(x)</td>
<td align="left">返回数的平方根</td>
</tr>
<tr>
<td align="left">tan(x)</td>
<td align="left">返回角的正切</td>
</tr>
<tr>
<td align="left">toSource()</td>
<td align="left">返回该对象的源代码</td>
</tr>
<tr>
<td align="left">valueOf()</td>
<td align="left">返回 Math 对象的原始值</td>
</tr>
</tbody></table>
</li>
<li><p>断言<br>  <code>console.assert(1 == 2, &quot;not equal&quot;);</code></p>
</li>
<li><p>js 中 “==” 与 “===” 区别</p>
<ul>
<li>“==” 是比较两边<strong>值</strong>是否相同</li>
<li>“===” 是比较两边<strong>值</strong>和<strong>类型</strong>是否相同</li>
</ul>
</li>
<li><p>对象展开运算符 (ES6)</p>
<pre><code class="javascript">let a = [1, 2, 3];
let b = [0, ...a, 4]; // [0, 1, 2, 3, 4]

let obj = &#123; a: 1, b: 2 &#125;;
let obj2 = &#123; ...obj, c: 3 &#125;; // &#123; a: 1, b: 2, c: 3 &#125;
let obj3 = &#123; ...obj, a: 3 &#125;; // &#123; a: 3, b: 2 &#125;
</code></pre>
<pre><code class="javascript">// 剩余操作符
let a = [1, 2, 3];
let [b, ...c] = a;
b; // 1
c; // [2,3]

let a = [1, 2, 3];
let [b, ...[c, d, e]] = a;
b; // 1
c; // 2
d; // 3
e; // undefined

function test(a, ...rest)&#123;
    console.log(a); // 1
    console.log(rest); // [2, 3]
&#125;
test(1, 2, 3)
</code></pre>
<pre><code class="javascript">let object = &#123;
    a: &quot;01&quot;, b: &quot;02&quot;
&#125;;
let newObject = &#123;
    c: &quot;03&quot;,
    ...object
&#125;;
console.log(newObject); // &#123; c: &quot;03&quot;, a: &quot;01&quot;, b: &quot;02&quot; &#125;
</code></pre>
</li>
<li><p>从对象中删除属性</p>
<pre><code class="javascript">const user = &#123;
    id: 1,
    name: &quot;zhangsan&quot;,
    gender: &quot;male&quot;
&#125;;

// 使用 delete 运算符
delete user.name;
delete user[&quot;name&quot;];

// 使用 rest 语法进行对象解构
const &#123; name, ...restObject &#125; = user;
console.log(restObject); // &#123; id: 1, gender: &quot;male&quot; &#125;
</code></pre>
</li>
<li><p>正则表达式</p>
<pre><code class="javascript">var content = &quot;hello, world&quot;;

var pattern = new RegExp(&quot;o&quot;, &quot;g&quot;);
// var pattern = /o/g; // 修饰符 i 表示忽略大小写，g 表示全局匹配，m 表示多行匹配
while ((result = pattern.exec(content)) != null) &#123;
    var above = content.substring(0, result.index);
    var lineNum = (above.match(/[\n]/g) || []).length + 1;
    console.info(&quot;&#39;%s&#39; found in row: %s, col: %s&quot;, result[0], lineNum, result.index + 1);
&#125;

console.info(content.match(/o/g));
</code></pre>
<pre><code class="javascript">// 命名分组
&quot;data:image/png;base64,iVBORw0KGgoAAAANSUh...&quot;.match(/^data:image\/(?&lt;type&gt;[a-z]+);base64,(?&lt;data&gt;.+)$/).groups // &#123; &quot;type&quot;: &quot;png&quot;, &quot;data&quot;: &quot;iVBORw0KGgoAAAANSUh...&quot; &#125;
</code></pre>
</li>
<li><p><a href="https://blog.csdn.net/u010003835/article/details/79042135">集合</a></p>
<pre><code class="javascript">var a = [1, 2, 3], b = [2, 4, 5];

// ES7
&#123;
    // 并集
    let union = a.concat(b.filter(v =&gt; !a.includes(v))); // [1, 2, 3, 4, 5]
    // 交集
    let intersection = a.filter(v =&gt; b.includes(v)); // [2]
    // 差集
    let difference = a.concat(b).filter(v =&gt; a.includes(v) &amp;&amp; !b.includes(v)); // [1, 3]
&#125;

// ES6
&#123;
    // 并集
    let union = Array.from(new Set(a.concat(b))); // [1, 2, 3, 4, 5]
    // 交集
    var bSet = new Set(b);
    let intersection = Array.from(new Set(a.filter(v =&gt; bSet.has(v)))); // [2]
    // 差集
    var aSet = new Set(a);
    let difference = Array.from(new Set(a.concat(b).filter(v =&gt; aSet.has(v) &amp;&amp; !bSet.has(v)))); //  [1, 3]
&#125;

// ES5
&#123;
    // 并集
    var union = a.concat(b.filter(function (v) &#123; return a.indexOf(v) === -1 &#125;)); // [1, 2, 3, 4, 5]
    // 交集
    var intersection = a.filter(function (v) &#123; return b.indexOf(v) &gt; -1 &#125;); // [2]
    // 差集
    var difference = a.filter(function (v) &#123; return b.indexOf(v) === -1 &#125;); // [1, 3]
&#125;
</code></pre>
<pre><code class="javascript">var m = [[1, 3.0], [2, 3.9], [3, 2.0], [4, 1.2], [5, 1.3], [6, 2.5], [7, 2.0], [8, 3.1], [9, 2.9], [10, 0.9]];

// 数组降维
var arr = [].concat.apply([], m); // [1, 3, 2, 3.9, 3, 2, 4, 1.2, 5, 1.3, 6, 2.5, 7, 2, 8, 3.1, 9, 2.9, 10, 0.9]

// 数组去重
// var distinction = Array.from(new Set(arr));
// var distinction = [...new Set(arr)];
var distinction = arr.filter((item, index, arr) =&gt; &#123; return arr.indexOf(item) === index; &#125;); // [1, 3, 2, 3.9, 4, 1.2, 5, 1.3, 6, 2.5, 7, 8, 3.1, 9, 2.9, 10, 0.9]

// 数组排序
distinction.sort(); // [0.9, 1, 1.2, 1.3, 10, 2, 2.5, 2.9, 3, 3.1, 3.9, 4, 5, 6, 7, 8, 9]

// 数组求和
arr.reduce((total, current) =&gt; &#123;
    return total + current;
&#125;, 0);
</code></pre>
<pre><code class="javascript">// 多个数组求交集
let arr = [
    [1, 2, 3, 4],
    [3, 4, 6],
    [4, 5],
    [4, 5, 8, 9],
    [4, 5, 2, 7],
    [4, 5, 3],
    [4, 5, 0],
];
let res = arr.reduce((a, b) =&gt; &#123; 
    return a.filter(c =&gt; b.includes(c));
&#125;);
</code></pre>
<pre><code class="javascript">var users = [&#123; name: &quot;zhangsan&quot;, age: 14 &#125;, &#123; name: &quot;lisi&quot;, age: 15 &#125;];

// 映射数组为新数组
// 语法: array.map(function(currentValue, index, arr), thisValue)
var names = users.map(u =&gt; u.name); // [&quot;zhangsan&quot;, &quot;lisi&quot;]
names.map(n =&gt; &#123; return &#123; name: n, sex: &quot;male&quot; &#125; &#125;); // [&#123; name: &quot;zhangsan&quot;, sex: &quot;male&quot; &#125;, &#123; name: &quot;lisi&quot;, sex: &quot;male&quot; &#125;]

// 过滤数组为新数组
users.filter(u =&gt; u.age &gt; 14); // [&#123; name: &quot;lisi&quot;, age: 15 &#125;]

// 数组转对象
users.reduce((p, c) =&gt; &#123;
    p[c.name] = c.age;
    return p;
&#125;, &#123;&#125;); // &#123; zhangsan: 14, lisi: 15 &#125;
</code></pre>
<pre><code class="javascript">// 优雅地递归取数据
var data = [
    &#123;
        name: &quot;123&quot;,
        type: &quot;menu&quot;,
        children: [&#123; name: &quot;321&quot;, type: &quot;operation&quot;, children: null &#125;],
    &#125;,
    &#123;
        name: &quot;456&quot;,
        type: &quot;menu&quot;,
        children: [&#123; name: &quot;654&quot;, type: &quot;menu&quot;, children: [&#123; name: &quot;546&quot;, type: &quot;operation&quot;, children: null &#125;] &#125;],
    &#125;
];
const filterByType = (target, init = []) =&gt; &#123;
    target.forEach(item =&gt; &#123;
        item.type === &quot;operation&quot; &amp;&amp; init.push(item.name);
        item.children &amp;&amp; filterByType(item.children, init);
    &#125;);
    return init;
&#125;;
filterByType(data); // [&quot;321&quot;, &quot;546&quot;]
</code></pre>
<pre><code class="javascript">// ip 地址转换为二进制
&quot;192.168.0.101&quot;.split(&quot;.&quot;).reduce((total, cur) =&gt; total + (&quot;00000000&quot; + parseInt(cur).toString(2)).substr(-8), &quot;&quot;)
</code></pre>
<pre><code class="javascript">// 栈
let stack = [1, 2];
stack.push(3); // 入栈
console.debug(stack); // [1, 2, 3]
// 出栈最后一个元素
stack.pop(); // 3
console.debug(stack); // [1, 2]

// 队列
let queue = [1, 2];
queue.push(3); // 把数据放入队尾
console.debug(queue); // [1, 2, 3]
// 从队列中取出队列中的第一个数
queue.shift(); // 1
console.debug(queue); // [2, 3]
</code></pre>
<pre><code class="javascript">Array.from(&#123; length: 3 &#125;, (v, k) =&gt; k + 1); // [1, 2, 3]

// 创建一个 5x4 的二维数组
new Array(5).fill(&quot;&quot;).map(d =&gt; new Array(4).fill(0));
</code></pre>
<pre><code class="javascript">// 比较两个数组元素的出现顺序，时间复杂度均为 O(n)   

// using foreach
function compare(a, b) &#123;
    var i = 0;
    b.forEach(function(el) &#123;
        if(el == a[i]) i++;
    &#125;)
    return i == a.length;
&#125;

// using reduce
function compare2(a, b) &#123;
    return b.reduce(function(i, el) &#123;
        return el == a[i] ? i + 1 : i;
    &#125;, 0) == a.length;
&#125;

var a = [1,2,3];
var b = [0,1,4,3,9,10,2,5,6]; // 1,2,3 in wrong order
var c = [0,4,1,5,6,2,8,3,5];  // 1,2,3 in right order

console.log(compare(a,b)  ==  false);
console.log(compare(a,c)  ==  true);
console.log(compare2(a,b) ==  false);
console.log(compare2(a,c) ==  true);
</code></pre>
</li>
<li><p>Json</p>
<pre><code class="javascript">// json 序列化  
var string = JSON.stringify(object);
var string2 = JSON.stringify(object, (key, value) =&gt; &#123;
    if (key === &quot;phone&quot; &amp;&amp; value) &#123;
        return value.replace(/^(\d&#123;3&#125;)\d*(\d&#123;2&#125;)$/, &quot;$1***$2&quot;); // 脱敏
    &#125;
    return value;
&#125;, 4); // 文本添加缩进：空格、换行符。为 4 表示 4 个空格（最大为 10）；为 &quot;\t&quot; 表示 1 个制表符。
// json 反序列化
var object = JSON.parse(string);

// 格式化显示 json
document.body.innerHTML = `&lt;pre&gt;$&#123;JSON.stringify(obj, null, &quot;\t&quot;)&#125;&lt;/pre&gt;`;
</code></pre>
</li>
<li><p>Console</p>
<pre><code class="javascript">console.log(&quot;this is log message&quot;);
console.info(&quot;this is info message&quot;);
console.warn(&quot;this is warn message&quot;);
console.error(&quot;this is error message&quot;);

console.log(
    &quot;Nothing here %cHi Cat %cHey Bear&quot;,  // Console Message
    &quot;color: blue&quot;, &quot;color: red&quot; // CSS Style
);
console.log(&quot;\x1b[33m%s\x1b[0m&quot;, &quot;yellow&quot;); // nodejs 控制台设置颜色

// 1.将css样式传递给数组
const styles = [ 
    &quot;color:green&quot;,
    &quot;background:yellow&quot;,
    &quot;font-size:30px&quot;,
    &quot;border:1px solid red&quot;,
    &quot;text-shadow:2px 2px black&quot;,
    &quot;padding:10px&quot;
].join(&quot;;&quot;); // 2.连接单个数组项并将它们连接成一个用分号分隔的字符串（;）
// 3.传递样式变量
console.log(&quot;%cHello There&quot;, styles);
// or
console.log(&quot;%c%s&quot;, styles, &quot;Some Important Message Here&quot;);

console.log(&quot;%d 年 %d 月 %d 日&quot;, 2011, 3, 26); // 占位符

console.group(&quot;第一组信息&quot;);
console.log(&quot;第一组第一条&quot;);
console.log(&quot;第一组第二条&quot;);
console.groupEnd();
console.group(&quot;第二组信息&quot;);
console.log(&quot;第二组第一条&quot;);
console.groupEnd();

console.dir(&#123; // 显示一个对象所有的属性和方法
    name: &quot;zhangsan&quot;
&#125;);

console.dirxml(document.getElementById(&quot;info&quot;)); // 显示网页的某个节点（node）所包含的html/xml代码

console.assert(year === 2020, &quot;not equal&quot;); // 判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常

console.trace(); // 追踪函数的调用轨迹/调用栈

console.time(&quot;控制台计时器一&quot;);
for (var i = 0; i &lt; 1000; i++) &#123;
    for (var j = 0; j &lt; 1000; j++) &#123;&#125;
&#125;
console.timeEnd(&quot;控制台计时器一&quot;); // 显示代码的运行时间

console.profile(&quot;性能分析器&quot;);
// ...
console.profileEnd(); // 分析程序各个部分的运行时间

// 通过表格的形式打印数组和对象
console.table([&#123; name: &quot;zhangsan&quot; &#125;]);
</code></pre>
</li>
<li><p>async 和 await</p>
<pre><code class="javascript">// async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。await 只能出现在 async 函数中
function sleep(ms) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        setTimeout(resolve, ms);
    &#125;);
&#125;

async function print(value, ms) &#123;
    await sleep(ms);
    console.log(value);
&#125;

print(&quot;hello world&quot;, 50); // 指定 50 毫秒以后，输出 hello world
</code></pre>
<pre><code class="javascript">(async () =&gt; &#123;
    for (let i = 0; i &lt; 100; i++) &#123;
        const promise = fetch(&quot;https://127.0.0.1/greeting&quot;);
        const body = await (await promise).json();
        console.info(`The $&#123;i&#125;st request with response is`, body);
    &#125;
&#125;)();
</code></pre>
<pre><code class="javascript">// 仿 fetch 方法实现
function fetch(url) &#123;
    return new Promise(function (resolve, reject) &#123;
        var xhr = new XMLHttpRequest();
        xhr.open(&quot;GET&quot;, url, true);
        xhr.onreadystatechange = function () &#123;
            if(xhr.readyState == 4) &#123;
                if(xhr.status == 200) &#123;
                    resolve(xhr.responseText);
                &#125; else &#123;
                    reject(&quot;Server response failed.&quot;);
                &#125;
            &#125;
        &#125;;
        xhr.send(null);
    &#125;);
&#125;
fetch(&quot;http://www.baidu.com&quot;).then(function (res) &#123;
    console.info(res);
&#125;).catch(function (err) &#123;
    console.log(err);
&#125;);
</code></pre>
<blockquote>
<ul>
<li>async 与 await 配套使用，await 必须在 async 方法内部，await 返回结果为 Promise 对象中执行结果，即 resolved 或 rejected 的值</li>
<li>await 后面跟 Promise 对象或值，如果是值，则会转到一个立即 resolve 的 Promise 对象；async 返回一个 Promise 对象，如果是值，则自动包装为 Promise</li>
<li>async 方法中如果有多个 await，如果有一个 await 状态是 reject，则后面操作不会继续执行</li>
<li>await 用来串行的执行异步操作，并行的可以考虑 Promise.all([p1, p2, …])</li>
</ul>
</blockquote>
</li>
<li><p>其他</p>
<pre><code class="javascript">var as = [&#123; name: &quot;zhangsan&quot;, age: 14 &#125;, &#123; name: &quot;lisi&quot;, age: 15 &#125;];

for (var aa in as[0]) &#123; // for ... in 表示遍历属性
    console.assert(aa == &quot;name&quot; || aa == &quot;age&quot;);
&#125;

for (var a of as) &#123; // for ... of 表示遍历数组，for 循环的性能优于 forEach、map、filter 等
    console.assert(a.name == &quot;zhangsan&quot; || a.name == &quot;lisi&quot;);
&#125;
</code></pre>
<pre><code class="javascript">for (let t = Date.now(); Date.now() - t &lt;= 5000;); // 当前线程等待 5 秒
</code></pre>
<pre><code class="javascript">console.time(); // 计时开始
// console.time(&quot;timer01&quot;);
// ...
console.timeEnd(); // 计时结束，返回时差，单位毫秒，如 default: 944.423095703125ms
// console.timeEnd(&quot;timer01&quot;);
</code></pre>
<pre><code class="javascript">!Object.getOwnPropertyNames(obj).length &amp;&amp; (obj = null); // 如果 obj 是空对象，则赋值 obj 为 null
</code></pre>
</li>
<li><p>getter 和 setter</p>
<pre><code class="javascript">var obj = &#123;
    _val: 0,
    get val(): &#123;
        return this._val;
    &#125;,
    set val(_val): &#123;
        this._val = _val;
    &#125;
&#125;;
</code></pre>
<pre><code class="javascript">Object.defineProperty(obj, &quot;val&quot;, &#123;
    get: function() &#123;
        return this._val;
    &#125;
&#125;);
</code></pre>
</li>
<li><p>动态执行</p>
<pre><code class="javascript">// https://m.jb51.net/article/180809.htm
// 格式：let func = new Function(arg1, arg2, ..., body);
let sum = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b;&quot;);
console.log(sum(1, 2));

console.log(eval(&quot;1 + 2&quot;));
</code></pre>
</li>
<li><p>格式化字符串</p>
<pre><code class="javascript">String.prototype.format = function(...args) &#123;
    if (args.length == 1 &amp;&amp; typeof args[0] == &quot;object&quot;) &#123;
        let k = &quot;&quot;, v = &quot;&quot;;
        return this.replace(/&#123;[A-Za-z]+&#125;/g, (it, i) =&gt; &#123;
            k = it.slice(1, -1);
            v = args[0][k];
            return typeof v != &quot;undefined&quot; ? v : &quot;&quot;;
        &#125;)
    &#125;
    return this.replace(/&#123;(\d+)&#125;/g, (it, i) =&gt; &#123;
        return typeof args[i] != &quot;undefined&quot; ? args[i] : &quot;&quot;;
    &#125;);
&#125;;
console.log(&quot;我是&#123;0&#125;，今年&#123;1&#125;了. &#123;2&#125;&quot;.format(&quot;zhgl&quot;, 42, 0));
console.log(&quot;我是&#123;name&#125;，今年&#123;age&#125;了.&quot;.format(&#123; name: &quot;zhgl&quot;, age: 42 &#125;));
</code></pre>
<pre><code class="javascript">// 数字或字符串，指定长度，不足则前补零
((num, len) =&gt; &#123;
    return (Array(len).join(0) + num).slice(-len);
&#125;)(12, 3); // &quot;012&quot;
</code></pre>
<pre><code class="javascript">// 正则替换为自增数列
let i = 0;
&quot;00000000&quot;.replace(/\d/g, s =&gt; i++); // 012345678
</code></pre>
</li>
<li><p>格式化时间</p>
<pre><code class="javascript">Date.prototype.toString = function(fmt)   
&#123;
    var o = &#123;
        &quot;M+&quot;: date.getMonth() + 1,
        &quot;d+&quot;: date.getDate(),
        &quot;h+&quot;: date.getHours(),
        &quot;m+&quot;: date.getMinutes(),
        &quot;s+&quot;: date.getSeconds(),
        &quot;q+&quot;: Math.floor((date.getMonth() + 3) / 3),
        &quot;S&quot;: date.getMilliseconds()
    &#125;;
    if(/(y+)/.test(fmt)) &#123;
        fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));
    &#125;
    for(var k in o) &#123;
        if(new RegExp(&quot;(&quot;+ k +&quot;)&quot;).test(fmt)) &#123;
            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));
        &#125;
    &#125;
    return fmt;
&#125;;
new Date().toString(&quot;yyyy-MM-dd hh:mm:ss&quot;);
</code></pre>
</li>
<li><p>获取 url 参数</p>
<pre><code class="javascript">function getQueryParameter(name) &#123;
    var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;, &quot;i&quot;);
    var r = window.location.search.substr(1).match(reg);
    if (r != null) &#123;
        return unescape(r[2]);
    &#125;
    return null;
&#125;
</code></pre>
</li>
<li><p>csv 转 json 对象</p>
<pre><code class="javascript">function parse(csv) &#123;
    const COMMA_REGEX = /,(?=(?:[^\&quot;]*\&quot;[^\&quot;]*\&quot;)*[^\&quot;]*$)/g,
          QUOTES_REGEX = /^&quot;(.*)&quot;$/g;

    let lines = csv.split(&quot;\n&quot;),
        result = [],
        headers = lines[0].split(COMMA_REGEX).map(h =&gt; h.replace(QUOTES_REGEX, &quot;$1&quot;));

    for(let i = 1; i &lt; lines.length; i++) &#123;
        let obj = &#123;&#125;,
            currentline = lines[i].split(COMMA_REGEX);
        for(let j = 0; j &lt; headers.length; j++) &#123;
            obj[headers[j]] = currentline[j].replace(QUOTES_REGEX, &quot;$1&quot;);
        &#125;
        result.push(obj);
    &#125;
    return result;
&#125;
// parse(`id,name\n1,zhangsan\n`)
</code></pre>
</li>
<li><p>数组分页</p>
<pre><code class="javascript">function pagination(index, size, array) &#123;
    var offset = (index - 1) * size;
    return (offset + size &gt;= array.length) ? array.slice(offset, array.length) : array.slice(offset, offset + size);
&#125;
// pagination(1, 10, [...])
</code></pre>
</li>
<li><p>生成器函数</p>
<pre><code class="javascript">function * gen()&#123;
    yield 10;
    y = yield &quot;foo&quot;;
    yield y;
&#125;

var gen_obj = gen();
console.log(gen_obj.next()); // &#123; value: 10, done: false &#125;
console.log(gen_obj.next()); // &#123; value: &quot;foo&quot;, done: false &#125;
console.log(gen_obj.next(11)); // &#123; value: 11, done: false &#125;
console.log(gen_obj.next()); // &#123; value: undefine, done: true &#125;
</code></pre>
</li>
<li><p><a href="https://www.it1352.com/1013354.html">阻塞队列</a></p>
<pre><code class="javascript">class AsyncBlockingQueue &#123;
    constructor() &#123;
        // invariant: at least one of the arrays is empty
        this.resolvers = [];
        this.promises = [];
    &#125;
    _add() &#123;
        this.promises.push(new Promise(resolve =&gt; &#123;
            this.resolvers.push(resolve);
        &#125;));
    &#125;
    enqueue(t) &#123;
        // if (this.resolvers.length) this.resolvers.shift()(t);
        // else this.promises.push(Promise.resolve(t));
        if (!this.resolvers.length) this._add();
        this.resolvers.shift()(t);
    &#125;
    dequeue() &#123;
        if (!this.promises.length) this._add();
        return this.promises.shift();
    &#125;
    // now some utilities:
    isEmpty() &#123; // there are no values available
        return !this.promises.length; // this.length == 0
    &#125;
    isBlocked() &#123; // it&#39;s waiting for values
        return !!this.resolvers.length; // this.length &lt; 0
    &#125;
    get length() &#123;
        return this.promises.length - this.resolvers.length;
    &#125;
&#125;

let queue = new AsyncBlockingQueue();
let a = await queue.dequeue(); // 这里会阻塞，直到 queue.enqueue 调用
console.asset(a == &quot;hello, world&quot;);

// 新开启一个线程执行如下
queue.enqueue(&quot;hello, world&quot;);
</code></pre>
</li>
<li><p><a href="https://www.jianshu.com/p/7f0d3785b54a">防抖、节流</a></p>
<pre><code class="javascript">// 防抖：在一定时间内，触发多次事件，只认第一次触发的，到了时间结束执行事件
function throttle(fn, time) &#123;
    let oldTime = 0,
        timer = null;
    return () =&gt; &#123;
        const nowTime = new Date();
        if (nowTime - oldTime &gt;= time) &#123;
            fn();
            oldTime = nowTime;
        &#125;
    &#125;
&#125;

// 节流：在一定时间内，触发多次事件，只认最后一次触发的并且重置时间，到了时间结束执行事件
function debounce(fn, wait, immediate) &#123; // 立即执行，停止触发 n 秒后，才可以重新触发执行
    let timer;
    return function () &#123;
        if (timer) clearTimeout(timer);
        if (immediate) &#123;
            // 如果已经执行过，不再执行
            var callNow = !timer;
            timer = setTimeout(() =&gt; &#123;
                timer = null;
            &#125;, wait);
            if (callNow) &#123;
                fn.apply(this, arguments);
            &#125;
        &#125; else &#123;
            timer = setTimeout(() =&gt; &#123;
                fn.apply(this, arguments);
            &#125;, wait);
        &#125;
    &#125;
&#125;

// containr.addEventListener(&quot;scroll&quot;, debounce(onScroll, 1000), false);
</code></pre>
</li>
<li><p>监听事件</p>
<pre><code class="javascript">(function () &#123;
    window.addEventListener(&quot;click&quot;, function (event) &#123;
        console.info(&quot;The event of click triggered on location (%s, %s) in browser.&quot;, event.clientX, event.clientY);
        console.info(&quot;The event of click triggered on location (%s, %s) in screen.&quot;, event.screenX, event.screenY);
    &#125;);
&#125;)();
</code></pre>
</li>
<li><p><a href="https://blog.csdn.net/jyb123/article/details/86574365">自定义事件</a></p>
<pre><code class="javascript">// 添加一个事件监听器
window.addEventListener(&quot;myEvent&quot;, function(e) &#123;
    console.info(&quot;the data received is&quot;, e.detail);
&#125;);

// var event = new Event(&quot;myEvent&quot;);
// 创建一个支持冒泡且不能被取消的事件
var event = new Event(&quot;myEvent&quot;, &#123;
    &quot;bubbles&quot;: true,
    &quot;cancelable&quot;: false
&#125;);
// 创建一个事件，并传递自定义数据
var event = new CustomEvent(&quot;myEvent&quot;, &#123;
    &quot;detail&quot;: &#123; // 自定义数据需要通过 CustomEvent.detail 属性传递
        &quot;greeting&quot;: &quot;hello, world&quot;
    &#125;
&#125;);

// 分发事件
window.dispatchEvent(event);
</code></pre>
</li>
<li><p>float to IEEE</p>
<pre><code class="javascript">((f) =&gt; &#123;
    var buf = new ArrayBuffer(4);
    (new Float32Array(buf))[0] = f;
    return (new Uint32Array(buf))[0];
&#125;)(0.5); // 1056964608
</code></pre>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays">类型化数组</a><br>  类型化数组是一种类似数组的对象，并提供了一种用于访问原始二进制数据的机制。</p>
<ul>
<li><p>ArrayBuffer</p>
<pre><code class="javascript">// 创建一个 16 字节固定长度的缓冲
var buffer = new ArrayBuffer(16);

// 获取数据的字节长度
console.info(buffer.byteLength); // 16

// 在实际开始操作这个缓冲之前，需要创建一个视图。我们将创建一个视图，此视图将把缓冲内的数据格式化为一个 32 位的有符号整数数组
var int32View = new Int32Array(buffer);

// 现在我们可以像普通数组一样访问该数组中的元素
for (var i = 0; i &lt; int32View.length; i++) &#123;
    int32View[i] = i * 2;
&#125;
// 该代码会将数组以0, 2, 4 和 6填充 （一共4个4字节元素，所以总长度为16字节）
</code></pre>
<blockquote>
<ul>
<li>ArrayBuffer 又称类型化数组，是一个二进制数据的原始缓存区，无法直接读取或者写入（也就是说只能存放 0,1 并且不能直接修改和读取）</li>
<li>数组是放在堆中，ArrayBuffer 数组则把数据放在栈中（所以取数据时后者快）</li>
<li>可以根据需要传递类型化数组或者 DataView 对象来解释原始缓存区</li>
<li>ArrayBuffer 初始化后固定大小，数组则可以自由增减。</li>
</ul>
</blockquote>
</li>
<li><p>数据视图 DataView</p>
</li>
<li><p>Uint8Array</p>
<pre><code class="javascript">// 创建一个 Uint8Array
let uint8array = new Uint8Array([1, -1, 999]);

// Uint8Array 转 Array
Array.from(uint8array); // [1, 255, 231] // 231 = 999 % 256
[].slice.call(uint8array); // [1, 255, 231]
</code></pre>
</li>
</ul>
</li>
<li><p>大额数值数据容量单位转换</p>
<pre><code class="javascript">((bytes) =&gt; &#123;
    if (bytes === 0) return &quot;0 B&quot;;
    let k = 1000, // or 1024
        sizes = [&quot;B&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;, &quot;PB&quot;, &quot;EB&quot;, &quot;ZB&quot;, &quot;YB&quot;],
        i = Math.floor(Math.log(bytes) / Math.log(k));
    return (bytes / Math.pow(k, i)).toPrecision(3) + &quot; &quot; + sizes[i];
&#125;)(8164674); // 8.16 MB
</code></pre>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/97188370">锁</a></p>
<pre><code class="javascript">class Lock &#123;
    constructor() &#123;
        this.locked = null;
    &#125;
    async lock() &#123;
        if (this.locked === null)
            this.locked = [];
        else
            await new Promise(res =&gt; this.locked.push(res));
    &#125;
    unlock() &#123;
        if (this.locked.length)
            this.locked.shift()();
        else
            this.locked = null;
    &#125;
&#125;

(async () =&gt; &#123;
    const a = new Lock();
    await a.lock();
    console.log(&quot;locked&quot;);
    a.unlock();
&#125;)().catch (err =&gt; &#123;
    console.log(err);
&#125;);
</code></pre>
</li>
<li><p>函数柯里化</p>
<pre><code class="javascript">function currying(reg) &#123;
    return function(txt) &#123;
        return reg.test(txt)
    &#125;
&#125;

let hasNumber = currying(/\d+/g);
hasNumber(&quot;test1&quot;); // true
</code></pre>
</li>
<li><p>Web Worker  </p>
<blockquote>
<p>当在 HTML 页面中执行脚本时，页面是不可响应的，直到脚本已完成。Web worker 是运行在后台的 JavaScript，独立于其他脚本（在新的独立的线程中运行），不会影响页面的性能，同时也不能操作 DOM 元素。</p>
</blockquote>
<ol>
<li><p>创建 Web Worker 文件，如 greeting_worker.js</p>
<pre><code class="javascript">setInterval(function() &#123;
    postMessage(&quot;hello, world&quot;); // 向 HTML 页面传回一段消息
&#125;, 5000);
</code></pre>
</li>
<li><p>HTML 页面中调用如下</p>
<pre><code class="javascript">if(typeof(Worker) === &quot;undefined&quot;) &#123;
    console.error(&quot;Sorry! No Web Worker support.&quot;);
&#125;

let worker;
if(typeof(worker) === &quot;undefined&quot;) &#123; // 检测是否存在 worker，如果不存在，创建一个新的 web worker 对象，然后运行 &quot;greeting_worker.js&quot; 中的代码
    worker = new Worker(&quot;demo_workers.js&quot;);
&#125;
worker.onmessage = function(event) &#123; // 当 web worker 传送消息时，会执行事件监听器中的代码。来自 web worker 的数据会存储于 event.data 中
    console.info(&quot;receive message&quot;, event.data);
&#125;;

worker.terminate(); // 终止 web worker，并释放浏览器/计算机资源
worker = undefined; // 把 worker 变量设置为 undefined，在其被终止后，可以重复使用该代码
</code></pre>
</li>
</ol>
</li>
<li><p>Service Worker</p>
<blockquote>
<p>Service Worker 基于 Web Worker，是运行在浏览器后台的 JS 程序，可以操控浏览器端的存储、网络请求、消息推送等。</p>
</blockquote>
<ol>
<li><p>创建 Service Worker 文件，如 service_worker.js</p>
<pre><code class="javascript">// 监听安装事件，install 事件一般是被用来设置你的浏览器的离线缓存逻辑
this.addEventListener(&quot;install&quot;, function (event) &#123;
    // 通过这个方法可以防止缓存未完成，就关闭 Service Worker
    event.waitUntil(
        // 创建一个名叫 v1 的缓存版本
        caches.open(&quot;v1&quot;).then(function (cache) &#123;
            // 指定要缓存的内容，地址为相对于跟域名的访问路径
            return cache.addAll([
                &quot;./index.html&quot;
            ]);
        &#125;)
    );
&#125;);

// 注册 fetch 事件，拦截全站的请求
this.addEventListener(&quot;fetch&quot;, function(event) &#123;
     event.respondWith(
         // 在缓存中匹配对应请求资源直接返回
         caches.match(event.request)
     );
&#125;);
</code></pre>
</li>
<li><p>在 HTML 页面中注册 Service Worker 如下</p>
<pre><code class="javascript">// 判断当前浏览器是否支持 Service Worker
if (&quot;serviceWorker&quot; in navigator) &#123;
    // 当页面加载完成就创建一个 Service Worker
    window.addEventListener(&quot;load&quot;, function () &#123;
        // 创建并指定对应的执行内容
        navigator.serviceWorker.register(&quot;./service_worker.js&quot;, &#123;
            scope: &quot;./&quot; // 可选，可以用来指定 service worker 控制的内容的子目录。在这个例子里，我们指定了 &quot;/&quot;，表示根网域下的所有内容，这也是默认值。
        &#125;)
            .then(function (registration) &#123;
                console.log(&quot;Service Worker registration successful with scope: &quot;, registration.scope);
            &#125;)
            .catch(function (err) &#123;
                console.log(&quot;Service Worker registration failed: &quot;, err);
            &#125;);
    &#125;);
&#125;
</code></pre>
</li>
</ol>
</li>
<li><p>Shared Worker</p>
</li>
<li><p>重试机制 retry</p>
<pre><code class="javascript">const retry = (fn, times = [1000, 1500]) =&gt; &#123;
    return new Promise(async (resolve, reject) =&gt; &#123;
        let n = 0, s = false;
        while (true) &#123;
            switch (n) &#123;
                case 0:
                    await fn(r =&gt; &#123;
                        s = true;
                        resolve();
                    &#125;, reject);
                    n = s == true ? 2 : 1;
                    break;
                case 1:
                    let t = times.shift();
                    if (t) &#123;
                        await new Promise(r =&gt; setTimeout(r, t));
                        i = 0;
                    &#125; else &#123;
                        i = 2;
                    &#125;
                    break;
                case 2:
                    return;
            &#125;
        &#125;
    &#125;);
&#125;
retry(async (resolve, reject) =&gt; &#123;
    await fetch(&quot;/&quot;).then(r =&gt; &#123;
        resolve(r);
    &#125;).catch(e =&gt; &#123;
        reject(e);
    &#125;);
&#125;);
</code></pre>
</li>
<li><p>延迟队列 DelayQueue</p>
</li>
<li><p>js 函数转代码字符串</p>
<pre><code class="javascript">let func = n =&gt; `hello, $&#123;n || &quot;world&quot;&#125;`;
func.toString() // &#39;n =&gt; `hello, $&#123;n || &quot;world&quot;&#125;`&#39;
</code></pre>
</li>
</ul>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a><a href="https://www.sitepoint.com/client-side-storage-options-comparison/">存储</a></h2><ul>
<li><p>DOM 节点（读写快，但页面刷新会丢失）</p>
<blockquote>
<p>通过以 “data-“ 为前缀的数据集属性存储和读取，对象类型需要序列化为字符串存储。</p>
</blockquote>
<pre><code class="javascript">const main = document.querySelector(&quot;main&quot;);

// 赋值
main.dataset.name = &quot;zhangsan&quot;;
main.dataset.user = JSON.stringify(&#123; name: &quot;zhangsan&quot; &#125;);

// 取值
console.info(JSON.parse(main.dataset.user).name);
</code></pre>
</li>
<li><p>Local Storage 和 Session Storage（每个域名下只有 5 MB 空间，值需要序列化为字符串类型）</p>
<pre><code class="javascript">// localStorage 用于持久化的本地存储，存储资料在客户端（client）的浏览器上，除非主动删除数据，否则数 据是永远不会过期的。
localStorage.setItem(&quot;name&quot;, &quot;zhangsan&quot;);
localStorage.getItem(&quot;name&quot;);
localStorage.removeItem(&quot;name&quot;);

// sessionStorage 用于本地存储一个会话中的数据，这些数据只有在同一个会话中的页面才能访问并且会话结束，例如关闭窗口后，数据也会随之被销毁。它是一种会话级别的存储。
sessionStorage.setItem(&quot;name&quot;, &quot;zhangsan&quot;);
sessionStorage.getItem(&quot;name&quot;);
</code></pre>
</li>
<li><p>IndexedDB（索引数据库）（取决于设备，最少 1 GB 空间，最多剩余磁盘空间的 60%，读写快）</p>
<pre><code class="javascript">(async () =&gt; &#123;
    const db = await new Promise((resolve, reject) =&gt; &#123;
        const request = indexedDB.open(&quot;myDB&quot;, 1.0);
        request.onsuccess = e =&gt; &#123;
            resolve(e.target.result);
        &#125;;
        request.onerror = e =&gt; &#123;
            console.error(`indexedDB error: $&#123; e.target.errorCode &#125;`);
        &#125;;
        request.onupgradeneeded = e =&gt; &#123;
            const store = e.target.result.createObjectStore(&quot;todo&quot;, &#123; keyPath: &quot;id&quot;, autoIncrement: true &#125;);
        &#125;;
    &#125;);

    db.transaction([&quot;todo&quot;], &quot;readwrite&quot;)
        .objectStore(&quot;todo&quot;)
        .add(&#123; task: &quot;do something&quot; &#125;)
        .onsuccess = () =&gt; console.log(&quot;added&quot;);

    db.transaction([&quot;todo&quot;], &quot;readonly&quot;)
        .objectStore(&quot;todo&quot;)
        .get(1)
        .onsuccess = data =&gt; console.log(data.target.result);
    // &#123; id: 1, task: &quot;do something&quot; &#125;
&#125;)();
</code></pre>
</li>
<li><p>Cache API（适用于缓存网络请求如网页等）</p>
<pre><code class="javascript">(async () =&gt; &#123;
    const cache = await caches.open(&quot;myCache&quot;);

    // 请求并保存
    await cache.add(&quot;/greeting&quot;);
    await cache.add(new Request(&quot;/greeting&quot;, &#123;
        method: &quot;GET&quot;,
        headers: new Headers(&#123;
            &quot;Content-Type&quot;: &quot;application/json&quot;
        &#125;)
    &#125;));

    // 查询
    console.info(&quot;the cache response context is&quot;, await (await caches.match(&quot;/greeting&quot;))).text());
    
    // 请求并更新
    const response = await fetch(&quot;/greeting&quot;);
    await cache.put(&quot;/greeting&quot;, response);
    
    // 删除
    await cache.delete(&quot;/greeting&quot;);

    await cache.delete(&quot;myCache&quot;);
&#125;)();
</code></pre>
</li>
<li><p>文件系统访问 API</p>
<pre><code class="javascript">// 使用 `try...catch` 可以捕获用户取消选择时抛出的错误，如果你对错误不在意，不捕获也行
try &#123;
    const [handle] = await showOpenFilePicker(&#123;
        multiple: false, // 只选择一个文件
        types: [
           &#123;
               description: &quot;Navlang Files&quot;,
               accept: &#123;
                  &quot;text/x-navlang&quot;: &quot;.nav&quot;
               &#125;
           &#125;
        ],
        excludeAcceptAllOption: true
    &#125;);
&#125; catch (e) &#123;
    if (e.message.indexOf(&quot;The user aborted a request&quot;) === -1) &#123;
        console.error(e);
        return;
    &#125;
&#125;

// 如果没有选择文件，就不需要继续执行了
if (!handle) &#123;
    return;
&#125;

// 这里的 options 用来声明对文件的权限，能否写入
const options = &#123;
    writable: true,
    mode: &quot;readwrite&quot;
&#125;;
// 然后向用户要求权限
if ((await handle.queryPermission(options)) !== &quot;granted&quot; &amp;&amp; (await handle.requestPermission(options)) !== &quot;granted&quot;) &#123;
    alert(&quot;Please grant permissions to read &amp; write this file.&quot;);
    return;
&#125;

// 前面获取的是 FileHandle，需要转换 File 才能用
const file = await handle.getFile();
// 接下来，`file` 就是普通 File 实例，你想怎么处理都可以，比如，获取文本内容
const code = await file.text();
</code></pre>
<pre><code class="javascript">async function save(blob) &#123;
    // create handle to a local file chosen by the user
    const handle = await window.showSaveFilePicker();

    // create writable stream
    const stream = await handle.createWritable();

    // write the data
    await stream.write(blob);

    // save and close the file
    await stream.close();
&#125;
</code></pre>
</li>
<li><p>Web SQL（每个域名下 5 MB 空间，读写速度慢）</p>
<blockquote>
<p>Chrome 浏览器数据库（SQLite）位置 “C:\Users%username%\AppData\Local\Google\Chrome\User Data\Default\databases\Databases.db”</p>
</blockquote>
<pre><code class="javascript">var db = openDatabase(&quot;MyData&quot;, &quot;&quot;, &quot;My Database&quot;, 102400);

// 创建一个数据库表，里面有 3 个字段 
db.transaction(function(tx)&#123; 
    tx.executeSql(&quot;CREATE TABLE IF NOT EXISTS InfoData(name TEXT, info TEXT, time INTEGER)&quot;, []); 
&#125;

// 显示所有
db.transaction(function(tx) &#123;      
    // 然后定义了一个回调函数，表明对于结果集的处理 
    tx.executeSql(&quot;SELECT * FROM InfoData&quot;, [], function(tx, rs) &#123; 
        // 遍历结果集，对于每一行，依次调用 showData 来在 table 上创建对于的 html 文本 
        for(var i = 0; i &lt; rs.rows.length; i++)&#123; 
            // 对于 item(i)，也就是某一行记录，我们显示其内容到页面的表格中（构建对应的 HTML 片断） 
            alert(rs.rows.item(i)); 
        &#125; 
    &#125;); 
&#125; 

// 增加数据
db.transaction(function(tx) &#123;      
    // 插入的语句是个模板语句 
    // 插入成功的回调就是在控制台上输入一行日志 
    tx.executeSql(&quot;INSERT INTO InfoData VALUES(?, ?, ?)&quot;, [name, info, time], function(tx, rs) &#123; 
        console.log(&quot;成功保存数据!&quot;); 
    &#125;, 
    // 插入失败的回调就是在控制台上输入一行错误日志 
    function(tx, error) &#123; 
        console.log(error.source + &quot;::&quot; + error.message); 
    &#125;); 
&#125;
</code></pre>
</li>
<li><p>Cookie（每个域名下 80 KB 空间，不同浏览器对每个域名下 Cookie 有个数限制，不应超过 20 个，每个不超过 4 KB）</p>
<pre><code class="javascript">document.cookie = `user=$&#123;encodeURIComponent(JSON.stringify(&#123; name: &quot;zhangsan&quot; &#125;))&#125;`;

document.cookie = &quot;username=zhangsan; expires=Session; domain=.example.com; path=/; secure=true; priority=High;&quot;;
</code></pre>
</li>
<li><p>window.name</p>
<pre><code class="javascript">window.name = JSON.stringify(&#123; name: &quot;zhangsan&quot; &#125;);

console.info(JSON.parse(window.name).name);
</code></pre>
</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li><p>XMLHTTPRequest</p>
<pre><code class="javascript">var xmlhttp = null;
//create xml http request
if (window.XMLHttpRequest) &#123;
    // for all new browsers
    xmlhttp = new XMLHttpRequest();
&#125; else if (window.ActiveXObject) &#123;
    // for IE5 and IE6
    xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
&#125;
//send xml http request
if (xmlhttp != null) &#123;
    xmlhttp.onreadystatechange = function()&#123;
        if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200) &#123;
            // 4 = &quot;loaded&quot;
            // 200 = OK
            console.info(&quot;response text: &quot; + xmlhttp.responseText);
        &#125;
    &#125;;
    xmlhttp.open(&quot;GET&quot;, url, true);
    xmlhttp.send(null);
&#125; else &#123;
    console.error(&quot;current browser does not support XMLHTTP.&quot;);
&#125;
</code></pre>
</li>
<li><p>fetch</p>
<pre><code class="javascript">fetch(&quot;https://127.0.0.1/greeting&quot;, &#123;
    method: &quot;post&quot;,
    headers: &#123;
        &quot;Content-Type&quot;: &quot;application/json&quot;
    &#125;,
    body: JSON.stringify(&#123;
        name: &quot;zhangsan&quot;
    &#125;)
&#125;)
.then(response =&gt; response.json())
.then(data =&gt; &#123;
    console.info(&quot;response is&quot;, data);
&#125;)
.catch(error =&gt; console.log(&quot;error is&quot;, error));
</code></pre>
<pre><code class="javascript">await fetch(&quot;https://www.baidu.com&quot;).then(re =&gt; re.text());
await fetch(&quot;http://127.0.0.1/greeting&quot;, &#123; method: &quot;post&quot;, headers: &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;, body: JSON.stringify(&#123; name: &quot;zhangsan&quot; &#125;)&#125;).then(re =&gt; re.json());
</code></pre>
<pre><code class="javascript">fetch(&quot;http://127.0.0.1/greeting&quot;, &#123;
    method: &quot;post&quot;,
    headers: &#123;
        &quot;Content-Type&quot;: &quot;application/json&quot;
    &#125;,
    body: JSON.stringify(&#123; name: &quot;zhangsan&quot; &#125;)
&#125;)
.then(re =&gt; &#123;
    if (re.ok) &#123;
        return re.json();
    &#125;
    throw new Error(&quot;Request reject with status &quot; + re.status);
&#125;)
.then(data =&gt; &#123;
    console.info(&quot;response is&quot;, data);
&#125;);
</code></pre>
</li>
<li><p><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket</a></p>
<pre><code class="javascript">var ws = new WebSocket(&quot;wss://echo.websocket.org&quot;);

ws.onopen = function(evt) &#123; 
    console.log(&quot;Connection opened.&quot;); 
    ws.send(&quot;hello, world&quot;);
&#125;;

ws.onmessage = function(evt) &#123;
    console.log(&quot;Received message:&quot;, evt.data);
    ws.close();
&#125;;

ws.onclose = function(evt) &#123;
    // evt.code // 错误码，number 类型
    // evt.reason // 断开原因，string 类型
    // evt.wasClean // 是否正常断开，boolean 类型
    console.log(&quot;Connection closed.&quot;);
&#125;;
</code></pre>
</li>
<li><p><a href="https://www.jianshu.com/p/622a3549728a">EventSource 服务端推送事件</a></p>
<pre><code class="javascript">var es = new EventSource(&quot;/event/source&quot;);

// 收到服务器发生的事件时触发
evtSource.onmessage = function (e) &#123;
    console.log(e.data);
&#125;
// 成功与服务器发生连接时触发
es.onopen = function () &#123;
    console.log(&quot;Server open&quot;)
&#125; 
// 出现错误时触发
es.onerror = function () &#123;
    console.log(&quot;Error&quot;)
&#125;

// 自定义事件
es.addEventListener(&quot;myEvent&quot;, function (e) &#123;
    console.log(e.data);
&#125;, false);
</code></pre>
<p>  nodejs 服务器端实现</p>
<blockquote>
<ul>
<li>需设置响应消息头 “Content-Type” 设置为 “text/event-stream”</li>
<li>报文格式为 “字段:…”，每个事件之间通过空行来分隔<ul>
<li>字段为空白，表示该行是注释，会在处理时被忽略</li>
<li>event: 表示该行用来声明事件的类型。浏览器在收到数据时，会产生对应类型的事件</li>
<li>data: 消息的数据字段。如果该条消息包含多个 data 字段，则客户端会用换行符把它们连接成一个字符串来作为字段值</li>
<li>id: 事件 ID，会成为当前 EventSource 对象的内部属性”最后一个事件 ID”的属性值</li>
<li>retry: 一个整数值，指定了重新连接的时间(单位为毫秒)，如果该字段值不是整数，则会被忽略。默认浏览器每隔 3 秒断线重连</li>
</ul>
</li>
</ul>
</blockquote>
<pre><code class="javascript">var http = require(&quot;http&quot;);
var fs = require(&quot;fs&quot;);

http.createServer(function (req, res) &#123;
    if(req.url === &quot;/sendMessage&quot;) &#123;
        res.writeHead(200, &#123;
            &quot;Content-Type&quot;: &quot;text/event-stream&quot; //设置头信息
        &#125;);

        setInterval(function () &#123;
            res.write(
                // 事件一
                &quot;data:&quot; + new Date().toLocaleTimeString() + &quot;\n\n&quot; + //必须 &quot;\n\n&quot; 结尾
                // 事件二
                &quot;: &#39;这是注释！&#39;&quot; + &quot;\n&quot; +
                &quot;event: myEvent&quot; + &quot;\n&quot; + 
                &quot;data:&quot; + new Date().toLocaleString() + &quot;\n\n&quot;
            );
        &#125;, 1000);
    &#125; else &#123;
        fs.readFile(&quot;./index.html&quot;, function (err, content) &#123;
            res.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html&quot;&#125;);
            res.end(content, &quot;utf-8&quot;);
        &#125;);
    &#125;
&#125;).listen(3000);
</code></pre>
</li>
<li><p>WebRTC</p>
</li>
</ul>
<h2 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h2><h3 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h3><pre><code class="javascript">// http://www.youdict.com/root/root.php
$(&quot;table a[target=&#39;_blank&#39;]&quot;).each((index, obj) =&gt; &#123;
    console.info(obj.innerHTML.replace(/,/g, &quot;&quot;));
&#125;);

var arr = new Array(0);
$(&quot;table a[target=&#39;_blank&#39;]&quot;).each((index, obj) =&gt; &#123;
    // arr = arr.concat(obj.innerHTML.replace(/,/g, &quot;&quot;).split(&quot; &quot;));
    arr = arr.concat(obj.innerHTML.replace(/[^a-z]+/g, &quot;&quot;).split(&quot; &quot;));
&#125;);
var set = new Set(arr); // ES6 中支持
arr = Array.from(set); // 去重
console.info(arr);
// document.body.innerHTML = arr.join(&quot; &quot;);

Array.prototype.remove = function(val) &#123; // 定义数组的 remove 拓展方法
    var index = this.indexOf(val);
    if (index &gt; -1) &#123;
        this.splice(index, 1);
    &#125;
&#125;;
for (var i of arr) &#123;
    if (i.length &gt; 4 || i.length &lt; 2) &#123;
        arr.remove(i);
    &#125;
&#125;
</code></pre>
<pre><code class="javascript">$.get(url, data, success(response, status, xhr), dataType);

$.post(url, data, success(data, textStatus, jqXHR), dataType);

$.ajax(&#123;
    type: &quot;POST&quot;,
    url: url,
    data: data,
    success: success,
    dataType: dataType
&#125;);
</code></pre>
<h3 id="使用-vConsole-调试移动端-web"><a href="#使用-vConsole-调试移动端-web" class="headerlink" title="使用 vConsole 调试移动端 web"></a>使用 vConsole 调试移动端 web</h3><pre><code class="html">&lt;!-- 页面中嵌入以下代码，则页面底部会生成 console 框工具 --&gt;
&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/vConsole/3.3.4/vconsole.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;var vConsole = new VConsole();&lt;/script&gt;
</code></pre>
<h3 id="lunr-js"><a href="#lunr-js" class="headerlink" title="lunr.js"></a><a href="https://github.com/olivernn/lunr.js/">lunr.js</a></h3><pre><code class="javascript">var idx = lunr(function () &#123;
    this.field(&quot;title&quot;)
    this.field(&quot;body&quot;)

    this.add(&#123;
        &quot;title&quot;: &quot;Twelfth-Night&quot;,
        &quot;body&quot;: &quot;If music be the food of love, play on: Give me excess of it…&quot;,
        &quot;author&quot;: &quot;William Shakespeare&quot;,
        &quot;id&quot;: &quot;1&quot;
    &#125;)
&#125;);

idx.search(&quot;love&quot;);

// idx2 = lunr.Index.load(idx.toJSON());
idx2 = lunr.Index.load(JSON.parse(JSON.stringify(idx)));

idx2.search(&quot;love&quot;);
</code></pre>
<h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><ul>
<li><p><a href="https://www.jianshu.com/p/f56cde007210?utm_source=oschina-app">v-clock</a><br>  当网络较慢，网页还在加载 Vue.js ，而导致 Vue 来不及渲染，这时页面就会显示出 Vue 源代码。我们可以使用 v-cloak 指令来解决这一问题</p>
</li>
<li><p>外联引用 vant: <van-cell-group> 组件渲染出错<br>  应使用闭合标签的这种写法如 <van-cell></van-cell>。参考 <a href="https://github.com/youzan/vant/issues/800">https://github.com/youzan/vant/issues/800</a></p>
</li>
</ul>
<h3 id="socket-io"><a href="#socket-io" class="headerlink" title="socket.io"></a><a href="https://socket.io/get-started">socket.io</a></h3><ul>
<li><p>websocket 服务端</p>
<ol>
<li><p>安装</p>
<pre><code class="bash"># npm install express@4
npm install socket.io
</code></pre>
</li>
<li><p>创建 server.js 如下</p>
<pre><code class="javascript">// const express = require(&quot;express&quot;);
// const app = express();

const http = require(&quot;http&quot;);
const server = http.createServer(
//     app
);

const io = require(&quot;socket.io&quot;)(server);

// app.get(&quot;/&quot;, (req, res) =&gt; &#123;
//     res.sendFile(__dirname + &quot;/index.html&quot;);
// &#125;);

io.on(&quot;connection&quot;, (socket) =&gt; &#123; // 当有客户端连接时触发
    console.log(&quot;a user connected&quot;);

    socket.on(&quot;chat message&quot;, (msg) =&gt; &#123; // 接受客户端 &quot;chat message&quot; 事件
        console.log(&quot;message: &quot; + msg);
    &#125;);

    socket.on(&quot;disconnect&quot;, () =&gt; &#123; // 当有客户端断开连接时触发
        console.log(&quot;user disconnected&quot;);
    &#125;);
&#125;);

server.listen(3000, () =&gt; &#123;
    console.log(&quot;listening on *:3000&quot;);
&#125;);

setInterval(() =&gt; &#123;
    // 向所有连接广播发送 &quot;some event&quot; 事件，并传递对象参数
    io.emit(&quot;some event&quot;, &#123;
        greeting: &quot;hello, all clients&quot;
    &#125;);
&#125;, 5000); // 定时器，每 5 秒执行一次
</code></pre>
</li>
<li><p>运行</p>
<pre><code class="bash">node server.js
</code></pre>
</li>
</ol>
</li>
<li><p>websocket 客户端</p>
<pre><code class="html">&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/socket.io/3.1.3/socket.io.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        // var socket = io(&quot;http://127.0.0.1:3000/&quot;);
        var socket = io();

        socket.emit(&quot;chat message&quot;, &quot;hello, server&quot;);

        socket.on(&quot;some event&quot;, (msg) =&gt; &#123;
            console.log(&quot;message: &quot; + msg);
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ul>
<h3 id="js-sha256"><a href="#js-sha256" class="headerlink" title="js-sha256"></a><a href="https://github.com/emn178/js-sha256">js-sha256</a></h3><ol>
<li>引入<pre><code class="html">https://cdn.bootcdn.net/ajax/libs/js-sha256/0.9.0/sha256.min.js
</code></pre>
</li>
<li>语法<pre><code class="javascript">sha256(&quot;The quick brown fox jumps over the lazy dog&quot;); // d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592
</code></pre>
</li>
</ol>
<h3 id="jsencrypt"><a href="#jsencrypt" class="headerlink" title="jsencrypt"></a>jsencrypt</h3><ol>
<li><p>引入 jsencrypt</p>
<pre><code class="html">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/jsencrypt/3.1.0/jsencrypt.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li><p>语法</p>
<pre><code class="javascript">let PUBLIC_KEY = &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC8HMr2CBpoZPm3t9tCVlrKtTmI4jNJc7/HhxjIEiDjC8czP4PV+44LjXvLYcSV0fwi6nE4LH2c5PBPEnPfqp0g8TZeX+bYGvd70cXee9d8wHgBqi4k0J0X33c0ZnW7JruftPyvJo9OelYSofBXQTcwI+3uIl/YvrgQRv6A5mW01QIDAQAB&quot;, // 公钥
    PRIVATE_KEY = &quot;MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALwcyvYIGmhk+be320JWWsq1OYjiM0lzv8eHGMgSIOMLxzM/g9X7jguNe8thxJXR/CLqcTgsfZzk8E8Sc9+qnSDxNl5f5tga93vRxd5713zAeAGqLiTQnRffdzRmdbsmu5+0/K8mj056VhKh8FdBNzAj7e4iX9i+uBBG/oDmZbTVAgMBAAECgYEAmgNU5NTDkj9B+Pnt6UU8doSjw3+3j+bV2K2yS3QUOvAUus/Ax7x6ktjWxzCXvDY9IfUil2RNv9vtKEAqYLCWjc+lf8PV/yH1b7NEgyeAPBXtAJRoOnmYL2bdPW92kP9KgxJruF6Dz/C5AmMOncsvq8ABD+9Darn4p8dwj2ZC4O0CQQDf/AHmZsQokEItfCy4mHS9UbxbfIhEUv1ApPh/+Sr7NkJkHWYCtBQo+8jKO6zurAZQgWBPD1XX2UE4R+VIiZazAkEA1wAqtMvGhccyRZr+6kpkpDIa8+9jOE+nGUzqTDvgCID6as8AzOONFVVK6m/UUqkhcJ8Qu1pF36BGojy5BX2KVwJBAJSFpbji0hXXupowqfLp3RcgmNbNWAp+QUJZYhJx5cdYbmO2fssyH+AhPT6knYJR/YnqkDM8hv6vKCkqu2YDHjMCQAOA8TE5EOclM+CGghj3VWSHnIDVKdzFD4gOBNNxNlltIKeU8AJmwunSFgJ0CBXAw9a+ANvMwM7AIeaK7sj0HskCQAvxfDCq7gaNx+pfu0FHG8Gix08A/A6foggBl1fVu+L9sr9ZuOQ3HbXnl28F9ewuB9xdjnLUDjp7W7U0pB+vKoQ=&quot;, // 私钥

// 使用公钥加密
let encrypt = new JSEncrypt();
encrypt.setPublicKey(&quot;-----BEGIN PUBLIC KEY-----&quot; + PUBLIC_KEY + &quot;-----END PUBLIC KEY-----&quot;);
let encrypted = encrypt.encrypt(&quot;hello, world&quot;);
console.log(&quot;加密后数据&quot;, encrypted);

// 使用私钥解密
let decrypt = new JSEncrypt();
decrypt.setPrivateKey(&quot;-----BEGIN RSA PRIVATE KEY-----&quot; + PRIVATE_KEY + &quot;-----END RSA PRIVATE KEY-----&quot;);
let decrypted = decrypt.decrypt(encrypted);
console.log(&quot;解密后数据&quot;, decrypted);

console.assert(&quot;hello, world&quot; === decrypted);
</code></pre>
</li>
</ol>
<h3 id="multiavatar"><a href="#multiavatar" class="headerlink" title="multiavatar"></a><a href="https://github.com/multiavatar/Multiavatar">multiavatar</a></h3><ol>
<li>引入<pre><code class="html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/@multiavatar/multiavatar/multiavatar.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li>语法<pre><code class="javascript">multiavatar(&quot;meter&quot;) // &quot;&lt;svg ...&lt;/svg&gt;&quot;
</code></pre>
<pre><code class="javascript">let image = new Image();
image.src = &quot;data:image/svg+xml,&quot; + multiavatar(&quot;Binx Bond&quot;);
</code></pre>
<blockquote>
<p>好看的头像：”appinn”、”meter”</p>
</blockquote>
</li>
</ol>
<h3 id="tensorflow-js"><a href="#tensorflow-js" class="headerlink" title="tensorflow.js"></a>tensorflow.js</h3><h3 id="使用-mark-js-标注网页内容（关键词前后包裹-mark-标签，如-“hello“）"><a href="#使用-mark-js-标注网页内容（关键词前后包裹-mark-标签，如-“hello“）" class="headerlink" title="使用 mark.js 标注网页内容（关键词前后包裹 mark 标签，如 “hello“）"></a>使用 mark.js 标注网页内容（关键词前后包裹 mark 标签，如 “<mark>hello</mark>“）</h3><ol>
<li>引入<pre><code class="html">&lt;script src=&quot;https://cdn.jsdelivr.net/mark.js/latest/&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li>语法<pre><code class="javascript">new Mark(document.body).mark(&quot;hello&quot;);
</code></pre>
</li>
</ol>
<h3 id="qrcodejs"><a href="#qrcodejs" class="headerlink" title="qrcodejs"></a><a href="https://github.com/davidshimjs/qrcodejs">qrcodejs</a></h3><ol>
<li><p>引入</p>
</li>
<li><p>语法</p>
<pre><code class="javascript">var div = document.createElement(&quot;div&quot;);
document.body.appendChild(div);

new QRCode(div, &quot;hello, world&quot;);
</code></pre>
</li>
</ol>
<h3 id="Monaco-Editor"><a href="#Monaco-Editor" class="headerlink" title="Monaco Editor"></a><a href="https://github.com/microsoft/monaco-editor">Monaco Editor</a></h3><ol>
<li><p>示例</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&gt;&lt;!-- 网页的宽度自动适应手机屏幕的宽度 --&gt;
    &lt;title&gt;Cube&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; data-name=&quot;vs/editor/editor.main&quot; href=&quot;https://cdn.bootcdn.net/ajax/libs/monaco-editor/0.31.0/min/vs/editor/editor.main.css&quot;&gt;
    &lt;style&gt;
        * &#123;
            margin: 0;
            padding: 0;
        &#125;

        html,
        body &#123;
            width: 100%;
            height: 100%;
        &#125;

        html &#123;
            overflow: hidden;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id=&quot;container&quot; style=&quot;width: 100%; height: 100%;&quot;&gt;&lt;/div&gt;

    &lt;script&gt;var require = &#123; paths: &#123; &quot;vs&quot;: &quot;https://cdn.bootcdn.net/ajax/libs/monaco-editor/0.31.0/min/vs&quot; &#125; &#125;;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/monaco-editor/0.31.0/min/vs/loader.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/monaco-editor/0.31.0/min/vs/editor/editor.main.nls.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/monaco-editor/0.31.0/min/vs/editor/editor.main.js&quot;&gt;&lt;/script&gt;

    &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/typescript/4.5.4/typescript.min.js&quot;&gt;&lt;/script&gt;

    &lt;script&gt;
        (function () &#123;
            // compiler options
            monaco.languages.typescript.typescriptDefaults.setCompilerOptions(&#123;
                target: monaco.languages.typescript.ScriptTarget.ES2016,
                allowNonTsExtensions: true,
                moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
                module: monaco.languages.typescript.ModuleKind.CommonJS,
                noEmit: true,
                // noLib: true,
                experimentalDecorators: true,
                typeRoots: [&quot;node_modules/@types&quot;]
            &#125;);

            // diagnostics options
            // monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions(&#123;
            //     noSemanticValidation: false, // 关闭语义校验，默认为 false
            //     noSyntaxValidation: false // 关闭语法校验，默认为 false
            // &#125;);

            // extra libraries
            monaco.languages.typescript.typescriptDefaults.addExtraLib(`/*\n * Post method\n */\ndeclare function Post(path: string): Function;`);
            monaco.languages.typescript.typescriptDefaults.addExtraLib(`export let user = &#123; name: &quot;zhangsan&quot; &#125;;`, &quot;node_modules/@types/user/index.d.ts&quot;);

            let editor = monaco.editor.create(document.getElementById(&quot;container&quot;), &#123;
                language: &quot;typescript&quot;,
                theme: &quot;vs-dark&quot;,
                value: &quot;// code here&quot;,
                model: monaco.editor.createModel(&quot;&quot;, &quot;typescript&quot;, new monaco.Uri(&quot;main.tsx&quot;)),
                options: &#123;
                    selectOnLineNumbers: true,
                    roundedSelection: false,
                    readOnly: false,
                    cursorStyle: &quot;line&quot;,
                    automaticLayout: true
                &#125;
            &#125;);
            
            editor.setValue(`import &#123; user &#125; from &quot;user&quot;;\n\nclass Greeting &#123;\n\t@Post(&quot;/greeting&quot;)\n\tpublic greeting(name: string = &quot;world&quot;): string &#123;\n\t\treturn \`hello, \$&#123;user?.name ?? name&#125;\`;\n\t&#125;\n&#125;`);

            document.onkeydown = function (e) &#123;
                let keyCode = e.keyCode || e.which || e.charCode,
                    ctrlKey = e.ctrlKey || e.metaKey;
                if (ctrlKey &amp;&amp; keyCode == 82) &#123; // Ctrl + R
                    let tsSrc = editor.getValue(),
                        jsSrc = ts.transpileModule(tsSrc, &#123;
                        compilerOptions: &#123; module: ts.ModuleKind.CommonJS &#125;
                    &#125;)?.outputText;

                    var fd = window.open(&quot;about:blank&quot;, &quot;&quot;, &quot;width=600,height=450&quot;);
                    setTimeout(() =&gt; &#123;
                        fd.document.open()
                        fd.document.write(`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script&gt;console.info=function(message, ...optionalParams)&#123;document.write(message + &quot;&lt;br/&gt;&quot;);&#125;&lt;\/script&gt;&lt;script&gt;$&#123;jsSrc&#125;&lt;\/script&gt;&lt;\/body&gt;&lt;\/html&gt;`);
                        fd.document.close();
                    &#125;, 50);

                    e.preventDefault();
                    return false;
                &#125;
            &#125;
        &#125;)();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li><p>代码提示</p>
<pre><code class="javascript">monaco.languages.registerCompletionItemProvider(&quot;sql&quot;, &#123;
    provideCompletionItems: function (model, position) &#123;
        // 获取提示符 sym
        const line = position.lineNumber, // 获取当前行数
            column = position.column, // 获取当前列数
            content = model.getLineContent(line); // 获取当前输入行的所有内容
        const sym = content[column - 2]; // 通过下标来获取当前光标后一个内容，即为刚输入的内容
        let textUntilPosition = model.getValueInRange(&#123;
            startLineNumber: 1,
            startColumn: 1,
            endLineNumber: position.lineNumber,
            endColumn: position.column
        &#125;);
        let word = model.getWordUntilPosition(position);
        let range = &#123;
            startLineNumber: position.lineNumber,
            endLineNumber: position.lineNumber,
            startColumn: word.startColumn,
            endColumn: word.endColumn
        &#125;;

        let suggestions = [];
        if (sym === &quot;$&quot;) &#123;
            // ...
            // 拦截到用户输入 $，开始设置提示内容，同 else 中代码一致，自行拓展
        &#125; else &#123;
            // 直接提示，以下为 sql 语句关键词提示
            let sqlStr = [&quot;SELECT&quot;, &quot;FROM&quot;, &quot;WHERE&quot;, &quot;AND&quot;, &quot;OR&quot;, &quot;LIMIT&quot;, &quot;ORDER BY&quot;, &quot;GROUP BY&quot;, &quot;LEFT&quot;, &quot;ON&quot;, &quot;if()&#123;&#125;&quot;, &quot;for()&#123;&#125;&quot;, &quot;size&quot;, &quot;get()&quot;, &quot;substring&quot;, &quot;return&quot;];
            for (let i in sqlStr) &#123;
                suggestions.push(&#123;
                    label: sqlStr[i], // 显示的提示内容
                    kind: monaco.languages.CompletionItemKind[&quot;Function&quot;], // 用来显示提示内容后的不同的图标
                    insertText: sqlStr[i], // 选择后粘贴到编辑器中的文字
                    detail: &quot;&quot;, // 提示内容后的说明
                    range: range
                &#125;);
            &#125;
        &#125;
        return &#123;
            suggestions: suggestions
        &#125;;
    &#125;,
    triggerCharacters: [&quot;$&quot;, &quot;&quot;]
&#125;);
</code></pre>
</li>
</ol>
<h3 id="使用-Mock-js-生成随机数据，拦截-ajax-请求"><a href="#使用-Mock-js-生成随机数据，拦截-ajax-请求" class="headerlink" title="使用 Mock.js 生成随机数据，拦截 ajax 请求"></a>使用 <a href="http://mockjs.com/examples.html">Mock.js</a> 生成随机数据，拦截 ajax 请求</h3><ol>
<li><p>引入 mockjs</p>
<pre><code class="html">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/Mock.js/1.0.0/mock-min.js&quot;&gt;&lt;/script&gt;
</code></pre>
</li>
<li><p>语法</p>
<pre><code class="javascript">Mock.mock(&quot;@paragraph&quot;);
Mock.mock(&quot;@sentence&quot;);

Mock.mock(&#123;
    &quot;users|20-30&quot;: [&#123;
        &quot;id|+1&quot;: 1,
        &quot;name&quot;: &quot;@name&quot;,
        &quot;cname&quot;: &quot;@cname&quot;,
        &quot;gender&quot;: &quot;@pick([&#39;male&#39;, &#39;female&#39;])&quot;,
        &quot;birth&quot;: &quot;@date(&#39;yyyy-MM-dd&#39;)&quot;,
        &quot;telephone&quot;: /^1[385][1-9]\d&#123;8&#125;/,
        &quot;email&quot;: &quot;@email&quot;,
        &quot;address&quot;: &quot;@province&quot; + &quot;@city&quot; + &quot;@county&quot;
    &#125;]
&#125;);
</code></pre>
<pre><code class="javascript">Mock.mock(&quot;/greeting&quot;, &quot;post&quot;, function (options) &#123;
    // console.log(options);
    return &#123;
        &quot;greeting&quot;: &quot;hello, world&quot;
    &#125;
&#125;);
$.post(&quot;/greeting&quot;, &#123;
    name: &quot;zhangsan&quot;
&#125;).then(res =&gt; console.log(res));

Mock.mock(&quot;/greeting2&quot;, function (options) &#123;
    return &#123;
        &quot;_status&quot;: 404,
        &quot;_headers&quot;: &#123;
            
        &#125;
    &#125;
&#125;);
</code></pre>
</li>
</ol>
<h3 id="decimal-js"><a href="#decimal-js" class="headerlink" title="decimal.js"></a><a href="https://github.com/MikeMcl/decimal.js">decimal.js</a></h3><ol>
<li><p>引入</p>
<pre><code class="html">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/decimal.js/10.3.1/decimal.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
<blockquote>
<p>nodejs 安装</p>
<pre><code class="bash">npm install --save decimal.js
</code></pre>
</blockquote>
</li>
<li><p>语法</p>
<pre><code class="javascript">// nodejs 需引入 decimal.js 模块
// var Decimal = require(&quot;decimal.js&quot;);

// 加法
var a = 0.1;
var b = 0.2;
console.log(a.toString(2)); // 0.0001100110011001100110011001100110011001100110011001101
console.log(a + b); // 0.30000000000000004
console.log(new Decimal(a + &quot;&quot;).add(new Decimal(b)).toNumber()); // 0.3

// 减法
var a = 1.0;
var b = 0.7;
console.log(a - b); // 0.30000000000000004
console.log(new Decimal(a).sub(new Decimal(b)).toNumber()); // 0.3

// 乘法
var a = 1.01;
var b = 1.003;
console.log(a * b); // 1.0130299999999999
console.log(new Decimal(a).mul(new Decimal(b)).toNumber()); // 1.01303

// 除法
var a = 0.029;
var b = 10;
console.log(a / b); // 0.0029000000000000002
console.log(new Decimal(a).div(new Decimal(b)).toNumber()); // 0.0029
</code></pre>
</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>使用百度 api 查询经纬度位置信息<pre><code class="javascript">// # npm install node-fetch
// const fetch = require(&quot;node-fetch&quot;);
(async function (latitude, longitude) &#123;
    return await fetch(`http://api.map.baidu.com/geocoder/v2/?ak=wLyevcXk5QY36hTKmvV5350F&amp;callback=renderReverse&amp;location=$&#123;latitude&#125;,$&#123;longitude&#125;s&amp;output=json&amp;pois=0`, &#123;
        method: &quot;GET&quot;
    &#125;).then(r =&gt; r.text()).then(r =&gt; JSON.parse(r.replace(&quot;renderReverse&amp;&amp;renderReverse(&quot;, &quot;&quot;).replace(/\)$/, &quot;&quot;)));
&#125;)(39.916527, 116.397128);
</code></pre>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://blog.csdn.net/fdsdidgf/article/details/102566928">高薪的web前端工程师必会的19 个 JavaScript 简写方法</a></li>
</ul>
<details>

<summary>优雅的语法</summary>

<pre><code class="javascript">// 多个条件判断
// long
if (x === &quot;a&quot; || x === &quot;b&quot; || x === &quot;c&quot; || x === &quot;d&quot;) &#123;
    // todo
&#125;
// short
if ([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;].includes(x)) &#123;
    // todo
&#125;

// 三目运算符
// long
let flag
if (x &gt; 10) &#123;
    flag = true
&#125; else &#123;
    flag = false
&#125;
// short
let flag = x &gt; 10 ? true : false

// 变量声明
// long
let a
let b = 1
// short
let a, b = 1

// 空/未定义检查和分配默认值
// long
if (test1 !== null || test1 !== undefined || test1 !== &quot;&quot;) &#123;
    let test2 = test1;
&#125; else &#123;
    let test2 = &quot;&quot;
&#125;
// short
let test2 = test1 || &quot;&quot;

// 给多个变量赋值
//long 
let test1, test2, test3;
test1 = 1;
test2 = 2;
test3 = 3;
//Short 
let [test1, test2, test3] = [1, 2, 3];

// 赋值运算符的简写
// long
test1 = test1 + 1;
test2 = test2 - 1;
test3 = test3 * 20;
// short
test1++;
test2--;
test3 *= 20;

// 真值判断
// long
if (test1 === true)
// short
if (test1)

// 多条件的与/或运算
//long 
if (test1) &#123;
    callMethod();
&#125;
//short 
test1 &amp;&amp; callMethod();

// forEach
// long
for (var i = 0; i &lt; testList.length; i++)
// short
testList.forEach(item =&gt; console.log(item))

// 比较返回值
// long
let test;
function checkReturn() &#123;
    if (!(test === undefined)) &#123;
        return test;
    &#125; else &#123;
        return callMe(&quot;test&quot;);
    &#125;
&#125;
var data = checkReturn();
console.log(data); //output test
function callMe(val) &#123;
    console.log(val);
&#125;
// short
function checkReturn() &#123;
    return test || callMe(&quot;test&quot;);
&#125;

// 箭头函数
// long 
function add(a, b) &#123;
    return a + b;
&#125;
// short 
const add = (a, b) =&gt; a + b;

// 短函数调用
// long
function test1() &#123;
    console.log(&quot;test1&quot;);
&#125;;
function test2() &#123;
    console.log(&quot;test2&quot;);
&#125;;
var test3 = 1;
if (test3 == 1) &#123;
    test1();
&#125; else &#123;
    test2();
&#125;
// short
(test3 === 1 ? test1 : test2)();

// switch
// long
switch (data) &#123;
    case 1:
        test1();
        break;

    case 2:
        test2();
        break;

    case 3:
        test();
        break;
    // And so on...
&#125;
// short
var data = &#123;
    1: test1,
    2: test2,
    3: test
&#125;;
data[something] &amp;&amp; data[something]();

// 默认参数
// long
function add(test1, test2) &#123;
    if (test1 === undefined)
        test1 = 1;
    if (test2 === undefined)
        test2 = 2;
    return test1 + test2;
&#125;
// short
add = (test1 = 1, test2 = 2) =&gt; (test1 + test2);
add() // output: 3

// 参数必传校验
// long
function hello(obj) &#123;
    let &#123; name, age &#125; = obj
    if (!name) &#123;
        console.warn(&quot;name is null, pls check!&quot;)
        return &quot;&quot;
    &#125;
    if (!age) &#123;
        console.warn(&quot;age is null, pls check!&quot;)
        return &quot;&quot;
    &#125;
    return `$&#123;name&#125;: $&#123;age&#125;`
&#125;
// short
function hello(obj) &#123;
    let &#123; name = required(&quot;name&quot;), age = required(&quot;age&quot;) &#125; = obj
    return `$&#123;name&#125;: $&#123;age&#125;`
&#125;
function required(key) &#123;
    console.warn(`$&#123;key&#125; is null, pls check!`)
&#125;

// 扩展运算符
// long
const data = [1, 2, 3];
const test = [4, 5, 6].concat(data);
// short
const data = [1, 2, 3];
const test = [4, 5, 6, ...data];
console.log(test); // [ 4, 5, 6, 1, 2, 3]

// 克隆
// long
const test1 = [1, 2, 3];
const test2 = test1.slice()
// short
const test1 = [1, 2, 3];
const test2 = [...test1];

// 模板字符串/模板字面量
// long
const welcome = &quot;Hi &quot; + user + &quot; &quot; + name + &quot;.&quot;
// short
const welcome = `Hi $&#123;user&#125; $&#123;name&#125;`;

// 对象属性赋值
let test1 = &quot;a&quot;;
let test2 = &quot;b&quot;;
// long
let obj = &#123; test1: test1, test2: test2 &#125;;
// short 
let obj = &#123; test1, test2 &#125;;

// 字符串转换成数字
// long
let test1 = parseInt(&quot;123&quot;);
let test2 = parseFloat(&quot;12.3&quot;);
// short
let test1 = +&quot;123&quot;;
let test2 = +&quot;12.3&quot;;

// Array.find
const data = [&#123;
    type: &quot;test1&quot;,
    name: &quot;abc&quot;
&#125;,
&#123;
    type: &quot;test2&quot;,
    name: &quot;cde&quot;
&#125;,
&#123;
    type: &quot;test1&quot;,
    name: &quot;fgh&quot;
&#125;,
]
// long
function findtest1(name) &#123;
    for (let i = 0; i &lt; data.length; ++i) &#123;
        if (data[i].type === &quot;test1&quot; &amp;&amp; data[i].name === name) &#123;
            return data[i];
        &#125;
    &#125;
&#125;
//shorthand
filteredData = data.find(data =&gt; data.type === &quot;test1&quot; &amp;&amp; data.name === &quot;fgh&quot;);
console.log(filteredData); 

// 多条件判断
// long
if (type === &quot;test1&quot;) &#123;
    test1();
&#125;
else if (type === &quot;test2&quot;) &#123;
    test2();
&#125;
else if (type === &quot;test3&quot;) &#123;
    test3();
&#125;
else if (type === &quot;test4&quot;) &#123;
    test4();
&#125; else &#123;
    throw new Error(&quot;Invalid value &quot; + type);
&#125;
// short
const types = &#123;
    test1: test1,
    test2: test2,
    test3: test3,
    test4: test4
&#125;;
let func = types[type];
(!func) &amp;&amp; throw new Error(&quot;Invalid value &quot; + type); func();

// 索引查找
// long
if (arr.indexOf(item) &gt; -1) &#123; // item found 
&#125;
if (arr.indexOf(item) === -1) &#123; // item not found
&#125;
// short
if (~arr.indexOf(item)) &#123; // item found
&#125;
if (!~arr.indexOf(item)) &#123; // item not found
&#125;
// 按位~运算符将返回非-1的真实值。取反就像做~一样简单。另外，我们也可以使用include()函数
if (arr.includes(item)) &#123; 
    // true if the item found
&#125;

// Object.entries()
const data = &#123; test1: &quot;abc&quot;, test2: &quot;cde&quot;, test3: &quot;efg&quot; &#125;;
const arr = Object.entries(data);
console.log(arr); // [[ &quot;test1&quot;, &quot;abc&quot; ], [ &quot;test2&quot;, &quot;cde&quot; ], [ &quot;test3&quot;, &quot;efg&quot; ]]

// Object.values()
const data = &#123; test1: &quot;abc&quot;, test2: &quot;cde&quot; &#125;;
const arr = Object.values(data);
console.log(arr); // [ &quot;abc&quot;, &quot;cde&quot;]

// 重复一个字符串多次
// long 
let test = &quot;&quot;;
for (let i = 0; i &lt; 5; i++) &#123;
    test += &quot;test &quot;;
&#125;
console.log(str); // test test test test test 
// short 
&quot;test &quot;.repeat(5);

// 在数组中查找最大值和最小值
const arr = [1, 2, 3]; 
Math.max(…arr); // 3
Math.min(…arr); // 1
Math.min.apply(null, arr); // 1

// 使用展开运算符号 `...` 有条件地向对象快速添加属性
const condition = true;
const person = &#123;
  id: 1,
  name: &quot;John Doe&quot;,
  ...(condition &amp;&amp; &#123; age: 16 &#125;),
&#125;;

// 合并对象
let a = &#123; 1: 1, 2: 2, 3: 0 &#125;,
    b = &#123; 3: 3, 4: 4 &#125;;
console.log(&#123; ...b, ...a, 5: 5 &#125;); // &#123; 1: 1, 2: 2, 3: 0, 4: 4, 5: 5 &#125; // 相同属性 3，后添加的(a: &#123; 3: 0 &#125;)会覆盖之前同名属性(b: &#123; 3: 3 &#125;)值，最终为 &#123; 3: 0 &#125;

// 使用 `in` 关键字来检查对象中是否存在某个属性
const person = &#123; name: &quot;前端小智&quot;, salary: 1000 &#125;;
console.log(&quot;salary&quot; in person); // true
console.log(&quot;age&quot; in person); // false

// 使用 `[&quot;key name&quot;]` 动态键设置对象属性
const dynamic = &quot;flavour&quot;;
var item = &#123;
  name: &quot;前端小智&quot;,
  [dynamic]: &quot;巧克力&quot;
&#125;
console.log(item); // &#123; name: &quot;前端小智&quot;, flavour: &quot;巧克力&quot; &#125;
const keyName = &quot;name&quot;;
console.log(item[keyName]); // returns &quot;前端小智&quot;

// 使用 `:` 来对解构的属性进行重命名
const person = &#123; id: 1, name: &quot;前端小智&quot; &#125;;
const &#123; name: personName &#125; = person;
console.log(personName); // &quot;前端小智&quot;
// 用动态键来解构属性
const templates = &#123;
  &quot;hello&quot;: &quot;Hello there&quot;,
  &quot;bye&quot;: &quot;Good bye&quot;
&#125;;
const templateName = &quot;bye&quot;;
const &#123; [templateName]: template &#125; = templates;
console.log(template); // Good bye

// 空值合并 `??` 操作符，当它的左侧操作数为 null 或 undefined 时，它返回右侧的操作数，否则返回其左侧的操作数
const foo = null ?? &quot;Hello&quot;;
console.log(foo); // &quot;Hello&quot;
const bar = &quot;Not null&quot; ?? &quot;Hello&quot;;
console.log(bar); // &quot;Not null&quot;
const baz = 0 ?? &quot;Hello&quot;;
console.log(baz); // 0

// https://m.toutiao.com/is/dnGrHRV/?=有个开发者总结这 15 优雅的 JavaScript 个技巧
</code></pre>
</details>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes</title>
    <url>/2025/03/22/kubernetes/</url>
    <content><![CDATA[<h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a><a href="https://www.kubernetes.org.cn/k8s">Kubernetes</a></h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="示例部署"><a href="#示例部署" class="headerlink" title="示例部署"></a>示例部署</h2><h3 id="部署业务应用（deployment-资源）"><a href="#部署业务应用（deployment-资源）" class="headerlink" title="部署业务应用（deployment 资源）"></a>部署业务应用（deployment 资源）</h3><ol>
<li><p>创建文件 deploy.yaml 如下</p>
<pre><code class="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deployment
  namespace: handson-7609b5511e618e0aebc8dcf2c96e23e6
  labels:
    app: myapp
spec:
  replicas: 1 # 表示当前应用只部署一份
  selector:
    matchLabels:
    name: myapp
  template:
    metadata:
      labels:
      name: myapp
      namespace: handson-7609b5511e618e0aebc8dcf2c96e23e6
    spec:
      containers:
        - name: myapp
          image: registry.cn-shanghai.aliyuncs.com/workbench_1459088147016887/handson_ack_test:3 # web 应用的镜像地址
          ports:
            - containerPort: 8080
</code></pre>
</li>
<li><p>部署</p>
<pre><code class="bash">kubectl apply -f deploy.yaml
</code></pre>
</li>
<li><p>查询已部署的 pod</p>
<pre><code class="bash">kubectl get pod
</code></pre>
</li>
<li><p>重启</p>
<pre><code class="bash">kubectl delete pod myapp-deployment
# 执行 delete pod 后将会立即重启了一个新的同类型的 pod，因为 deployment 控制 replicasSet，当副本数跟实际的不相符的时候，rs 会自动再创建新的，直到跟模板上的一致
</code></pre>
</li>
<li><p>卸载</p>
<pre><code class="bash">kubectl delete deployment myapp-deployment
</code></pre>
</li>
</ol>
<h3 id="部署服务（service-资源）"><a href="#部署服务（service-资源）" class="headerlink" title="部署服务（service 资源）"></a>部署服务（service 资源）</h3><ol>
<li><p>创建文件 service.yaml 如下</p>
<pre><code class="yaml">apiVersion: v1
kind: Service
metadata:
  name: myapp-service
  namespace: handson-7609b5511e618e0aebc8dcf2c96e23e6
spec:
  ports: # 这里定义了服务自身暴露的端口和需要访问的应用的端口
    - port: 8080
      targetPort: 8080
      protocol: TCP
  type: NodePort
  selector: # 这是一个选择器，通过 name=myapp 这个条件来选择需要代理的服务
    name: myapp
</code></pre>
</li>
<li><p>部署</p>
<pre><code class="bash">kubectl apply -f service.yaml
</code></pre>
</li>
<li><p>查询已部署的 service</p>
<pre><code class="bash">kubectl get service
</code></pre>
</li>
<li><p>卸载</p>
<pre><code class="bash">kubectl delete service myapp-service
</code></pre>
</li>
</ol>
<h3 id="配置-ingress-开放外部访问"><a href="#配置-ingress-开放外部访问" class="headerlink" title="配置 ingress 开放外部访问"></a>配置 ingress 开放外部访问</h3><ol>
<li><p>创建文件 ingress.yaml 如下</p>
<pre><code class="yaml">apiVersion: networking.k8s.io/v1beta1
kind: Ingress
metadata:
  name: example-ingress
  namespace: handson-7609b5511e618e0aebc8dcf2c96e23e6
spec:
  rules:
    - http:
        paths:
          - path: /welcome
            backend:
              serviceName: myapp-service
              servicePort: 8080
</code></pre>
</li>
<li><p>部署</p>
<pre><code class="bash">kubectl apply -f ingress.yaml
</code></pre>
</li>
<li><p>查询已部署的 ingress</p>
<pre><code class="bash">kubectl get ingress
</code></pre>
</li>
<li><p>卸载</p>
<pre><code class="bash">kubectl delete ingress example-ingress
</code></pre>
</li>
</ol>
<h2 id="kubectl-命令"><a href="#kubectl-命令" class="headerlink" title="kubectl 命令"></a>kubectl 命令</h2><pre><code class="bash"># 查看所有命名空间
kubectl get namespace

# 查看默认命名空间 default 下所有 pods
kubectl get pods
# 查看命名空间 n1 下所有 pods
kubectl get pods -n n1

# 查看当前可用的 api 版本
kubectl api-versions

# 查看命名空间 n1 下 example-ingress 的描述 yaml 文件
kubectl -n n1 get ingress -o yaml example-ingress
</code></pre>
<h2 id="yaml-配置"><a href="#yaml-配置" class="headerlink" title="yaml 配置"></a>yaml 配置</h2><pre><code class="yaml"># 必填，api 版本，可通过命令 kubectl api-versions 查询所有可选值
apiVersion: v1

# 必填，资源类别，包括：
#   资源对象 Pod、ReplicaSet、ReplicationController、Deployment、StatefulSet、DaemonSet、Job、CronJob、HorizontalPodAutoscaling
#   配置对象 Node、Namespace、Service、Secret、ConfigMap、Ingress、Label、ThirdPartyResource、ServiceAccount
#   存储对象 Volume、Persistent Volume
#   策略对象 SecurityContext、ResourceQuota、LimitRange
kind: Pod

metadata: # 必填，元数据
  name: string # 必填，名称
  namespace: string # 必填，所属命名空间
  labels: # 自定义标签
    - name: string # 自定义标签名字
  annotations: # 自定义注释列表
    - name: string
spec: # 必选，容器的详细定义
  containers: # 必选，Pod 中容器列表
  - name: string # 必选，容器名称
    image: string # 必选，容器的镜像名称
    imagePullPolicy: [Always | Never | IfNotPresent] # 获取镜像的策略，Alawys 表示下载镜像，IfnotPresent 表示优先使用本地镜像，否则下载镜像，Nerver 表示仅使用本地镜像
    command: [string] # 容器的启动命令列表，如不指定，使用打包时使用的启动命令
    args: [string] # 容器的启动命令参数列表
    workingDir: string # 容器的工作目录
    volumeMounts: # 挂载到容器内部的存储卷配置
    - name: string # 引用 pod 定义的共享存储卷的名称，需用 volumes[] 部分定义的的卷名
      mountPath: string # 存储卷在容器内 mount 的绝对路径，应少于 512 字符
      readOnly: boolean # 是否为只读模式
    ports: # 需要暴露的端口库号列表
    - name: string # 端口号名称
      containerPort: int # 容器需要监听的端口号
      hostPort: int # 容器所在主机需要监听的端口号，默认与 Container 相同
      protocol: string # 端口协议，支持 TCP 和 UDP，默认 TCP
    env: # 容器运行前需设置的环境变量列表
    - name: string # 环境变量名称
      value: string # 环境变量的值
    resources: # 资源限制和请求的设置
      limits: # 资源限制的设置
        cpu: string # Cpu 的限制，单位为 core 数，将用于 docker run --cpu-shares 参数
        memory: string # 内存限制，单位可以为 Mib/Gib，将用于 docker run --memory 参数
      requests: # 资源请求的设置
        cpu: string # Cpu 请求，容器启动的初始可用数量
        memory: string # 内存清楚，容器启动的初始可用数量
    livenessProbe: # 对 Pod 内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有 exec、httpGet 和 tcpSocket，对一个容器只需设置其中一种方法即可
      exec: # 对Pod容器内检查方式设置为 exec 方式
        command: [string] # exec 方式需要制定的命令或脚本
      httpGet: # 对 Pod 内个容器健康检查方法设置为 HttpGet，需要制定 Path、port
        path: string
        port: number
        host: string
        scheme: string
        HttpHeaders:
        - name: string
          value: string
      tcpSocket: # 对 Pod 内个容器健康检查方式设置为 tcpSocket 方式
         port: number
       initialDelaySeconds: 0 # 容器启动完成后首次探测的时间，单位为秒
       timeoutSeconds: 0 # 对容器健康检查探测等待响应的超时时间，单位秒，默认 1 秒
       periodSeconds: 0 # 对容器监控检查的定期探测时间设置，单位秒，默认 10 秒一次
       successThreshold: 0
       failureThreshold: 0
       securityContext:
         privileged: false
    restartPolicy: [Always | Never | OnFailure] # Pod 的重启策略，Always 表示一旦不管以何种方式终止运行，kubelet 都将重启，OnFailure 表示只有 Pod 以非 0 退出码退出才重启，Nerver 表示不再重启该 Pod
    nodeSelector: obeject # 设置 NodeSelector 表示将该 Pod 调度到包含这个 label 的 node 上，以 key: value 的格式指定
    imagePullSecrets: # Pull 镜像时使用的 secret 名称，以 key: secretkey 格式指定
    - name: string
    hostNetwork:false # 是否使用主机网络模式，默认为 false，如果设置为 true，表示使用宿主机网络
    volumes: # 在该 pod 上定义共享存储卷列表
    - name: string # 共享存储卷名称（volumes 类型有很多种）
      emptyDir: &#123;&#125; # 类型为 emtyDir 的存储卷，与Pod同生命周期的一个临时目录。为空值
      hostPath: string # 类型为 hostPath 的存储卷，表示挂载 Pod 所在宿主机的目录
        path: string # Pod 所在宿主机的目录，将被用于同期中 mount 的目录
      secret: # 类型为 secret 的存储卷，挂载集群与定义的 secre 对象到容器内部
        scretname: string  
        items:     
        - key: string
          path: string
      configMap: # 类型为 configMap 的存储卷，挂载预定义的 configMap 对象到容器内部
        name: string
        items:
        - key: string
          path: string
</code></pre>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令</title>
    <url>/2025/03/22/linux/</url>
    <content><![CDATA[<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><ul>
<li><p>常用文件管理命令</p>
<pre><code class="bash"># # 强制删除目录以及其下所有文件、文件夹（参数 f 表示强制，不推荐使用；参数 r 表示递归删除）
# rm -rf folder
# 递归删除目录
rm -r folder
# 删除文件 hello.txt
rm hello.txt

# 彻底删除、粉碎文件
shred -u hello.txt

# 显示当前目录，print working directory(打印工作目录)
pwd

# 创建一个空白的文件
touch file

# 创建一个临时文件（&quot;tmp.XXX&quot; 为模板，其中的 &quot;X&quot; 数量必须大于等于 3），如 tmp.hKg
mktemp tmp.XXX

# 在 test.txt 中查找 money 这个字符串，grep 查找是区分大小写的
grep money test.txt
ls -l | grep -Po &#39;git-[a-z]+.exe&#39; # 参数 “-o” 表示只显示匹配内容

# 把 file1 的文件内容加上行号后输入 file2 这个文件里
cat -n file1 &gt; file2

# 把 file1 和 file2 的文件内容加上行号（空白行不加）之后将内容附加到 file3 里
cat -b file1 file2 &gt;&gt; file3
 
# 把 test.log 文件扔进垃圾箱，赋空值 test.log（清空文本 test.log 内容）
cat /dev/null &gt; test.log

# 显示 xxx.csv 文件中的第二、第三列
awk -F &#39;,&#39; &#39;&#123; print $2, $3 &#125;&#39; xxx.csv

# 清空文本 test.log 内容
echo &gt; test.log

# 实时显示新追加到文件中的信息
# tail -f test.log # &quot;-f&quot; 表示根据文件描述符进行追踪，当文件改名或被删除，追踪停止
tail -F test.log # &quot;-F&quot; 表示根据文件名进行追踪，并保持重试，即该文件被删除或改名后，如果再次创建相同的文件名，会继续追踪

# 以十六进制的方式读取文件 test.log
od -t x1 test.log
xxd \
    -u \ # 显示大写字母（默认为小写字母）
    -l 160 \ # 输出 160 个字符后停止
    test.log

# 以十六进制的方式读取文件 test.txt
hexdump -C test.txt

# 查看文件 test.log 的系统属性信息
stat test.log

# 以 utf-8 编码显示文件 test.txt 内容  
iconv -t utf-8 test.txt

# 查看程序的动态依赖库，如返回 &quot;not a dynamic executable&quot; 则表示该可执行文件不依赖任何动态链接库
ldd /bin/bash
# 将 /bin/bash 以及其依赖打包压缩至文件 rootfs.tar.gz 中
ldd /bin/bash | perl -p -e &#39;s#^\s*(\S+ =&gt; )?(/\S+) \(0x[0-9a-z]+\)$#$2#g&#39; | grep -v &#39;linux-vdso&#39; | sed &#39;$a/bin/bash&#39; | xargs tar zcvf rootfs.tar.gz

# 打开一个 bash，参数 “--rcfile” 指定预加载的 .bashrc 文件
bash --rcfile .bashrc

# 下载文件（&quot;-k&quot; 表示忽略 https 证书校验，&quot;-O&quot; 表示使用 URL 中默认的文件名保存文件到本地，&quot;-s&quot; 表示不显示下载进度，&quot;-L&quot; 表示自动跟踪 URL 重定向跳转，&quot;--retry 3 --retry-delay 2&quot; 表示失败重试 3 次，每次间隔 2 秒）
curl -k -O -s -L https://github.com/btraceio/btrace/releases/download/v1.3.11.1/btrace-bin-1.3.11.1.zip --retry 3 --retry-delay 2 &gt; /dev/null 2&gt;&amp;1
# curl -k -s -L https://sourceforge.net/projects/jodconverter/files/JODConverter/2.2.2/jodconverter-2.2.2.zip/download -o jodconverter-2.2.2.zip --retry 3 --retry-delay 2 &gt; /dev/null 2&gt;&amp;1

# 取某个路径下的目录名
dirname /home/test.txt # /home
# 取某个路径下的文件名
basename /home/test.txt # test.txt
# 取某个路径下的文件名（并去除文件后缀 .txt）
basename /home/test.txt .txt # test
</code></pre>
</li>
<li><p>根据文件名 “filename” 查找文件<br>  <code>find -name filename</code><br>  在当前目录下所有txt文件中查找内容 “word”<br>  <code>find -name &quot;*.txt&quot; | grep &quot;word&quot;</code><br>  <code>find . -name &quot;*.txt&quot; | grep &quot;word&quot;</code><br>  删除当前目录及子目录下所有 <em>.lastUpdated 文件<br>  <code>find -name &quot;*.lastUpdated&quot; | xargs rm</code><br>  强制删除当前目录及子目录下所有 *.git 目录及其子文件<br>  <code>find -name &quot;.git&quot; | xargs rm -rf</code><br>  删除 7 天前的文件（可用于定期手工清理 tomcat 日志文件）<br>  <code>find -mtime +7 -exec rm -f &#123;&#125; \;</code><br>  把 /home/logs/ 目录下所有 *.log 文件中的字符 “abc” 替换成 “def”<br>  <code>find /home/logs/ -name &quot;*.log&quot; | xargs sed -i &quot;s/abc/def/g&quot;</code><br>  统计当前目录及子目录下所有 *.java 文件的总行数<br>  <code>find -name &quot;*.java&quot; | xargs wc -l</code><br>  统计当前目录及子目录下所有文件的类型（后缀名）<br>  <code>find -name &quot;*.*&quot; | sed &#39;s/.*\./\./&#39; | sort | uniq</code><br>  查找当前目录下所有 *. java、</em>. xml、*. txt文件（参数 “-o” 表示或者）<br>  <code>find -name *. java -o -name *. xml -o -name *. txt</code><br>  查找当前目录下所有文件，并列出其详细信息<br>  <code>find ./ ! -type d -exec ls -l &#123;&#125; \;</code><br>  遍历查找当前目录下所有文件内容，查找包含内容 ‘“id”: ‘ 的行，使用正则替换，筛选出 id 的值并作为数进行排序，取最后一个值（即找出当前目录下所有文件中定义的 id 最大值）<br>  <code>grep -rn &#39;&quot;id&quot;: &#39; . | sed &#39;s/^.*&quot;id&quot;: \([0-9]\+\),/\1/&#39; | sort -n | tail -n 1</code><br>  <code>printf &quot;%d\n&quot; $(($(grep -rn &#39;&quot;id&quot;: &#39; . | sed &#39;s/^.*&quot;id&quot;: \([0-9]\+\),/\1/&#39; | sort -n | tail -n 1) + 1))</code><br>  <code>printf &quot;%04x\n&quot; $((16#$(grep -rn &#39;&quot;key&quot;: &#39; . | sed &#39;s/^.*&quot;key&quot;: &quot;\([a-zA-Z0-9]\+\)&quot;,/\1/g&#39; | sort -n | tail -n 1) + 1))</code><br>  批量重命名文件<br>  <code>find -name &#39;*.json&#39; | cut -c 3- | xargs -i mv &#123;&#125; A_&#123;&#125;</code><br>  查询当前目录下所有目录（不包含子目录），并删除目录名称中的 B_ 前缀<br>  <code>find . -maxdepth 1 -type d | tail -n +2 | sed &#39;s#^./B_##&#39; | xargs -I&#123;&#125; mv ./B_&#123;&#125; ./&#123;&#125;</code><br>  查询当前目录下所有 zip 文件，并将文件名中 “_” 去除  </p>
<pre><code class="shell">find *.zip | while read n; do mv $n `echo &quot;$n&quot; | sed &#39;s/_//g&#39;`; done
</code></pre>
<p>  查找当前目录下重复的多版本 jar 包<br>  <code>ls -a | sed &#39;s/-[^-]*\.jar$//g&#39; | sort | uniq -d</code><br>  从文件中随机选择一行<br>  <code>shuf pokemon.txt -n 1</code></p>
</li>
<li><p>监听文件 catalina.out，直到文件中出现 “org.apache.catalina.startup.Catalina.start Server startup in [0-9]+ ms” 后退出</p>
<pre><code class="bash"># (tail -f -n0 catalina.out &amp;) | grep -m 1 -E &quot;org.apache.catalina.startup.Catalina(.start)|- Server startup in [0-9]+ ms&quot; &amp;&amp; pkill -s 0 tail

# (tail -f -n0 catalina.out &amp;) | (grep -m 1 -E &quot;org.apache.catalina.startup.Catalina(.start)|- Server startup in [0-9]+ ms&quot; &amp;&amp; ( \
#     ps | grep tail | grep -oP &#39;^\s*([0-9]+)\s+&#39; | sed &#39;s/ //g&#39; | xargs kill -15 \
# )) &gt; /dev/null

tail -F -n 0 catalina.out | grep -m 1 -P &quot;org.apache.catalina.startup.Catalina(.start)|- Server startup in [0-9]+ ms&quot; &amp;&amp; (
    echo &#39;Tomcat has started.&#39;
    # ...
)
</code></pre>
</li>
<li><p>修改文件读写权限（文件或目录的拥有者、文件或目录的所属群组、其他用户。读取权限 ‘r’ 代号为 “4”，写入权限 ‘w’ 代号为 “2”，执行或切换权限 ‘x’ 代号为 “1”，不具任何权限 ‘-‘ 代号为 “0”）<br>  <code>chmod 777 filename</code><br>  <code>chmod ugo+rwx filename</code><br>  修改文件读写权限为 “-rwsr-xr-x”（第一个 4 表示给 /bin/cat 加上 setUID 权限，系统可以临时把这个文件的所有者（root）身份角色赋给普通用户）（<a href="http://www.linuxidc.com/Linux/2013-08/88587.htm">特殊权限 “setuid” 代号为 “4”，”setgid” 代号为 “2”，”stick bit” 代号为 “1”</a>）<br>  <code>chmod 4755 /bin/cat</code><br>  修改目录 “folder” 以及其下所有文件、文件夹读写权限<br>  <code>chmod -R 777 folder</code><br>  文件增加执行权限<br>  <code>chmod +x filename</code><br>  当前用户增加执行权限，组用户增加写权限<br>  <code>chmod u+x g+w filename</code><br>  当前用户具有读、写、执行权限，组用户具有读写权限，其他用户具有读权限<br>  <code>chmod u=rwx g=rw o=r filename</code><br>  修改文件的属主为 root<br>  <code>chown root filename</code><br>  <code>chown -R root filename</code><br>  修改文件的属主为 sa，群组为 sagroup<br>  <code>chown sa:sagroup filename</code><br>  修改文件的群组为 sagroup<br>  <code>chgrp sagroup filename</code><br>  查看、设置当前用户的 umask（umask 决定目录和文件被创建时得到的初始权限）</p>
<pre><code class="bash"># 查看当前用户的 umask
umask

# 设置当前用户的 umask
umask 022
# &quot;022&quot; 是八进制格式数据，二进制值为 10010，字符表示为 &quot;----w--w-&quot;。而 umask 为屏蔽的意思，即数值取反，二进制取反值为 &quot;111101101&quot;，八进制取反值为 &quot;755&quot;，字符表示为 &quot;rwxr-xr-x&quot;
</code></pre>
<p>  suid（4）、sgid（2）、sbit（1）  </p>
<pre><code class="bash"># suid
# 只要一个命令文件在属主权限位上的x变成s的话，那么其它用户在执行这个命令文件时，就会以该命令文件的属主用户身份去执行
chmod u+s filename # 授权 suid
chmod u-s filename # 取消授权 suid

# sgid
# 一般情况下是设置给目录使用的，主要目的就是为了让别的用户无法删除其它用户所创建的文件或目录
chmod g+s filename
chmod g-s filename

# sbit（sticky bit，即沾滞位）
# 只作用在目录上，当一个目录的没有设置sticky bit权限时，并且该目录对所有用户都有读、写、执行权限时，普通用户在该目录下所创建的文件或目录都会被其它用户删除
chmod o+t filename
chmod o-t filename
</code></pre>
<blockquote>
<p><a href="https://www.zhihu.com/tardis/sogou/art/29945600">文件信息</a></p>
<pre><code>drwxr-xr-- 4 root everybody 3488 Mar  2 21:30 src
# 第一列，第一位 `d` 表示文件类型为目录，第一组 `rwx` 表示文件的属主 `root` 用户的权限为：可读、可写、可执行，第二组 `r-x` 表示文件所属群组 `everybody` 的权限为：可读、可执行，第三组 `r--` 表示其他用户的权限为：可读。
# 第二列，`4` 表示有 4 个文件硬链接到此节点（i-node）：`.`、`..`、该目录下的两 2 个子目录（不计算子目录下的子目录）。当我们新建一个新的目录时，新的目录连接数为 2，而上层目录的连接数会增加 1。
# 第三列表示文件属主为 `root` 用户。
# 第四列表示文件所属组为 `everybody`。
# 第五列表示文件大小为 `3488` bytes。
# 第六列表示文件最近修改时间。
# 第七列为文件（这里是目录）名称。
-rw-rw---- 1 root everybody 2897 Jun  7 23:39 readme.md
# 第一列，第一位 `-` 表示文件类型为文件。
# 第二列，`1` 表示只有 1 个文件硬链接到此节点，即该文件除了自身，无硬连接。
</code></pre>
</blockquote>
</li>
<li><p>保护文件，禁止修改删除移动<br>  <code>chattr +i hello.txt</code><br>  去保护<br>  <code>chattr -i hello.txt</code></p>
</li>
<li><p>创建文件或目录 a 的硬连接 b（新建的文件是原文件的一个别名，当原文件被删除，新建的文件仍然可用）<br>  <code>ln a b</code><br>  创建文件或目录 a 的软连接（又称符号连接，类似于快捷方式，新建的文件可以指向不存在的文件）<br>  <code>ln -s a b</code><br>  删除连接 b<br>  <code>rm -f b</code></p>
</li>
<li><p>拷贝本地目录 /home/sa 目录及子文件到远程主机 192.168.1.1 的 /home/sa<br>  <code>scp -r /home/sa root@192.168.1.1:/home/sa</code><br>  将远程主机 192.168.1.1 上的 /home/sa/info.log 复制到本机的 /tmp 下<br>  <code>scp root@192.168.1.1:/home/sa/info.log /tmp</code></p>
</li>
<li><p>同步远程主机 192.168.1.1 上目录 /home/sa/dic/ 下除 .* 和 log 之外的文件到本地目录 /home/sa/dic 下<br>  <code>rsync -a --delete --exclude=&quot;.*&quot; --exclude=&quot;log&quot; root@192.168.1.1:/home/sa/dic/ /home/sa/dic/</code></p>
</li>
<li><p><a href="http://www.cnblogs.com/AloneSword/p/4918791.html">使用 GPG 对文件加密</a><br>  生成（自己的）密钥<br>  <code>gpg --gen-key</code><br>  导出（自己的）公钥，其中（自己的）用户 ID 为 “Ke Sun <a href="mailto:&#107;&#101;&#x2e;&#115;&#117;&#110;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;">&#107;&#101;&#x2e;&#115;&#117;&#110;&#x40;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#x6f;&#x6d;</a>“<br>  <code>gpg --armor --output public-key.txt --export &quot;Ke Sun &lt;ke.sun@gmail.com&gt;&quot;</code><br>  导入（他人的）公钥<br>  <code>gpg --import public-key.txt</code><br>  生成文件 “hello.txt” 的签名 “hello.txt.asc”<br>  <code>gpg --armor --detach-sign hello.txt</code><br>  校验文件 “hello.txt” 的签名 “hello.txt.asc”<br>  <code>gpg --verify hello.txt.asc hello.txt</code></p>
</li>
<li><p>计算文件的 sha-1 校验和<br>  <code>sha1sum a.txt</code><br>  计算文件的 md5 校验和<br>  <code>md5sum a.txt</code><br>  计算文件的 md5 校验和，并保存至文件 hello.txt.md5 中<br>  <del><code>md5sum &lt; hello.txt &gt; hello.txt.md5</code></del><br>  <code>md5sum hello.txt &gt; hello.txt.md5</code><br>  根据 hello.txt.md5 校验相应的文件<br>  <code>md5sum -c hello.txt.md5</code><br>  计算字符串 “hello, world” 的 md5 校验和<br>  <code>echo -n &quot;hello, world&quot; | md5sum</code></p>
</li>
<li><p>查找命令文件所在位置<br>  <code>which sha1sum</code></p>
</li>
<li><p>显示 /etc/hosts 的路径<br>  <code>ls /etc/hosts</code><br>  列出目录 /etc 下所有文件<br>  <code>ls -l /etc</code><br>  <code>ls -a /etc</code><br>  列出当前目录下所有文件和目录，并着色（参数 “–color” 表示对结果进行着色）<br>  <code>ls --color</code><br>  参数 “-h” 表示友好显示文件大小，如 4.0K、3.2M<br>  <code>ls -lh</code></p>
</li>
<li><p>使用 unix2dos 将文件 test.txt 由 unix 格式转换为 windows 格式（即将 “\n” 替换为 “\n\r”）<br>  <code>unix2dos test.txt</code><br>  <code>/bin/find -name &#39;*.txt&#39; | xargs unix2dos</code><br>  使用 dos2unix 将文件 test.txt 由 windows 格式转换为 unix 格式（即将 “\n\r” 替换为 “\n”）<br>  <code>dos2unix test.txt</code></p>
</li>
<li><p>使用 diff 简单比较两个文件 a.txt、b.txt<br>  <code>diff a.txt b.txt</code><br>  使用 diff 比较两个目录 a、b<br>  <code>diff -ywrNa ./a ./b</code><br>  使用 diff 比较两个目录 folder1、folder2 下所有文件，但不包括 “.git”、”bin” 目录和 “.classpath” 文件<br>  <del><code>diff -ywrNa folder1/ folder2/ -x .git -x bin -X .classpath</code></del><br>  <code>diff -ywrNa folder1/ folder2/ -x .git -x bin -x .classpath</code><br>  使用diff比较两个文件 a.txt、b.txt 并计数不相同的行数<br>  <code>diff -yw a.txt b.txt | grep -E &#39;&lt;|&gt;|\|&#39; | wc -l</code><br>  比较两个文件 f1、f2，并导出补丁脚本（不包括相同的行）<br>  <code>diff -Nu f1 f2 | grep -E &#39;^[^ ]&#39;</code><br>  比较两个目录 d1、d2，并导出补丁脚本（不包括相同的行）<br>  <code>diff -Nur ./d1 ./d2 | grep -E &#39;^[^ ]&#39;</code>  </p>
</li>
<li><p>比较两个文件 f1、f2，并导出补丁脚本 f2.patch（windows 下可使用 TortoiseUDiff 或 TortoiseGitUDiff 打开 .patch/.diff 文件）<br>  <code>diff -Nu f1 f2 &gt; f2.patch</code><br>  给文件 f1 打补丁 f2.patch，结果 f1 应与 f2 一致<br>  <del><code>patch -p0 &lt; f2.patch</code></del><br>  <code>patch f1 &lt; f2.patch</code><br>  给文件 f1 撤销补丁 f2.patch，文件 f1 被还原<br>  <del><code>patch -RE -p0 &lt; f2.patch</code></del><br>  <code>patch -R f1 &lt; f2.patch</code></p>
</li>
<li><p>比较两个目录、导出补丁脚本、打补丁、撤销补丁</p>
<ol>
<li>比较两个目录 d1、d2，并导出补丁脚本 d2.patch<br> <code>diff -Nur ./d1 ./d2 &gt; d2.patch</code></li>
<li>给目录 d1 打补丁 d2.patch，结果 d1 应与 d2 一致<ul>
<li>方法一：<br>  <code>patch --binary --dir ./d1 &lt; d2.patch</code></li>
<li>方法二：<br>  <code>cd ./d1 &amp;&amp; patch --binary -p1 &lt; d2.patch &amp;&amp; cd ../</code></li>
</ul>
</li>
<li>给目录 d1 撤销补丁 d2.patch，目录 d1 被还原<ul>
<li>方法一：<br>  <code>patch --binary -R --dir ./d1 &lt; d2.patch</code></li>
<li>方法二：<br>  <code>cd ./d1 &amp;&amp; patch --binary -R -p1 &lt; d2.patch &amp;&amp; cd ../</code></li>
</ul>
</li>
</ol>
</li>
<li><p>将 docx 文件转换为 txt 文件<br>  <code>docx2txt *.docx</code></p>
</li>
<li><p>交集、并集、差集</p>
<pre><code class="bash"># 交集
#grep -F -f a.txt b.txt
#cat b.txt | grep -F -f a.txt
sort a.txt b.txt | uniq -d

# 并集
#cat a.txt b.txt | sort | uniq
sort a.txt b.txt | uniq

# 差集（a.txt - b.txt）
#grep -F -v -f b.txt a.txt
#cat a.txt | grep -F -v -f b.txt
sort a.txt b.txt b.txt | uniq -u
</code></pre>
</li>
</ul>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><ul>
<li><p>返回到上一次的工作目录<br>  <code>cd -</code><br>  返回上一层目录<br>  <code>cd ../</code><br>  返回到用户的家目录<br>  <code>cd ~</code><br>  进入到文件 /etc/sudoers 所在目录<br>  <code>cd $(dirname /etc/sudoers)</code></p>
</li>
<li><p>统计 / 目录下目录或文件所占用磁盘大小，”-d 1” 表示遍历的目录深度为 1<br>  <code>du -h -d 1 /</code></p>
</li>
<li><p>快速制作系统盘<br>  <code>dd if=ubuntu-server-amd64.iso of=/dev/sdb</code><br>  安全擦除硬盘数据<br>  <code>dd if=/dev/urandom of=/dev/sda</code></p>
</li>
</ul>
<h2 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h2><ul>
<li><p><a href="https://www.jianshu.com/p/b5ec0df362e5">vim 编辑器</a></p>
<ul>
<li>使用 vi 编辑器编辑文本文件 temp.txt<br>  <code>vi temp.txt</code>  </li>
<li>以二进制模式（binary mode）编辑文件 temp.txt（该模式下，\r 会显示为 ^M，即不可打印字符（non-printable char））<br>  <code>vi -b temp.txt</code></li>
<li>同时打开多个文件<br>  <code>vi file1 file2 file3 ...</code><blockquote>
<ul>
<li>Edit 模式（刚启动时 vim 工作于 edit 模式, 主要是用来进行一下文本操作）</li>
<li>Insert 模式（键入 “i” 进入该模式，按下 <Esc> 退出该模式）</li>
<li>Command 模式（使用 “:”，按下 <Esc> 键退出 Insert 模式回到 Normal 模式）<ul>
<li>输入 <code>:%!xxd</code> 可将当前文件转换为 16 进制文本，再次输入 <code>:%!xxd -r</code> 可将 16 进制文本转换会原文本</li>
<li>先键入 <code>gg</code>，再键入 <code>=</code>，再键入 <code>G</code>，可使全部代码自动对齐</li>
<li>输入 <code>:X</code> 可设置当前文本加密，按照提示输入密码后保存退出完成加密（若输入密码为空，则表示不加密，即解密）<blockquote>
<p>若提示 “E21: Cannot make changes, ‘modifiable’ is off” 错误信息，需输入 <code>:set modifiable</code> 将文件设置为可修改模式，之后再重复上一步骤中的命令</p>
</blockquote>
</li>
<li>输入 <code>:s/old/new</code>，表示替换当前行中第一个 old 为 new<br>  输入 <code>:%s/old/new/g</code>，表示替换全文中所有 old 为 new  </li>
<li>输入 <code>/keyword</code>，表示向下搜索 keyword 关键词（按 <N> 表示查找下一个）</li>
<li>输入 <code>?keyword</code>，表示向上搜索 keyword 关键词（按 <N> 表示查找上一个）</li>
<li>输入 <code>:set number</code> 显示行号</li>
<li>输入 <code>:set hlsearch</code> 开启搜索结果高亮</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>在当前目录下递归查找内容 “word”<br>  <code>grep -rn word ./</code><br>  在文件 “temp.txt” 中使用正则表达式 “([0-9]+)(.[0-9]+){3}” 查找 IP 地址（参数 “-E” 表示使用正则表达式，参数 “-o” 表示只显示一行中匹配的部分，<font color=red>grep 无法匹配 CRLF 换行符，即无法跨行匹配</font>）<br>  <code>grep -E &#39;([0-9]+)(\.[0-9]+)&#123;3&#125;&#39; temp.txt</code><br>  <del><code>grep -oE &#39;([0-9]+)(\.[0-9]+)&#123;3&#125;&#39; *.txt</code></del><br>  在文件 *.txt 中查找字符串 “hello”，并显示其所在行以及上下 5 行（参数 “-C” 表示匹配字符串所在行以及上下几行，参数 “-B” 表示显示字符串所在行及前几行，参数 “-A” 表示显示字符串所在行及后几行）<br>  <code>grep -C 5 &#39;hello&#39; *.txt</code><br>  查找 catalina.sh 文件中 webresource 所在行号<br>  <code>grep -n webresource catalina.sh | cut -d : -f1</code><br>  查找 catalina.sh 文件中 webresource 所在行，并打印下一行行号<br>  <code>echo $(($(grep -n webresource catalina.sh | cut -d : -f1) + 1))</code><br>  使用正则表达式 [a-zA-Z0-9_]+ 查找所有的匹配项（tail -n +7 表示忽略结果中的前7行）<br>  <code>curl http://127.0.0.1:8080/admin/collections?action=List | grep -o -E &#39;[a-zA-Z0-9_]+&#39; | tail -n +7</code><br>  参数 “-P” 表示使用 perl 正则表达式查询<br>  <code>grep -P &#39;^PermitRootLogin ((?!no)\S)+$&#39; /etc/ssh/sshd_config</code><br>  参数 “–color=auto” 表示高亮显示结果<br>  <code>grep --color=auto &#39;hello, world&#39; hello.txt</code><br>  参数 “–exclude” 表示排除文件<br>  <code>grep -l -r --include &#39;*.csv&#39; --exclude &#39;res.csv&#39; --exclude &#39;list.txt&#39; &#39;hello, world&#39; . | wc -l</code></p>
</li>
<li><p>就地替换文件 debug.log 中所有 “world” 为 “luffy”（参数 “-i” 表示直接修改文件内容）<br>  <code>sed -i &#39;s/world/luffy/g&#39; debug.log</code><br>  将文件 debug.log 中所有 “world” 替换为 “luffy” 并保存至 “debug.new.log” 中<br>  <code>sed &#39;s/world/luffy/g&#39; debug.log &gt; debug.new.log</code><br>  在文件 “temp.txt” 中使用正则表达式 “([0-9]+)(.[0-9]+){3}” 查找 IP 地址（参数 “-r” 表示使用正则表达式，参数 “-n” 和标志 “p” 表示只打印匹配的行）<br>  <code>sed -nr &#39;/([0-9]+)(\.[0-9]+)&#123;3&#125;/p&#39; temp.txt</code><br>  在文件 “temp.txt” 末尾添加一行 “hello, world”<br>  <code>sed &#39;$ahello, world&#39; hello.txt</code><br>  将所有的行（以 “|” 为分隔符，拼接为一行）<br>  <code>sed &#39;:a;N;$!ba;s/\n/|/g&#39; xxx.txt</code><br>  查找 catalina.sh 文件中 webresource 所在行，并在下一行添加一行 “echo hello, world”<br>  <code>sed &quot;$(($(grep -n webresource catalina.sh | cut -d : -f1) + 1))&quot;&#39;iecho hello, world&#39; catalina.sh</code><br>  或</p>
<pre><code class="bash">sed &#39;/webresource/ &#123;
  n
  i echo hello, world
&#125;&#39; catalina.sh
# 其中 /webresource/ 表示匹配 webresource 所在行，n 表示下一行，i 表示插入行， r 表示插入文件内容（如 r hello.txt）
</code></pre>
<p>  筛选第二行内容<br>  <code>echo -e &quot;1\n2\n3&quot;  | sed -n 2p</code></p>
<blockquote>
<p>其中</p>
<ul>
<li>参数，如 sed -i ‘/…/…/‘ …<ul>
<li><code>i</code> 表示将修改替换的内容写入到原文件中</li>
</ul>
</li>
<li>查找标志，如 sed ‘s/…/…/‘ …<ul>
<li><code>s</code> 表示替换内容</li>
<li><code>n</code> 表示新增空行</li>
<li><code>i</code> 表示插入一行，如在第四行插入内容 sed ‘4ihello, world’ …</li>
</ul>
</li>
<li>替换标志，如 sed ‘/…/…/g’ …<ul>
<li><code>g</code> 表示全局替换</li>
<li><code>i</code> 表示不区分大小写</li>
</ul>
</li>
</ul>
</blockquote>
<p>  替换配置文件中第一次出现的文本内容<br>  <code>sed -i &#39;0,/IP = .*/s/IP = .*/IP = 10.10.10.10/&#39; /usr/share/config.conf</code><br>  删除包含字符串 “test” 的行<br>  <code>sed -i &#39;/test/d&#39; log.txt</code></p>
</li>
<li><p>awk</p>
<pre><code class="bash"># awk 忽略引号中的分隔符
echo &#39;a,b,c,&quot;d,e&quot;,f&#39; | awk -v -FPAT &#39;([^,]*)|(&quot;[^&quot;]*&quot;)&#39; &#39;&#123;print $4&#125;&#39; # &quot;d,e&quot;

# awk 删除行
awk -v -FPAT &#39;([^,]*)|(&quot;[^&quot;]|&quot;&quot;*&quot;)&#39; &#39;&#123; for (i = 1; i &lt;= NF; i++) &#123; if (i != 2) &#123; printf(&quot;%s&quot;, $i); if (i != NF) printf(&quot;,&quot;); &#125; &#125; printf(&quot;\n&quot;) &#125;&#39; test.csv 1&lt;&gt; test.csv

git diff | grep -P &#39;^(?!---)-&#39; | sed &#39;s/^-//g&#39; | awk -v -FPAT &#39;([^,]*)|(&quot;[^&quot;]|&quot;&quot;*&quot;)&#39; &#39;function contain(diamond, rough, x, y) &#123; for (x in rough) y[rough[x]]; return diamond in y; &#125; BEGIN &#123; split(&quot;20&quot;, indexs, &quot;,&quot;) &#125; &#123; for (i = 1; i &lt;= NF; i++) &#123; if (!contain(i, indexs)) &#123; printf(&quot;%s&quot;, $i); if (i != NF) printf(&quot;,&quot;); &#125; &#125; printf(&quot;\n&quot;) &#125;&#39; &gt; temp.okf

# 根据文件属主，分组显示文件
ls -l | tail -n +2 | awk &#39;&#123; ds[$3] += 1; fs[$3, ds[$3]] = $9; &#125; END &#123; for (x in ds) &#123; print x; for (y = 1; y &lt; ds[x]; y++) &#123; printf(&quot;  %s\n&quot;, fs[x, y]); &#125; &#125; &#125;&#39;

# 查找以 2019 开头的行记录
awk &#39;&#123;if(/^2019/) print&#125;&#39; ids.txt
awk &#39;&#123;if($0~&quot;201709&quot;) print&#125;&#39; ids.txt
</code></pre>
</li>
<li><p><a href="https://stackoverflow.com/questions/1348124/replace-an-xml-elements-value-sed-regular-expression">使用正则表达式替换文本内容（不保存修改到文件）</a><br>  <code>perl -p -0777 -e &#39;s/&lt;Context docBase=&quot;solr&quot;[^&gt;]*&gt;//&#39; server.xml</code><br>  使用正则表达式替换文本内容<br>  <code>perl -p -0777 -i -e &#39;s/&lt;Context docBase=&quot;solr&quot;[^&gt;]*&gt;//&#39; server.xml</code><br>  参数 -0777 会忽略分割符，无法匹配行首和行尾<br>  <code>perl -p -i -e &#39;s/^hello$/world/&#39; hello.txt</code></p>
</li>
<li><p>使用 cut 截断字符串（截取 当前登录信息中 “(“ 和 “)” 之间的内容，即登录者的 ip）<br>  <code>who am i | cut -d &#39;(&#39; -f2 | cut -d &#39;)&#39; -f1</code></p>
</li>
<li><p>向文件 temp.txt 中写入一行或多行内容，输入结束后，另起一行输入 “EOF” 表示结束写操作</p>
<pre><code class="bash"># cat &lt;&lt; EOF # 使用 EOF，需要对特殊字符如 &quot;$&quot;、&quot;`&quot;进行转义 &quot;\$&quot;、&quot;\`&quot;
# cat &lt;&lt; &quot;EOF&quot; # 加引号如 &quot;EOF&quot; 则特殊字符无需转义
cat &gt;&gt; temp.txt &lt;&lt; &quot;EOF&quot;
hello, world
EOF
</code></pre>
</li>
<li><p>大文件分割，如将文件 catalina.out 分割为多个以 catalina_ 为前缀的文件（单个文件不超过 10 MB），如 catalina_aa、catalina_ab、catalina_ac…<br>  <code>split -C 10M catalina.out catalina_</code></p>
</li>
<li><p>使用 jq 解析 json</p>
<ol>
<li>安装<br> <code>apt install jq</code></li>
</ol>
<ul>
<li>格式化显示 package.json 文件中的 json 报文<br>  <code>jq . package.json</code></li>
<li>格式化显示 /author/name 属性<br>  <code>jq .author.name package.json</code></li>
<li>格式化显示 /contributors 属性<br>  <code>jq -r .contributors[] package.json</code></li>
<li>格式化显示 /contributors 数组的第一个元素的 name 属性<br>  <code>jq .contributors[0].name package.json</code></li>
<li>压缩 json 报文，并写入到文件 package.min.json 中<br>  <code>jq --compact-output . package.json&gt; package.min.json</code></li>
<li>筛选出 /users 数组元素中 id、name 属性<br>  <code>cat users.json | jq &#39;.users[] | &#123; id, name &#125;&#39;</code><br>  筛选出 name 为 zhangsan 的 user<br>  <code>jq -r &#39;.users[] | select(.name == &quot;zhangsan&quot;)&#39; users.json</code><br>  筛选出 name 为 zhangsan 或 lisi 的 user<br>  <code>jq -r &#39;.users[] | select(.name == &quot;zhangsan&quot;, .name == &quot;lisi&quot;)&#39; users.json</code><br>  筛选出 age 大于 18，并且 name 为 zhangsan 的 user，并过滤（只展示）name 属性<br>  <code>jq -r &#39;.users[] | select(.age &gt; 18) | select(.name == &quot;zhangsan&quot;) | .name&#39; users.json</code></li>
<li>筛选出 /users 数组元素中 id、name 属性，将结果中每两行拼接为一行（最终每行以 “[id]  [name]” 显示 users）<br>  <code>jq -r &#39;.users[] | &#123; id, name &#125;[]&#39; users.json | sed &#39;N;s/\n/\t/g&#39;</code></li>
<li>循环遍历 /users 数组元素中 id、name 属性，以 “id: $id, name: $name” 格式显示<br>  <code>jq -r &#39;.[] | .id + &quot; &quot; + .name &#39; users.json | while read -r id name; do echo &quot;id: $id, name: $name&quot;; done</code></li>
</ul>
</li>
<li><p>使用 xmllint 解析 xml</p>
<ul>
<li>格式化显示 xml 文档<br>  <code>echo -n &quot;$xml_content&quot; | xmllint --format -</code></li>
<li>获取文件 users.xml 中 <code>//user</code> 节点下的内容<br>  <code>xmllint --xpath &#39;//user/text()&#39; users.xml</code></li>
<li><a href="https://stackoverflow.com/questions/41114695/get-pom-xml-version-with-xmllint">获取 pom.xml 文件中的 groupId、artifactId、version</a><br>  <code>xmllint --xpath &#39;concat(/*[local-name()=&quot;project&quot;]/*[local-name()=&quot;groupId&quot;]/text(),&quot;  &quot;,/*[local-name()=&quot;project&quot;]/*[local-name()=&quot;artifactId&quot;]/text(),&quot;  &quot;,/*[local-name()=&quot;project&quot;]/*[local-name()=&quot;version&quot;]/text())&#39; pom.xml</code></li>
</ul>
</li>
</ul>
<h2 id="备份压缩"><a href="#备份压缩" class="headerlink" title="备份压缩"></a>备份压缩</h2><ul>
<li><p>压缩打包目录 “content” 至文件 “file.tar.gz”<br>  <code>tar -zcvf file.tar.gz ./content</code><br>  查阅压缩包文件 “file.tar.gz”<br>  <code>tar -ztvf file.tar.gz</code><br>  解压缩文件 “file.tar.gz”<br>  <code>tar -zxvf file.tar.gz</code><br>  <code>tar -jxvf ffmpeg-3.2.2.tar.bz2</code><br>  解压指定文件或目录<br>  <code>tar zxvf tomcat.tar.gz tomcat/conf/server.xml</code><br>  查找所有包含名称 “*.usl” 的文件并打包压缩 “usl.tar.gz” 到当前目录（保持目录结构）<br>  <code>find . -name &quot;*.usl&quot; | xargs tar zcvf usl.tar.gz</code><br>  查找当前目录及子目录下所有包含名称 *.java、 *.xml、 *.jsp 的文件，并将其打包到 p.tar 中<br>  <code>find -name &quot;*.java&quot; -o -name &#39;*.xml&#39; -o -name *.jsp | xargs tar rvf p.tar</code></p>
</li>
<li><p>使用 bzip2 压缩 messages 文本文件（/var/log/messages，即系统日志文件）为 messages.bz2<br>  <code>bzip2 messages</code><br>  使用 bzip2 解压缩 messages.bz2 文件为 messages<br>  <code>bzip2 -d messages.bz2</code></p>
</li>
<li><p>使用 gzip 解压缩 train-labels-idx1-ubyte.gz<br>  <code>gzip -d train-labels-idx1-ubyte.gz</code></p>
</li>
<li><p>将文件 “hello.txt” 添加至压缩包 “hello.zip” 中<br>  <code>zip hello.zip hello.txt</code><br>  解压缩 “hello.zip” 至当前目录下<br>  <code>unzip hello.zip</code><br>  解压缩 “arc.zip” 中的 src\hello.java 至 \tmp 目录下<br>  <code>unzip -j &quot;arc.zip&quot; src\hello.java -d \tmp</code><br>  查看 “hello.zip” 中的文件<br>  <code>unzip -v hello.zip</code><br>  将文件 “file1”、”file2” 添加至压缩包 “result.zip” 中<br>  <code>zip result.zip file1 file2</code><br>  将 “tomcat-native-1.1.34-win32-bin.zip” 中的 bin/x64 目录下的 tcnative-1.dll 解压到 $CATALINA_HOME/bin 目录下<br>  <code>unzip -j -q tomcat-native-1.1.34-win32-bin.zip &#39;bin/x64/tcnative-1.dll&#39; -d $CATALINA_HOME/bin</code></p>
</li>
<li><p>将文件（或目录） “hello.txt” 压缩至压缩包 “hello.7z” 中<br>  <code>7z a hello.7z hello.txt</code><br>  解压缩 “hello.7z” 至当前目录下<br>  <code>7z x hello.7z</code><br>  解压缩 “hello.rar” 至当前目录下<br>  <code>7z x hello.rar</code></p>
</li>
</ul>
<h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><ul>
<li><p>查看服务<br>  <code>chkconfig</code><br>  查看所有服务（ubuntu，the status is [ + ] for running services, [ - ] for stopped services and [ ? ] for services without a ‘status’ command.）<br>  <code>service --status-all</code></p>
</li>
<li><p>显示环境变量 HOME<br>  <code>echo $HOME</code><br>  设置临时环境变量(只对当前进程有效，不会传递给子进程)<br>  <code>path=jdk/bin:$&#123;PATH&#125;</code><br>  设置环境变量（变量在关闭 shell 时失效，不仅对当前进程有效，而且会传递给子进程）（export 用于 bash，setenv 用于 csh）<br>  <code>export name=value</code><br>  <code>setenv name value</code><br>  显示当前用户的变量<br>  <code>env</code><br>  显示当前 shell 的变量，包括当前用户的变量<br>  <code>set</code><br>  <code>export</code><br>  删除环境变量<br>  <code>unset name</code></p>
</li>
<li><p>添加全局的环境变量<br>  <code>echo &#39;export PATH=&quot;$PATH:/opt/jdk/bin&quot;&#39; &gt;&gt; ~/.cshrc</code><br>  添加当前用户环境变量（需要注销后才能生效）<br>  <code>echo &#39;export PATH=&quot;$PATH:/opt/jdk/bin&quot;&#39; &gt;&gt; /etc/profile</code></p>
</li>
<li><p>安装 deb 软件包 “app.deb”（Debian、Ubuntu 等 Linux 发行版的软件安装包）<br>  <code>sudo dpkg -i app.deb</code><br>  删除软件包 “app”（删除配置信息）<br>  <code>sudo dpkg -P app</code><br>  删除软件包 “app”（保留配置信息）<br>  <code>sudo dpkg -r app</code><br>  显示所有已经安装的 deb 包，同时显示版本号以及简短说明<br>  <code>dpkg -l</code></p>
</li>
<li><p>安装 rpm 软件包 “app.rpm”（Red Hat、Fedora、CentOS、SuSE 等 Linux 发行版的软件安装包）<br>  <code>sudo rpm -i app.rpm</code><br>  删除软件包 “app”（删除配置信息）<br>  <code>sudo rpm -e app</code><br>  显示所有已经安装的 deb 包，同时显示版本号以及简短说明<br>  <code>rpm -qa</code></p>
</li>
<li><p>定时任务  </p>
<pre><code class="bash"># 查询定时任务
crontab -l

# 查询定时任务，不现实注释，并将结果导出到文件 crontab.data
crontab -l | grep -v &#39;^#&#39; &gt; crontab.data

# 添加定时任务，每小时的第一分钟会发送广播 &quot;hello, world&quot;
# 格式为：minute hour day month dayofweek command
# minute: 每个小时的第几分钟执行该任务，hour: 每天的第几个小时执行该任务，day: 每月的第几天执行该任务， month: 每年的第几个月执行该任务，dayofweek: 每周的第几天执行该任务
echo &quot;1 * * * * echo \&quot;hello, world\&quot; | wall&quot; &gt;&gt; crontab.data
crontab crontab.data

# 删除当前用户下的所有定时任务  
crontab -r
</code></pre>
</li>
<li><p>查看命令别名<br>  <code>alias</code><br>  设置别名<br>  <code>alias ll=ls -l</code></p>
</li>
</ul>
<h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><ul>
<li><p>以 root 用户权限执行命令 “touch file1”<br>  <code>sudo touch file1</code><br>  切换当前用户至 root 用户<br>  <code>su</code></p>
</li>
<li><p>关机重启  </p>
<pre><code class="bash"># 重启
sudo reboot
sudo shutdown -r now
sudo shutdown -r 10 # 过 10 分钟自动重启
sudo shutdown -r 20:00 # 在时间为 20:00 时候重启
# 关机
sudo halt
sudo poweroff
sudo shutdown -h now
sudo shutdown -h 10 # 10 分钟后自动关机
sudo shutdown -h 20:00 # 在时间为 20:00 时候关机
# 注销
logout
</code></pre>
</li>
<li><p>查询当前所有登录的终端用户信息、ip<br>  <code>who</code><br>  查询当前登录的用户信息<br>  <code>who am i</code><br>  <code>whoami</code><br>  显示目前登入系统的用户信息<br>  <code>w</code></p>
</li>
<li><p>查看历史命令执行记录<br>  <code>history</code>  </p>
<blockquote>
<ul>
<li>设置历史命令执行记录的格式为 “[日期 时间][ip地址][用户名]命令”<br><code>export HISTTIMEFORMAT=&quot;[%F %T][</code>who -u am i 2&gt;/dev/null| awk ‘{print $NF}’|sed -e ‘s/[()]//g’<code>][</code>whoami<code>]&quot;</code></li>
</ul>
</blockquote>
</li>
<li><p>用户管理</p>
<pre><code class="bash"># 创建了一个用户 luffy，其中 -d 和 -m 选项用来为登录名 luffy 产生一个主目录 /home/luffy
useradd -d /home/luffy -m luffy

# 修改用户的密码
passwd luffy

# 删除用户 luffy 在系统文件（主要是 /etc/passwd，/etc/shadow，/etc/group 等）中的记录，同时 &#39;-r&#39; 删除用户的主目录 /home/luffy
userdel -r luffy

# 此命令将用户 luffy 的登录 Shell 修改为 bash，主目录改为 /home/luffy，用户组改为 developer
usermod -s /bin/bash -d /home/luffy -g developer luffy

# 查看用户 luffy 密码有效期
chage -l luffy
# 设置用户有效期无限
chage -M 99999 luffy

# 查看用户 id、组 id，其中 gid（只有一个）为当前工作组 id，groups（可能为多个）为用户所有组）
id
id luffy
# 查询用户所在组
groups
groups luffy
＃ （如果用户有多个附加组）切换当前用户的工作组为 group2
newgrp group2
＃ 修改用户所属组（主组）
usermod -g group1 luffy
＃ 修改用户所属组（附加组）
usermod -G group1,group2 luffy
</code></pre>
</li>
<li><p>赋予用户 root 权限</p>
<ul>
<li>方法 1<br>  修改 /etc/sudoers 文件，添加用户 sa 信息<br>  <code>sa    ALL=(ALL)    ALL</code><br>  保存退出，则可以用 sa 帐号登录，然后用命令 su - ，即可获得 root 权限</li>
<li>方法 2<br>  修改 /etc/sudoers 文件，添加用户组 admin 信息<br>  <code>%admin  ALL=(ALL)   ALL</code><br>  保存退出<br>  修改用户 sa，使其属于 admin 组<br>  <code>usermod -g admin sa</code><br>  则可以用 sa 帐号登录，然后用命令 <code>su</code> 或 <code>su -</code> 或 <code>su - root</code>，即可获得 root 权限</li>
<li>方法 3<br>  修改 /etc/passwd 文件，找到用户 sa 所在行，把用户 ID 修改为 0<br>  如将<br>  <code>sa:x:500:500:sa:/home/sa:/bin/bash</code><br>  修改为<br>  <code>sa:x:0:500:sa:/home/sa:/bin/bash</code><br>  保存退出，则可以用 sa 帐号登录，即可获得 root 权限</li>
</ul>
</li>
<li><p>查看磁盘空间占用情况<br>  <code>df</code><br>  <a href="http://www.cnblogs.com/yinzhengjie/p/6489374.html">查看内存占用情况</a>（默认单位为 KB，即等价于 <code>free -k</code>）<br>  <code>free</code></p>
<blockquote>
<p>以 MB 为单位显示内存使用情况<br><code>free -m</code><br>不显示包含 “-/+ buffers/cache” 的这一列，即不显示缓冲区调节列<br><code>free -t -o -m -s 1</code></p>
</blockquote>
<p>  实时显示系统中各个进程的资源占用状况<br>  <code>top</code><br>  查看网络设备（网卡、ip、子网掩码等）信息<br>  <code>ifconfig</code><br>  查看路由表（默认网关等）信息<br>  <code>route</code><br>  显示系统中所有 PCI 总线设备或连接到该总线上的所有设备<br>  （Host bridge 主板芯片，VGA compatible controller 显卡，Audio device 音频设备，PCI bridge 接口插槽，USB Controller USB 控制器，Ethernet controller 网卡）<br>  <code>lspci</code><br>  查看当前时间<br>  <code>date</code><br>  格式化输出当前时间，如20180331205217（可用于生成时间戳）<br>  <code>date +%Y%m%d%H%M%S</code>  </p>
<pre><code class="bash"># https://blog.csdn.net/myweishanli/article/details/26172887

date &#39;+%Y-%m-%d %H:%M:%S&#39; # 2018-06-20 13:17:23

date &#39;+%Y-%m-%d %H:%M:%S&#39; -d &#39;next monday&#39; # 下周一的日期
date &#39;+%Y-%m-%d %H:%M:%S&#39; -d &#39;next-day&#39; # 明天的日期
date &#39;+%Y-%m-%d %H:%M:%S&#39; -d &#39;tomorrow&#39; # 明天的日期
date &#39;+%Y-%m-%d %H:%M:%S&#39; -d &#39;last-day&#39; # 昨天的日期
date &#39;+%Y-%m-%d %H:%M:%S&#39; -d &#39;yesterday&#39; # 昨天的日期

date &#39;+%Y-%m-%d %H:%M:%S&#39; -d &#39;30 days ago&#39; # 30天前的日期
date &#39;+%Y-%m-%d %H:%M:%S&#39; -d &#39;-100 days&#39; # 100天以前的日期
date &#39;+%Y-%m-%d %H:%M:%S&#39; -d &#39;3 months&#39; # 3个月后的日期
</code></pre>
<p>  显示系统名、节点名称、操作系统的发行版号、操作系统版本、运行系统的机器 ID 号<br>  <code>uname -a</code><br>  显示当前的各种用户进程限制<br>  <code>ulimit -a</code><br>  每两秒显示一次系统资源信息（CPU、内存占用）<br>  <code>vmstat 2</code><br>  每两秒显示一次系统资源信息（CPU、内存占用），一共显示 100 次<br>  <code>vmstat 2 100</code>  </p>
</li>
<li><p>查看 $PID 进程占用的文件句柄数<br>  <code>ls -l /proc/$pid/fd | wc -l</code><br>  <del><code>ls /proc/$pid/fd | sed -n &quot;$=&quot;</code></del><br>  <del><code>lsof -n | awk &#39;&#123; print $2 &#125;&#39; | sort | uniq -c | sort -nr | more | grep $PID</code></del><br>  <del><code>lsof -p $pid | wc -l</code></del></p>
<blockquote>
<p><a href="https://www.jianshu.com/p/407c2baef92e">lsof 的错误使用场景和查看打开文件数的正确方法</a></p>
</blockquote>
</li>
<li><p><a href="http://www.cnblogs.com/xiaofeiIDO/p/6170199.html">线程和 wait、sleep 命令</a></p>
<pre><code class="bash">sleep 10 # 等待 10 秒，再继续下一操作

sleep 10 &amp; # 当前 shell 不等待，后台子 shell 等待

# wait 是用来阻塞当前进程的执行，直至指定的子进程执行结束后，才继续执行。
wait # 等待 wait 所在 bash 上的所有子进程的执行结束，如上一句的 `sleep 10 &amp;`
</code></pre>
</li>
<li><p>进程、端口查询</p>
<ul>
<li><p>查询当前系统所有进程信息<br>  <code>ps -ef</code></p>
</li>
<li><p>杀死进程</p>
<pre><code class="shell"># （推荐使用）杀死 4044 进程，&quot;-15&quot; 表示 SIGTERM 信号编码
kill -15 4044

# （不推荐使用）强制杀死 4044 进程，&quot;-9&quot; 表示 SIGKILL 信号编码
# kill -9 4044
</code></pre>
</li>
<li><p>已知端口号 8080，查询占用该端口号的进程信息（进程号）<br>  <code>netstat -anp | grep &quot;:8080&quot;</code><br>  <code>lsof -i :8080</code><br>  <code>lsof -i tcp | grep &quot;:8080&quot;</code></p>
<blockquote>
<p>netstat 中查看 tcp 状态</p>
<ul>
<li><code>LISTENING</code>: 端口处于处于侦听状态</li>
<li><code>ESTABLISHED</code>：已建立连接，即两台机器正在通信</li>
<li><code>CLOSE_WAIT</code>：对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成 CLOSE_WAIT 此时我方需要调用 close() 来使得连接正确关闭</li>
<li><code>TIME_WAIT</code>：我方主动调用 close() 断开连接，收到对方确认后状态变为 TIME_WAIT</li>
<li><code>SYN_SENT</code>：表示请求连接（当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为 SYN_SENT），如果连接成功了就变为 ESTABLISHED</li>
</ul>
</blockquote>
</li>
<li><p>已知进程号 4044，查询该进程的具体信息<br>  <code>ps 4044</code><br>  查看该进程启动的完整命令行<br>  <code>ps eho command -p 4044</code><br>  查看该进程启动时候所在的目录<br>  <code>readlink /proc/4044/cwd</code><br>  查看该进程启动时的完整环境变量<br>  <code>strings -f /proc/4044/environ | cut -f2 -d &#39; &#39;</code></p>
</li>
<li><p>已知进程号 4044，查询该进程所打开的网络连接<br>  <code>netstat -pan | grep 4044</code></p>
</li>
<li><p>查询所有 tomcat 进程并强制杀掉进程<br>  <code>ps -ef | grep tomcat | grep -v grep | awk &#39;&#123;print $2&#125;&#39; | xargs kill -s 9</code></p>
</li>
</ul>
</li>
<li><p>临时修改网卡 eth0 上第一个 ip 地址<br>  <code>ifconfig eth0 192.168.1.104</code><br>  <a href="http://blog.csdn.net/hzhsan/article/details/44677867">修改网卡 eth0 上第二个 ip 地址</a><br>  <code>ifconfig eth0:1 192.168.2.101</code><br>  配置当前主机的 ip 为 192.168.1.101，子网掩码为 255.255.255.0<br>  <code>ifconfig eth0 192.168.1.101 netmask 255.255.255.0 up</code><br>  开启/关闭网卡混杂模式<br>  <code>ifconfig eth0 promisc</code><br>  删除 eth0 上的默认路由<br>  <code>route del default eth0</code><br>  添加默认路由<br>  <code>route add default gw 192.168.1.1</code><br>  配置当前主机的默认网关为 192.168.1.1<br>  <code>route add default gw 192.168.1.1</code></p>
</li>
<li><p>查看当前主机的 mac 地址<br>  <code>ifconfig -a | grep -i hw</code></p>
</li>
<li><p>OpenSSL</p>
<ul>
<li><p>使用 OpenSSL 生成自签名证书及私钥(无 PEM pass phrase)<br>  <code>openssl req -nodes -new -x509 -keyout key.pem -out cert.crt</code><br>  <font color=grey>参数 “-nodes” 表示生成的私钥不需要加密，即无需输入无 PEM pass phrase</font></p>
</li>
<li><p><a href="http://www.cnblogs.com/xcloudbiz/articles/5523815.html">创建自签名的CA证书，及使用CA签发证书</a> </p>
<ol>
<li>创建自签名根证书密钥 ca.key、证书 ca.crt<br> <code>openssl req -new -days 3650 -x509 -keyout ca.key -out ca.crt -subj &quot;/C=CN/ST=JiangSu/L=NanJing/O=MyCompany Corp./emailAddress=admin@mycompany.com&quot;</code></li>
<li>创建服务器证书密钥 server.key<br> <code>openssl genrsa -out server.key 2048</code></li>
<li>创建服务器证书的申请文件 server.csr(Certificate Signing Request)<br> <code>openssl req -new -key server.key -out server.csr -subj &quot;/C=CN/ST=JiangSu/L=NanJing/O=MyCompany Corp./CN=127.0.0.1/emailAddress=admin@mycompany.com&quot;</code><br> <font color=grey>其中 CN(Common Name) 为 “127.0.0.1” (服务器主机名)，即 web 服务访问的域名(如 “<a href="http://www.microsoft.com&quot;),若填写不正确,浏览器会报告证书无效/">www.microsoft.com&quot;)，若填写不正确，浏览器会报告证书无效</a></font></li>
<li>使用 CA 证书签发自当前日期起有效期为期两年的服务器证书 server.crt<br> <code>openssl x509 -req -days 365 -sha256 -extensions v3_req -CA ca.crt -CAkey ca.key -CAserial ca.srl -CAcreateserial -in server.csr -out server.crt</code><br> <font color=grey>参数 “-sha256” 表示使用 sha256 签名算法，参数 “-extensions v3_req” 表示需要生成 v3 版的证书</font></li>
</ol>
</li>
<li><p>使用 OpenSSL 生成私钥文件 key.pem (2048位)<br>  <code>openssl genrsa -out key.pem 2048</code><br>  根据私钥文件生成自签名证书 cert.pem<br>  <code>openssl req -new -x509 -key key.pem -out cert.pem</code></p>
</li>
<li><p>将证书文件 server.crt 和证书密钥文件 server.key 合并成证书安装包 server.pfx<br>  <code>openssl pkcs12 -export -in server.crt -inkey server.key -out server.pfx</code></p>
</li>
<li><p>对字符串进行编码解码、加密解密</p>
<ul>
<li>对字符串 “hello, world” 进行 base64 编码<br>  <code>openssl base64 &lt;&lt;&lt; &quot;hello, world&quot;</code>  </li>
<li>对字符串 “hello, world” 进行 aes 加密，使用密钥 123，输出结果以 base64 编码格式给出<br>  <code>echo hello, world | openssl aes-128-cbc -k 123 -base64</code><br>  对以上结果进行解密处理<br>  <code>echo U2FsdGVkX18ynIbzARm15nG/JA2dhN4mtiotwD7jt4g= | openssl aes-128-cbc -d -k 123 -base64</code></li>
<li>对字符串 “hello, world” 进行 aes-128-cbc 加密，使用密钥 “123”、初始化向量 “123”<br>  <code>openssl aes-128-cbc -iv &quot;123&quot; -k &quot;123&quot; &lt;&lt;&lt; &quot;hello, world&quot;</code><br>  对字符串 “hello, world” 进行 aes-128-cbc 加密，输出结果以 base64 编码格式给出（需要手动输入密钥，如 “123”）<br>  <code>openssl aes-128-cbc &lt;&lt;&lt; &quot;hello, world&quot; | openssl base64</code><br>  对以上结果进行解密处理（需要手动输入密钥，与加密密钥一致，如 “123”）<br>  <code>openssl base64 -d &lt;&lt;&lt; &quot;U2FsdGVkX1+oPWAlmoa6dn4c5ePWw9zG8MaZ0YCblq4=&quot; | openssl aes-128-cbc -d</code></li>
</ul>
</li>
<li><p><a href="http://www.cnblogs.com/AloneSword/p/3480115.html">使用 OpenSSL 编码解码文件</a><br>  将文件 hello.txt 编码为 base64 格式，并输出到文件 hello.base64.txt 中<br>  <code>openssl base64 -in hello.txt -out hello.base64.txt</code><br>  使用 base64 解码文件 hello.base64.txt<br>  <del><code>openssl base64 -d -in hello.base64.txt -out hello.txt</code></del><br>  <code>openssl base64 -d &lt;&lt;&lt; &quot;U2FsdGVkX1+oPWAlmoa6dn4c5ePWw9zG8MaZ0YCblq4=&quot; &gt; hello.txt</code><br>  对文件 hello.txt 进行 md5 摘要计算<br>  <code>openssl md5 -in hello.txt</code></p>
</li>
<li><p>使用 AES 算法加密文件<br>  使用 aes-256-ecb 加密算法加密文件 a.txt 并输出到文件 a.ecb.txt 中<br>  <code>openssl enc -aes-256-ecb -in a.txt -out a.ecb.txt -e</code><br>  使用 aes-256-ecb 加密算法解密文件 a.ecb.txt 并输出到文件 a.ecb.d.txt 中<br>  <code>openssl enc -aes-256-ecb -in a.ecb.txt -out a.ecb.d.txt -d</code><br>  使用 aes-256-cbc 加密算法加密文件 a.bmp 并输出到文件 a.cbc.bmp 中<br>  <code>openssl enc -aes-256-cbc -in a.bmp -out a.cbc.bmp</code></p>
</li>
<li><p>使用 RSA 算法加密解密文件</p>
<ol>
<li>生成密钥的长度为 1024 位的私钥文件 pri_key.pem<br> <code>openssl genrsa -out pri_key.pem 1024</code></li>
<li>从私钥文件 pri_key.pem 中提取公钥文件 pub_key.pem<br> <code>openssl rsa -in pri_key.pem -pubout -out pub_key.pem</code></li>
<li>使用公钥文件 pub_key.pem 加密文件 a.txt<br> <code>openssl rsautl -encrypt -in a.txt -inkey pub_key.pem -pubin -out a.e.txt</code></li>
<li>使用密钥文件 pri_key.pem 解密文件 a.e.txt<br> <code>openssl rsautl -decrypt -in a.e.txt -inkey pri_key.pem -out a.d.txt</code></li>
</ol>
</li>
<li><p>证书转换、导入导出  </p>
<ul>
<li>PKCS12 转换为 PEM<ul>
<li>导出私钥<br>  <code>openssl pkcs12 -in client.p12 -passin pass:123456 -passout pass:123456 -nocerts -out client.pri.pem</code></li>
<li>导出证书<br>  <code>openssl pkcs12 -in client.p12 -passin pass:123456 -nokeys -out client.pub.pem</code></li>
</ul>
</li>
<li>PEM 转换为 PKCS12<br>  <code>openssl pkcs12 -export -in client.pub.pem -inkey client.pri.pem -out client.p12 -name client -passin pass:123456 -passout pass:123456</code></li>
<li>JKS 转换为 PKCS12<br>  <code>keytool -importkeystore -srcstoretype JKS -srckeystore client.jks -srcstorepass 123456 -srcalias client -srckeypass 123456 -deststoretype PKCS12 -destkeystore client.p12 -deststorepass 123456 -destalias client -destkeypass 123456 -noprompt</code></li>
<li>PKCS12 导出至 JKS<br>  <code>keytool -importkeystore -srckeystore client.p12 -srcstoretype PKCS12 -srcstorepass 123456 -alias client -deststorepass 123456 -destkeypass 123456 -destkeystore client.jks</code><blockquote>
<ul>
<li><a href="tomcat.md#keytool">使用 keytool 生成证书</a></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>使用 openssl 生成 alipay 商户公私钥文件（merchant_private_key_pkcs8.pem、alipay_public_key.pem）</p>
<ol>
<li>生成（商户）私钥<br> <code>openssl genrsa -out merchant_private_key.pem 2048</code></li>
<li>Java 开发者需要将私钥转换成 PKCS8 格式<br> <code>openssl pkcs8 -topk8 -inform PEM -in merchant_private_key.pem -outform PEM -nocrypt -out merchant_private_key_pkcs8.pem</code></li>
<li>生成（应用）公钥<br> <code>openssl rsa -in merchant_private_key.pem -pubout -out app_public_key.pem</code></li>
</ol>
</li>
<li><p>使用 openssl 查看网站证书信息<br>  <code>openssl s_client -showcerts -connect www.baidu.com:443 &lt; /dev/null</code></p>
</li>
<li><p><a href="https://jamielinux.com/docs/openssl-certificate-authority/">使用 openssl 生成 ca 证书、签发中间 ca 证书、签发证书</a></p>
<pre><code class="bash"># root ca certificate
openssl genrsa -out ca.key 4096
openssl req -new -x509 -days 7300 -key ca.key -subj &quot;/C=CN/ST=JS/L=NJ/O=Sunke, Inc./CN=Sunke Root CA&quot; -out ca.crt

# intermediate ca certificate
openssl req -newkey rsa:2048 -nodes -keyout intermediate.key -subj &quot;/C=CN/ST=JS/L=NJ/O=Sunke, Inc./CN=Sunke Intermediate CA&quot; -out intermediate.csr
openssl x509 -sha256 -req -extfile &lt;(printf &quot;basicConstraints=critical,CA:true&quot;) -days 3650 -in intermediate.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out intermediate.crt

# server certificate (for multiple domains or ips, change subjectAltName to: DNS:example.com,DNS:www.example.com,IP:192.168.1.100)
openssl req -newkey rsa:2048 -nodes -keyout server.key -subj &quot;/C=CN/ST=JS/L=NJ/O=Sunke, Inc./CN=www.example.com&quot; -out server.csr
#openssl x509 -sha256 -req -extfile &lt;(printf &quot;subjectAltName=DNS:www.example.com&quot;) -days 365 -in server.csr -CA intermediate.crt -CAkey intermediate.key -CAcreateserial -out server.crt
openssl x509 -sha256 -req -extfile &lt;(printf &quot;subjectAltName=DNS:www.example.com,DNS:localhost,IP:127.0.0.1,IP:192.168.1.101&quot;) -days 365 -in server.csr -CA intermediate.crt -CAkey intermediate.key -CAcreateserial -out server.crt # visit with url https://www.example.com or https://localhost or https://127.0.0.1 or https://192.168.1.101
cat server.crt intermediate.crt ca.crt &gt; server.b.crt

# deploy server.key server.b.crt
</code></pre>
</li>
<li><p>RSA 秘钥格式 PKCS#1（RSA PRIVATE KEY）与 PKCS#8（PRIVATE KEY）互转</p>
<pre><code class="bash"># 生成 PKCS#1 私钥
openssl genrsa -out private_pkcs1.pem 2048
# 生成 PKCS#8 私钥
openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:2048 -out private_pkcs8.pem

# PKCS#1 私钥转为 PKCS#8 私钥
openssl pkcs8 -topk8 -inform PEM -in private_pkcs1.pem -outform pem -nocrypt -out private_pkcs8.pem
# PKCS#8 私钥转为 PKCS#1 私钥
openssl rsa -in private_pkcs8.pem -out private_pkcs1.pem

# PKCS#1 私钥生成 PKCS#8 公钥
openssl rsa -in private_pkcs1.pem -pubout -out public_pkcs8.pem
# PKCS#8 私钥生成 PKCS#8 公钥
openssl rsa -in private_pkcs8.pem -pubout -out public_pkcs8.pem
openssl pkey -in private_pkcs8.pem -pubout -out public_pkcs8.pem

# PKCS#8 公钥转为 PKCS#1 公钥（在私钥不使用密码的情况下，公钥的 PKCS#1 和 PKCS#8 格式内容是一致的）
openssl rsa -pubin -in public_pkcs8.pem -RSAPublicKey_out -out public_pkcs1.pem
# PKCS#1 公钥转为 PKCS#8 公钥
openssl rsa -RSAPublicKey_in -in public_pkcs1.pem -RSAPublicKey_out -pubout -out public_pkcs8.pem
</code></pre>
</li>
<li><p>公钥/私钥格式处理，单行字符串转换为多行<br>  如单行公钥字符串: <code>MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDYwzcpD6YQQu3ddK147cjBZoqRupP56FJIH2Rr8ShLawh1fbmHRHbrtfKsPE7jJS6UXEI0LncqUydbVKnOt9q1Dt+W8mEXZxzArmv5NuaHI7+Rx2ehphk913bR531CPm/+nUfLQN/9JT+2MVLMRMQ5P2b3fH+8h+ndvKhHQGetXwIDAQAB</code><br>  依次按每 64 个字符末尾加换行符 <code>\n</code>，首尾分别加一行 <code>-----BEGIN PUBLIC KEY-----</code> 和 <code>-----END PUBLIC KEY-----</code>，最终结果如下</p>
<pre><code>-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNA6DCBiQKBgQCwbR2M2efjbuttNoeCjE19ZBqA
z3Q2BWxdNeQfC7v3434344OI54JB28H5DX1H44CFRgodYn6oLzI4zh3kG2XqwAOGf4
FOZlkD1nkDhlY8od4mUJvEr1XwSz+V2W0aNyONBe29NdWScMQlTxhxf15NaHHSM1l
RkiOOOhNXgLLXOXF4QID3AQAB
-----END PUBLIC KEY-----
</code></pre>
</li>
<li><p>导出网站的公钥证书<br>  <code>openssl s_client -showcerts -connect www.baidu.com:443 &lt; /dev/null 2&gt; /dev/null | openssl x509 -outform PEM &gt; www.baidu.com.pem</code></p>
</li>
<li><p>签名</p>
<pre><code class="bash"># SHA256 + RSA/PSS 签名
openssl dgst -sha256 -sign private.pem -sigopt rsa_padding_mode:pss -out sign.bin 文件名.txt

# SHA256 + RSA/PSS 验签
openssl dgst -sha256 -verify public.pem -sigopt rsa_padding_mode:pss -signature sign.bin 文件名.txt # 输出 Verified OK 代表数字签名校验成功
</code></pre>
<pre><code class="bash"># 计算 SHA256 哈希校验和
openssl dgst -sha256 -binary -out sha256sum.bin 文件名.txt

# RSA/PSS 签名
openssl pkeyutl \
    -inkey private.pem -pkeyopt rsa_padding_mode:pss -pkeyopt digest:sha256 \
    -sign -in sha256sum.bin -out sign.bin

# RSA/PSS 验签
openssl pkeyutl \
    -pkeyopt rsa_padding_mode:pss -pkeyopt digest:sha256 \
    -pubin -inkey public.pem \
    -verify -in sha256sum.bin -sigfile sign.bin
# 输出 Signature Verified Successfully 代表数字签名校验成功
</code></pre>
<pre><code class="bash"># SHA1 + RSA 签名
openssl dgst -sha1 -sign private.pem -out sign.bin 文件名.txt

# SHA1 + RSA 验签
openssl dgst -sha1 -verify public.pem -signature sign.bin 文件名.txt
</code></pre>
<pre><code class="bash"># 计算文件 SHA256 哈希值
openssl dgst -sha256 文件名.txt
</code></pre>
</li>
</ul>
</li>
<li><p>hmac sha256 签名文件</p>
<pre><code class="bash">hmac256 \
    &quot;&quot; \ # key
    hello.txt # 待签名的文件
</code></pre>
</li>
<li><p>实现 /etc/shadow 中的密钥算法（详细请参考 <code>man crypt</code>）加密密码</p>
<ul>
<li>OpenSSL passwd 只支持基于 MD5 的加密算法（”xxxxxxxx” 为盐值，”password” 为密码明文，其结果应为 “$1$xxxxxxxx$UYCIxa628.9qXjpQCjM4a.”<br>）<br>  <code>openssl passwd -1 -salt &#39;xxxxxxxx&#39; &#39;password&#39;</code></li>
<li>使用 python 的 crypt 模块可以使用所有加密算法<pre><code class="python">import crypt
assert crypt.crypt(&#39;root&#39;, &#39;$6$Sguvrc9/&#39;) == &#39;$6$Sguvrc9/$657bKmUBEpGUplcKgDhd3UOTy7r71/da6upxGkf1jvX4j22flk8av8oM8IjL2ztxk5xQDKmV3M2Ea5QfcA/6Y0&#39;
# &#39;$6$Sguvrc9/&#39; 表示使用基于 SHA-512 的加密算法和盐值 &#39;Sguvrc9/&#39;
</code></pre>
</li>
</ul>
</li>
<li><p>iptables 防火墙</p>
<ul>
<li>创建规则，将所有通过本机的源地址在 10.0.1.* 网段（网卡接口 1，如 eth0）的数据包转发到 10.0.2.* 网段（网卡接口 2，如 eth1）上，可用作网关不同网络之间的转发<br>  <code>iptables -I FORWARD -s 10.0.1.0/24 -d 10.0.2.0/24 -j ACCEPT</code><br>  参数 -D 表示删除该规则<br>  <code>iptables -D FORWARD -s 10.0.1.0/24 -d 10.0.2.0/24 -j ACCEPT</code></li>
<li>删除规则<ol>
<li>列出 INPUT 链所有规则<br> <code>iptables -L INPUT --line-numbers</code></li>
<li>删除 INPUT 链规则行号为 3 的规则<br> <code>iptables -D INPUT 3</code></li>
</ol>
</li>
<li>端口转发，将 422 端口的包转发到 22 端口<br>  <code>iptables -t nat -A PREROUTING -p tcp -d 192.168.1.37 --dport 422 -j DNAT --to 192.168.1.37:22</code></li>
</ul>
</li>
<li><p>修改主机名，如修改为 luffy</p>
<pre><code class="bash">hostname luffy
cat &gt; /etc/hostname &lt; EOF
luffy
EOF
</code></pre>
</li>
<li><p>使用 unshare 命令模拟 docker 实现各种资源隔离（基于 Linux 的 Namespace 技术）</p>
<pre><code class="bash"># 创建一个新的 namespace，该 namespace 的 uts、mount、pid 与全局资源隔离
unshare \
    --uts \ # 隔离主机名和域名
    --mount \ # 隔离挂载点
    --pid \ # 隔离进程 ID（不继承父进程 pid 命名空间，即在子进程内执行 ps，无法看到父进程原有的进程）
    --fork /bin/bash # fork 一个新的子进程，在子进程里执行 /bin/bash
</code></pre>
<blockquote>
<p>Linux 内核提供了 8 种类型的 Namespace。在这些独立的 Namespace 中，资源互不影响，相互隔离</p>
<ul>
<li>Mount/mnt 隔离挂载点</li>
<li>Process ID/pid 隔离进程 ID</li>
<li>Network/net 隔离网络设备，端口号等</li>
<li>Interprocess Communication/ipc 隔离 System V IPC 和 POSIX message queues</li>
<li>UTS Namespace/uts 隔离主机名和域名</li>
<li>User Namespace/user 隔离用户和用户组</li>
<li>Control group Namespace/cgroup 隔离 Cgroups 根目录 (4.6 版本加入)</li>
<li>Time Namespace/time 隔离系统时间 (5.6 版本加入)</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="网络通讯"><a href="#网络通讯" class="headerlink" title="网络通讯"></a>网络通讯</h2><ul>
<li><p>从网络上下载文件<br>  <code>wget http://xxx/xxx.tar.gz</code><br>  断点续传<br>  <code>wget -c http://xxx/xxx.tar.gz</code><br>  从 https 站点下载文件<br>  <code>wget https://102.alibaba.com/downloadFile.do?file=1516614343703/AliDouble11.pdf --no-check-certificate</code></p>
</li>
<li><p><a href="http://www.cnblogs.com/gbyukg/p/3326825.html">使用 curl</a> 下载单个文件，默认将输出打印到标准输出中(stdout)中<br>  <code>curl http://www.centos.org</code><br>  <code>curl -k https://www.baidu.com</code><br>  参数 “-s” 表示不显示下载进度信息<br>  <code>curl -s http://www.baidu.com</code><br>  将文件下载到本地并命名为 mygettext.html（参数 “-o” 表示将文件保存为命令行中指定的文件名的文件中）<br>  <code>curl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html</code><br>  将文件保存到本地并命名为 gettext.html（参数 “-O” 表示使用 URL 中默认的文件名保存文件到本地）<br>  <code>curl -O http://www.gnu.org/software/gettext/manual/gettext.html</code><br>  “–retry 3” 表示失败重试次数为 3 次，“–retry-delay 3” 表示失败重试间隔时间为 3 秒<br>  <code>curl -v -s -k -O http://www.gnu.org/software/gettext/manual/gettext.html --retry 3 --retry-delay 3</code><br>  通过添加 -C 选项继续对该文件进行下载，已经下载过的文件不会被重新下载（即断点续传）<br>  <code>curl -C - -O http://www.gnu.org/software/gettext/manual/gettext.html</code><br>  通过代理服务器 <a href="http://proxy.huacai.com:8080（其中认证方式为">http://proxy.huacai.com:8080（其中认证方式为</a> NTLM，用户名为 “s00123456”，密码为 “huacai@123”）访问 <a href="http://www.baidu.com/">http://www.baidu.com</a><br>  <code>curl --proxy-ntlm --proxy-user s00123456:huacai@123 --proxy http://proxy.huacai.com:8080 http://www.baidu.com</code><br>  <code>curl -k &#39;https://139.159.158.150:8443/&#39; --proxy &#39;http://10.75.203.36:5888&#39;</code><br>  参数 “-L” 表示自动跟踪 URL 重定向跳转<br>  <code>curl -k -O -s -L https://github.com/btraceio/btrace/releases/download/v1.3.11.1/btrace-bin-1.3.11.1.zip</code><br>  使用环境变量设置代理服务器  </p>
<pre><code class="bash">export http_proxy=http://10.75.203.36:5888
export https_proxy=http://10.75.203.36:5888

curl -k &#39;https://139.159.158.150:8443/&#39;
</code></pre>
<p>  上传 json 文件<br>  <code>curl http://localhost:8983/xxx --data-binary @/temp/userinfo.json -H &#39;Content-type:application/json&#39;</code><br>  <code>curl -k https://xxx -F &quot;files=@data.zip&quot; -H &quot;filename:data.zip&quot;</code><br>  上传 jpeg 文件<br>  <code>curl -F &quot;pic=@1.jpg;filename=1.jpg;type=image/jpeg&quot; -F &quot;username=zhangsan&quot; -F &quot;type=2&quot; http://127.0.0.1:8080/upload</code><br>  使用 post 方法提交 json 格式数据<br>  <del><code>curl -X POST -H &#39;Content-Type: application/json&#39; &#39;http://localhost:8983/xxx&#39; --data-binary &#39;&#123; &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;zhangsan&quot; &#125;&#39;</code></del><br>  <code>curl -X POST -H &#39;Content-Type: application/json&#39; http://localhost:8983/xxx -d &#39;&#123; &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;zhangsan&quot; &#125;&#39;</code><br>  <code>curl -X POST -H &#39;Content-Type: application/json&#39; -H &#39;userid: 0012345&#39; http://localhost:8983/xxx -d &#39;&#123; &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;zhangsan&quot; &#125;&#39;</code><br>  自定义 Locale<br>  <code>curl -H &#39;Accept-Language:zh_CN&#39; &#39;http://localhost:8983/xxx&#39;</code><br>  <code>curl -H &#39;Accept-Language:en-us;q=0.8,zh-cn&#39; http://localhost:8983/xxx</code><br>  显示消息头和消息体<br>  <code>curl -i http://www.baidu.com</code><br>  客户端证书认证<br>  <code>curl --cacert ./ca.crt --cert ./client.crt --key ./client.key https://127.0.0.1:8443</code></p>
</li>
<li><p>抓包并写入到文件 xxx.cap 中<br>  <code>tcpdump -i any port xxxx -s 0 -w xxx.cap</code><br>  抓包（直接显示 ip，不做 dns 翻译）<br>  <code>tcpdump -n</code><br>  监听本地 80 端口，抓包并写入到文件 http.cap 中（使用参数 “-s0”，指定抓包长度，防止解析时出现 “Packet size limited during capture: HTTP truncated”）<br>  <code>tcpdump port 80 -s0 -w http.cap</code><br>  抓包并写入到文件 file.pcap 中（抓取网卡 eth0 的 tcp 协议包，目的主机为 192.168.1.100:3306）<br>  <code>tcpdump -n -i eth0 tcp and host 192.168.1.100 and port 3306 -w file.pcap</code><br>  抓包并写入到文件 a.cap 中<br>  <code>tcpdump -n -w a.cap</code><br>  从文件 a.cap 中读取抓包数据<br>  <code>tcpdump -nX -r a.cap</code><br>  抓包所有与本机 1935 端口通信的数据包，并记录到 rtmp.log 中<br>  <code>tcpdump -nX port 1935 &gt; rtmp.log</code><br>  参数 -i 指定监听的网卡，如 eth、lo（可用于抓取本地包，即 127.0.0.1）<br>  <code>tcpdump -i lo port 8080</code></p>
</li>
<li><p>使用文字式网页浏览器打开网页 archive.ubuntu.com<br>  <code>w3m archive.ubuntu.com</code></p>
</li>
<li><p>发送消息/广播<br>  <code>echo &quot;hello, world&quot; | wall</code><br>  向指定用户 “root”、指定终端 “pts/9” 发送消息<br>  <code>write root pts/9</code></p>
</li>
<li><p>连接 ftp<br>  <code>sftp -o Port=20022 username@192.168.1.1</code></p>
</li>
<li><p>使用 sqlplus 连接 oracle 数据库<br>  <code>sqlplus sysdb/sys_12dagd@10.137.15.11:1526/mdspdb</code>   </p>
</li>
<li><p>使用 netcat 监听本地 3452 端口，并打印详细信息（连接发起者 ip 和端口号）<br>  <code>nc -lvnp 3452</code></p>
</li>
<li><p>使用 netcat 监听 TCP 的 3452 端口，并将镜像写入文件 cyqimage.dd<br>  <code>nc -l -p 3452 &gt; myimage.dd</code></p>
</li>
<li><p>使用 netcat 循环监听本地 80 端口，并响应 index.html 内容<br>  <code>while true; do nc -l -p 80 &lt; index.html; done</code><br>  使用 netcat 监听本地 UDP 协议的 8080 端口，其中参数 “-w1” 表示只接收一行消息，参数 “-u” 表示使用 UDP 协议<br>  <code>nc -u -w1 -l -p 8080</code><br>  使用 netcat 向本机的 8080 端口发送（一行）UDP 消息 “hello”<br>  <code>echo &quot;hello&quot; | nc -u -w1 127.0.0.1 8080</code><br>  向本机的 8080 端口发送 UDP 消息 “hello”<br>  <code>echo &quot;hello&quot; &gt; /dev/udp/localhost/8080</code></p>
</li>
<li><p><a href="http://www.linux-france.org/~mdecore/linux/doc/memo2/node168.html">使用 netcat 创建一个 TCP/HTTP 代理服务器并监听请求和响应：监听本地 80 端口并转发请求至本地 8080 端口（如 web 服务器），请求报文保存至文件 in 中，响应报文保存至文件 out 中</a></p>
<pre><code class="bash">mknod backpipe p
nc -l -p 80 &lt; backpipe | tee -a in | nc localhost 8080 | tee -a out &gt; backpipe
</code></pre>
</li>
<li><p>使用 netcat 或 telnet 建立 TCP 连接，建立连接后即可直接相互发送消息</p>
<pre><code class="bash"># 服务端监听本地端口，如 8000
nc -l -p 8000

# 方法一：客户端使用 telnet 连接服务端
telnet 127.0.0.1 8000
# 方法二：客户端使用 netcat 连接服务端
nc 127.0.0.1 8000
</code></pre>
</li>
<li><p>查询域名信息<br>  <code>whois www.baidu.com</code><br>  查询域名信息，指定端口查询<br>  <code>whois -p 80 www.baidu.com</code></p>
</li>
<li><p>查询本机公网 ip<br>  <code>curl cip.cc</code><br>  <code>curl ip.sb</code></p>
</li>
</ul>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul>
<li><p>显示当前 shell 进程号<br>  <code>echo $$</code></p>
</li>
<li><p>在命令结尾处添加 <code>&amp;</code>，表示在后台运行命令（即进程在后台运行，Control + C 不会结束该进程，关闭 bash 时结束该进程）<br>  <code>python server.py &amp;</code><br>  在命令的开头加一个 <code>nohup</code>，表示忽略所有的挂断信号，如果当前 bash 关闭，则当前进程会挂载到 init 进程下，成为其子进程，这样即使退出当前用户，命令仍然在后台运行</p>
<pre><code class="bash"># nohup python server.py &amp;

# 使用追加模式（&quot;&gt;&gt;&quot;），可方便动态清空 out 日志内容（`cat /dev/null &gt; srv.out`）。否则无非释放 out 文件磁盘空间，见 https://zhidao.baidu.com/question/1821419994894225548.html
nohup python server.py &gt;&gt; srv.out 2&gt;&amp;1 &amp;
</code></pre>
<ul>
<li>查看后台执行的程序<br>  <code>jobs</code><br>  根据 jobs 命令查询的结果，唤起后台程序，如唤起序号为 2 的后台程序<br>  <code>fg 2</code></li>
</ul>
</li>
<li><p>编译、链接</p>
<ul>
<li>自动化编译，需先切换目录至 Makefile 所在目录（即项目根目录），再执行以下命令<br>  <code>make</code></li>
<li><a href="http://blog.csdn.net/yinjiabin/article/details/7731817">使用gcc/g++编译、链接</a><ul>
<li>编译、链接当前目录下所有 “*.c” 文件，并使用用宏定义 “DEBUG” 进行条件编译，生成可执行文件 “main”<br>  <code>gcc *.c -DDEBUG -o main</code></li>
<li>编译&amp;链接为可执行文件<ul>
<li>编译、链接单个源文件 “main.c” 为可执行文件，默认生成可执行文件 “a”<br>  <code>gcc main.c</code></li>
<li>编译、链接单个源文件 “main.c” 为可执行文件，指定生成可执行文件 “main”<br>  <code>gcc main.c -o main</code><br>  “-static” 表示静态编译（即将动态库的函数和所依赖的任何的东西，都编译进本程序中，因此编译好后，文件会非常大，但是运行时不需要依赖任何动态库）<br>  <code>gcc -static main.c -o main</code></li>
<li>编译、链接多个源文件 “main.c”、”test.c”为可执行文件 “main”<br>  <code>gcc main.c test.c -o main</code></li>
</ul>
</li>
<li>编译、链接、调试<ol>
<li>编译、链接<br> <code>gcc -g main.c -o main</code></li>
<li>调试运行<br> <code>gdb main</code></li>
</ol>
</li>
<li>编译、链接、运行程序<ol>
<li>编译<br> <code>gcc -c main.c -o main.o</code></li>
<li>链接<br> <code>gcc main.o -o main</code><br> <del>将多个目标文件(“main.o”、”app.o”)链接为可执行文件 “main”<br> <code>gcc main.o app.o -o main</code></del></li>
<li>运行<br> <code>./main</code></li>
</ol>
</li>
<li><a href="http://blog.sina.com.cn/s/blog_69e96b3701010881.html">编译链接动态库、静态库并调用</a><ul>
<li>编译 “func.c” 成动态链接库文件 “libfunc.so”<br>  <code>gcc -fPIC -shared func.c -o libfunc.so</code><br>  链接 “func1.o”、”func2.o” 成动态链接库文件 “libfunc.so”<br>  <code>gcc -o libfunc.so -fPIC -shared func1.o func2.o</code></li>
<li>链接 “func1.o”、”func2.o” 成静态链接库文件 “libfunc.a”<br>  <code>ar rc libfunc.a func1.o func2.o</code></li>
<li>编译链接 “main.c”，其中 “-lfunc” 中的 “func” 是指寻找当前目录下动态连接库 “libfunc.so”（隐含的命名规则：在给出的名字前面加上 lib，后面加上.so 来确定库的名称）<br>  <code>gcc -L. -lfunc main.c -o main</code></li>
</ul>
</li>
</ul>
</li>
<li>其他<br>  生成汇编代码 hello.s<br>  <code>gcc -S hello.c</code><br>  将汇编代码 hello.s 编译成可执行文件 hello<br>  <code>gcc hello.s -o hello</code></li>
</ul>
</li>
<li><p>使用 script 录制终端会话中所有输入输出结果，并保存时序信息至文件 “record.timing”，保存命令信息至文件 “record.script”（命令行提示 “Script started, file is record.script” 后开始录制，输入 “exit” 或键入 “Ctrl + D” 后提示 “Script done, file is record.script” 结束录制）<br>  <code>script -t 2&gt; record.timing record.script</code><br>  使用 scriptreplay 重放终端会话中所有输入输出结果<br>  <code>scriptreplay record.timing record.script</code></p>
</li>
<li><p>使用 qemu 启动一个虚拟机，内存为 128 mb，镜像为 dsl.iso<br>  <code>qemu -L . -m 128 -cdrom dsl.iso -enable-audio -localtime -user-net</code>  </p>
<blockquote>
<p>使用 qemu-img 创建一个虚拟磁盘<br><code>qemu-img create -f vhdx vdisk.vhdx 1G</code></p>
</blockquote>
</li>
<li><p>执行 shell 脚本</p>
<ul>
<li><p>fork 方式（由当前进程创建一个子进程）<br>  <code>./hello.sh</code></p>
</li>
<li><p>source 方式（不另外创建子进程，而是在当前的的 Shell 环境中执行）（可用于在脚本中集中设置环境变量，如引用 hello.sh 中的定义的环境变量）<br>  <code>source ./hello.sh</code>  </p>
<blockquote>
<p>该命令通常用命令 “.” 来替代<br>如：<code>source .bash_rc</code> 与 <code>. .bash_rc</code> 是等效的</p>
</blockquote>
</li>
<li><p>exec 方式（不另外创建子进程，但是会终止当前的 shell 执行）<br>  <code>exec ./hello.sh</code></p>
</li>
</ul>
</li>
<li><p>使用 python 正则查找所有 /etc/sudoers 中引用的 shell 脚本文件，并计算各脚本文件的 md5 值<br>  <code>python -c &quot;import re; print &#39; &#39;.join(re.compile(&#39;/[^,\s]+\.sh&#39;).findall(open(&#39;/etc/sudoers&#39;).read())).replace(&#39;\&#39;&#39;, &#39;&#39;);&quot; | xargs md5sum</code></p>
</li>
<li><p>执行命令<br>  <code>eval &quot;echo hello&quot;</code><br>  <code>exec echo hello</code> # 只能在脚本中使用</p>
</li>
<li><p>生成随机数</p>
<ul>
<li>随机生成 10 个字符的字符串<br>  <code>tr -dc &#39;A-Za-z0-9!?%=&#39; &lt; /dev/urandom | head -c 10</code><br>  <code>tr -cd &#39;[:alnum:]&#39; &lt; /dev/urandom | fold -w10 | head -n1</code><br>  <font color=grey># [:alnum:] 表示匹配当前归类中的数字、大写和小写字母字符</font></li>
<li>使用 OpenSSL 随机生成 10 个字节，并将其转换为十六进制数<br>  <code>openssl rand -hex 10</code><br>  随机生成 8 个字节，并将其转换为 base64 编码<br>  <code>openssl rand -base64 8</code>  </li>
</ul>
</li>
<li><p>格式化打印到控制台<br>  <code>printf &quot;hello, %5s&quot; &quot;hello&quot;</code><br>  <code>printf &quot;\e[1;31;40mRed\e[m&quot;</code><br>  <code>echo -e &quot;\e[1;31;40mRed\e[m&quot;</code></p>
<blockquote>
<p>终端的字符颜色由转义序列（Escape Sequence）控制，是文本模式下的系统显示功能，与具体语言无关<br>通过转义序列设置终端显示属性时，可采用格式：\033[ Param {;Param;…}m 或 \e[ Param {;Param;…}m（其中，’\033[‘或’\e[‘引导转义序列，’m’表示设置属性并结束转义序列）<br>转义序列相关的常用参数如下（通过 man console_codes 命令可查看更多的参数描述）：</p>
<ul>
<li>显示：0(默认)、1(粗体/高亮)、22(非粗体)、4(单条下划线)、24(无下划线)、5(闪烁)、25(无闪烁)、7(反显、翻转前景色和背景色)、27(无反显)</li>
<li>颜色：0(黑)、1(红)、2(绿)、3(黄)、4(蓝)、5(洋红)、6(青)、7(白)<br>前景色为 30+ 颜色值，如 31 表示前景色为红色；背景色为 40+ 颜色值，如 41 表示背景色为红色。</li>
</ul>
<p>如 <code>\e[1;31;40mRed\e[m</code> 或 <code>\033[1;31;40mRed\033[m</code> 表示使用粗体、前景色为红色、背景色为黑色显示字符串 Red</p>
</blockquote>
</li>
<li><p>在 ~/.ssh 目录下生成当前用户的密钥 id_rsa、公钥 id_rsa.pub<br>  <code>ssh-keygen -t rsa</code><br>  将公钥复制(替换或追加)到远程主机的 ~/.ssh 目录下的文件 authorized_keys，则远程主机信任当前主机用户，当前主机用户无需密码，可 ssh 直接登录远程主机<br>  <code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.1.101</code></p>
  <!-- `ssh-agent bash`
  `ssh-add id_rsa` --></li>
<li><p>使用 ssh 远程登录服务器<br>  <code>ssh 192.168.1.100</code><br>  通过私钥登录 ssh 服务器<br>  <code>ssh -i ~/.ssh/id_rsa root@192.168.1.200</code><br>  使用 ssh 向远程主机发送命令（设置主机信任后，可用于自动化脚本）  </p>
<pre><code class="bash">name=$(date +%Y%m%d%H%M%S)
ssh root@192.168.1.200 &lt;&lt; &quot;EOF&quot;
mkdir ~/$&#123;name&#125;
echo &#39;hello, world&#39;
EOF
</code></pre>
<pre><code class="bash"># 自动登录远程主机 192.168.1.101，并登录该主机中的 docker 容器（参数 -t 表示强制伪终端分配，即使标准输入不是终端）
ssh -t root@192.168.1.101 &quot;docker exec -it xxxxxxxx bash&quot;
ssh -t root@192.168.1.101 &quot;docker exec -it \`docker ps | grep tomcat: | awk \&quot;&#123; print \\\\\$1 &#125;\&quot;\` /bin/bash&quot;

# 登录远程主机 192.168.1.101 并进入 /home 路径
ssh -t root@192.168.1.101 &quot;cd /home; bash&quot;

alias mysql=&#39;ssh -t root@192.168.1.101 mysql&#39;

function kubectl()
&#123;
    ssh -t root@192.168.1.101 &quot;bash -ic \&quot;kubectl $@\&quot;&quot;
&#125;

# 查看函数 kubectl 的定义
# type kubectl
</code></pre>
<p>  保持连接:每60秒发送一次空包<br>  <code>ssh -o ServerAliveInterval=60 192.168.1.100</code></p>
</li>
<li><p>判断远程主机是否信任当前主机<br>  <code>ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no root@192.168.1.101 &quot;date&quot; &amp;&amp; echo $?</code><br>  结果返回 0 则信任，否则为不信任（如 255）</p>
</li>
<li><p>使用 ssh 进行端口转发</p>
<ul>
<li>监听本地8001端口（并登录远程主机192.168.1.102），将监听的tcp报文发送至（远程主机192.168.1.102的）localhost的8080端口，可用于正向端口转发<br>  <code>ssh -L 8001:localhost:8080 root@192.168.1.102</code></li>
<li>（通过主机192.168.1.102的ssh服务）将本机192.168.1.101的80端口转发至主机192.168.1.103的8080端口<br>  <code>ssh -L 192.168.1.101:80:192.168.1.103:8080 192.168.1.102</code><br>  <del><code>ssh -L 192.168.1.101:80:192.168.1.103:8080 192.168.1.101</code></del></li>
<li>（登录远程主机192.168.1.101并）监听远程主机的8001端口，将监听的tcp报文发送至本地localhost的8080端口，可用于反向端口转发<br>  <code>ssh -R 8001:localhost:8080 192.168.1.101</code></li>
<li>监听本地8001端口，（登录远程主机192.168.1.103）并动态开启端口，将监听的tcp报文通过该端口转发至目的服务器，可用于sockets代理服务器<br>  <code>ssh -D 8001 root@192.168.1.103</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2025/03/22/mysql/</url>
    <content><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul>
<li><p>Linux</p>
<ul>
<li><del>下载安装包并离线安装<br>  <code>wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-server_5.7.20-1ubuntu14.04_amd64.deb-bundle.tar</code><br>  <code>tar -xvf mysql-server_5.7.20-1ubuntu14.04_amd64.deb-bundle.tar</code><br>  <code>dpkg -i *.deb</code></del></li>
<li>在线安装<br>  <code>apt-get install mysql-server mysql-client libmysqlclient-dev</code><br>  <font color="grey">安装过程中根据提示输入 mysql 用户中的 root 用户的密码</font><blockquote>
<ul>
<li>启动服务<ul>
<li>方法一：使用 mysqladmin 启动<br>  <code>mysqladmin start</code></li>
<li>方法二：启动服务<br>  <code>/etc/init.d/mysql start</code></li>
</ul>
</li>
<li>重启服务<ul>
<li>方法一：使用 mysqladmin 重启<br>  <code>mysqladmin restart</code></li>
<li>方法二：<span id="restart-mysqld">重启服务</span><br>  <code>/etc/init.d/mysql restart</code></li>
</ul>
</li>
<li>关闭服务<br>  <code>mysqladmin shutdown</code></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>Windows</p>
<ul>
<li>离线安装<ol>
<li>下载 <a href="https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.13-winx64.zip">mysql-8.0.13-winx64.zip</a> 并解压</li>
<li>初始化 data 目录<br> <code>./bin/mysqld --initialize-insecure</code></li>
<li>独立（非服务模式）运行<br> <code>./bin/mysqld --standalone --console</code><blockquote>
<ul>
<li>安装至系统服务<br>  <code>./bin/mysqld --install</code><ul>
<li>启动系统服务<br>  <code>net start mysql</code>    </li>
</ul>
</li>
<li>删除系统服务<br>  <code>./bin/mysqld --remove</code><br>  <del><code>./bin/mysqld --remove MySQL</code></del></li>
</ul>
</blockquote>
</li>
<li>登录/连接 mysql 控制台<br> <code>mysql -uroot</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="控制台（mysql）操作"><a href="#控制台（mysql）操作" class="headerlink" title="控制台（mysql）操作"></a>控制台（mysql）操作</h2><ol>
<li><p>登录/连接 mysql 控制台环境</p>
<ul>
<li>场景一：指定的 mysql 用户 root 已设置密码，需以密钥的方式登录<br>  <del><code>mysql -uroot -p</code></del><br>  <code>mysql -u root -p</code><br>  使用 test 用户登录远程主机 192.168.1.101（使用默认端口号 3306）的 mysql 服务<br>  <code>mysql -h 192.168.1.101 -u test -p</code><br>  根据提示输入密码，验证通过后进入 mysql 命令行控制台界面中</li>
<li>场景二：登录的 mysql 用户（root）未设置密码<br>  <code>mysql</code><blockquote>
<p>参数 “-u” 指定登录用户名称，默认使用 mysql 用户中的 root 用户</p>
</blockquote>
</li>
</ul>
</li>
<li><p>操作、命令</p>
<ul>
<li><p>执行 sql 语句（参考 <a href="#mysql-syntax">MySql 语法</a>）</p>
<pre><code class="sql">-- 显示所有数据库
show databases;

-- 打开/使用 mysql 数据库（即切换当前所使用的数据库，也可通过 use 其他数据库来直接切换当前所使用的数据库）
-- 打开之后，不指定数据库名如 &quot;select * from user;&quot; 默认使用当前打开的数据库中的表 user；也可在未打开任何数据库的情况下，直接指定数据库名如 &quot;select * from mysql.user;&quot;。）
use mysql;

-- 显示当前已打开的数据库中所有表
show tables;

-- 显示数据表 user 的结构
describe user;
-- 显示数据表 user 的列
-- show columns from user;
</code></pre>
</li>
<li><p>查询（mysql 系统）用户<br>  <code>select Host, User, Password as Pass from mysql.user;</code></p>
<blockquote>
<p>命令行中，以 <code>\G</code> 结尾，表示垂直显示查询结果，如<br><code>select top(3) * from mysql.user\G</code></p>
</blockquote>
</li>
<li><p>执行 sql 脚本 data.sql<br>  <code>source data.sql</code></p>
</li>
<li><p><a href="https://www.cnblogs.com/xh831213/archive/2012/04/10/2439886.html">将查询结果导出到文件 user.txt 中</a><br>  <code>select Host, User, Password as Pass from mysql.user into outfile &#39;./user.txt&#39;;</code>  </p>
  <!-- 导入文件  
  `load data infile './user.txt' into table table03` -->
<blockquote>
<p>若导入导出文件失败，且抛出 “ERROR 1290” 异常，解决方法见 <a href="#error-1290">导出文件时抛出异常 “ERROR 1290 (HY000): …</a><br>导出的文件见 /var/lib/mysql/user.txt</p>
</blockquote>
</li>
<li><p><a href="https://www.cnblogs.com/lvdongjie/p/6274392.html">导入导出 csv 文件</a></p>
<pre><code class="sql">-- 导出 users 表中数据至 users.csv 文件中
select * from users into outfile &#39;/tmp/users.csv&#39; fields terminated by &#39;,&#39; optionally enclosed by &#39;&quot;&#39; escaped by &#39;&quot;&#39; lines terminated by &#39;\r\n&#39;;

-- 将 users.csv 文件中数据导入到 users 表中
load data infile &#39;/tmp/users.csv&#39; into table users fields terminated by &#39;,&#39;  optionally enclosed by &#39;&quot;&#39; escaped by &#39;&quot;&#39; lines terminated by &#39;\r\n&#39;;
</code></pre>
</li>
<li><p>将 table02 中的数据备份到 table02b 中<br>  <code>create table table02b(select * from table02);</code></p>
</li>
<li><p><span id="console-status">查看当前所有连接信息</span><br>  <code>status</code><br>  查看当前所有连接进程、等待时间、所处状态、是否 locked<br>  <code>show full processlist</code></p>
</li>
</ul>
</li>
<li><p>退出控制台环境<br> <code>exit</code></p>
</li>
</ol>
<h2 id="控制台（其他）操作"><a href="#控制台（其他）操作" class="headerlink" title="控制台（其他）操作"></a>控制台（其他）操作</h2><ul>
<li>使用 mysqldump 备份还原数据库  <ul>
<li>备份数据库<br>  <code>mysqldump -u root commerce &gt; backup.sql</code></li>
<li>还原数据库<br>  <code>mysql -u root &lt; backup.sql</code></li>
</ul>
</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li><p>使用 mysqladmin 修改 mysql 用户密码<br>  <code>mysqladmin -u[用户名] -p[旧密码] password [新密码]</code></p>
</li>
<li><p>实时查看 mysql 当前连接数</p>
<ul>
<li>方法一<ul>
<li>查看当前所有连接的详细资料<br>  <code>./mysqladmin -uroot -p -h192.168.1.101 processlist</code></li>
<li>只查看当前连接数（其中 Threads 即为连接数）<br>  <code>./mysqladmin -uroot -p -h192.168.1.101 status</code></li>
</ul>
</li>
<li><a href="#console-status">方法二</a><blockquote>
<p>或直接使用 mysql 控制台执行查询连接进程信息，并导出到文件 conns.txt 中  </p>
<pre><code>`mysql -e &#39;show full processlist;&#39; &gt; conns.txt`
</code></pre>
</blockquote>
</li>
</ul>
</li>
<li><p>配置 mysql 最大连接数</p>
<ol>
<li>编辑 my.cnf（windows 环境下为 my.ini），修改如下<pre><code class="ini">max_connections = 100
</code></pre>
<!--</li>
</ol>
</li>
<li><p>mysql 历史命令记录</p>
<ul>
<li>方法一：配置 mysql 日志，记录历史执行语句<ol>
<li>编辑 my.cnf（windows 环境下为 my.ini），修改如下<pre><code class="ini">[mysqld]
log = /tmp/mysql.log
</code></pre>
</li>
<li>重启 mysql 服务</li>
</ol>
</li>
<li>方法二：~/.mysql_history 文件中记录每个用户使用数据库的操作命令<br>  <code>tail -20 ~/.mysql_history</code><blockquote>
<ul>
<li>该文件会把所有操作记录下来，包括创建用户和修改用户的明文密码。因此出于安全考虑，需禁止该功能<br><font color="grey">（该文件是 mysql 编译安装时默认配置好的，不容易修改。但是最好不要保存，仅仅删除是不行的，要直接将其软连接到垃圾箱）</font><br><code>ln -s /dev/null ~/.mysql_history</code></li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>-&gt;</p>
</li>
<li><p>在 shell 中执行 mysql 命令</p>
<pre><code class="bash">mysql -h192.168.1.102 -P3306 -uroot -p123456 testdb &lt; EOF | tee - &gt; oper.log
show tables;
EOF
</code></pre>
</li>
</ul>
<h2 id="MySql-语法"><a href="#MySql-语法" class="headerlink" title="MySql 语法"></a><span id="mysql-syntax">MySql 语法</span></h2><ul>
<li><p>DQL（数据查询语言）</p>
<ul>
<li><p>简单查询</p>
<pre><code class="sql">-- 查询
select * from users;

select id, name, sex, round(datediff(curdate(), birth)/365.2422) as age from users;
</code></pre>
</li>
<li><p>分页查询</p>
<pre><code class="sql">-- 返回 4 行，跳过前 9 条记录，即返回第 10、11、12、13 条记录
select * from users limit 9,5;
select * from users limit 4 offset 9;
</code></pre>
</li>
<li><p>其他</p>
<pre><code class="sql">-- 查找 name 字段有重复的记录
select name from users group by name having count(1) &gt; 1;
</code></pre>
</li>
</ul>
</li>
<li><p>DML（数据操纵语言）</p>
<ul>
<li><p>简单增删改</p>
<pre><code class="sql">-- 新增
insert into users(name, telephone) values(&#39;luffy&#39;, &#39;17612345678&#39;);
insert into users values(null, &#39;lina&#39;, &#39;female&#39;, &#39;1993-11-23 00:00:00&#39;, &#39;17612345679&#39;, null, now());
insert into users(name, sex, birth, telephone, address) values(&#39;Haley&#39;, &#39;female&#39;, &#39;1993-05-17&#39;, &#39;18617382659&#39;, &#39;河南开封朝阳区新华路23号&#39;);

-- 修改
update users set birth = now() where id = 1;
update users set birth = &#39;1993-11-24&#39; where name = &#39;lina&#39;;

-- 删除
delete from users where name = &#39;lina&#39;;
</code></pre>
</li>
<li><p>复杂增删改</p>
<pre><code class="sql">-- 插入一条数据，如果主键已存在，则修改该数据
insert into users(id, name, telephone) values(1, &#39;zhangsan&#39;, &#39;17612345678&#39;) on duplicate key update name = &#39;lisi&#39;, telephone = &#39;17612335679&#39;;

-- 复制数据到同一张表 users 中
insert into users(name, sex, telephone) select name, sex, telephone from users;
</code></pre>
</li>
<li><p>清空表数据</p>
<pre><code class="sql">truncate table users;
</code></pre>
</li>
<li><p><a href="https://www.cnblogs.com/luyucheng/p/6297752.html">锁</a>  </p>
<ul>
<li><p>MySQL 各存储引擎使用了三种类型（级别）的锁定机制</p>
<ul>
<li><p>表级锁定（table-level）<br>  开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。适合于以查询为主，只有少量按索引条件更新数据的应用。<br>  使用表级锁定的主要是 MyISAM、MEMORY、CSV 等一些非事务性存储引擎。</p>
</li>
<li><p>行级锁定（row-level）<br>  开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。<br>  使用行级锁定的主要是 InnoDB 存储引擎<br>  InnoDB 行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</p>
<pre><code class="sql">-- https://www.zhihu.com/tardis/sogou/art/143866444

-- 悲观锁：每次获取商品时，对该商品加排他锁。也就是在用户A获取获取 id = 1 的商品信息时对该行记录加锁，期间其他用户（查询或修改）阻塞等待直至释放锁。悲观锁适合写入频繁的场景
start transaction;
select * from goods where id = 1 for update; -- for update 仅适用于 InnoDB，且必须在事务块 BEGIN/COMMIT 中才能生效。在进行事务操作时，通过 for update 语句，MySQL 会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。
update goods set stock = stock - 1 where id = 1;
commit;

-- 乐观锁方案：每次获取商品时，不对该商品加锁。在更新数据的时候需要比较程序中的库存量与数据库中的库存量是否相等，如果相等则进行更新，反之程序重新获取库存量，再次进行比较，直到两个库存量的数值相等才进行数据更新。乐观锁适合读取频繁的场景
select * from goods where id = 1;
start transaction;
update goods set stock = stock - 1 where id = 1 and stock = cur_stock;
commit;

-- 乐观锁方案：每次获取商品时，不对该商品加锁。在更新数据的时候需要比较程序中的库存量是否充足
start transaction;
update goods set stock = stock - 1 where id = 1 and stock &gt;= 1; -- 返回成功修改行数应该为 1，否则判定失败，需要回滚
commit;
</code></pre>
</li>
<li><p>页级锁定（page-level）<br>  开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<br>  使用页级锁定的主要是 BerkeleyDB 存储引擎</p>
</li>
</ul>
</li>
<li><p>共享锁（读锁）/ 排它锁（写锁）</p>
<ul>
<li>共享锁又叫读锁，是读取操作创建的锁。其他用户可以同步读取数据，但是不能够写数据。</li>
<li>排它锁又叫写锁，是更新操作创建的锁。其他用户不可以同步读取数据更不能写数据。</li>
</ul>
</li>
<li><p>MyIsam锁模式<br>  MyIsam引擎在执行查询语句前，会自动给涉及到的表添加读锁；在更新操作前会自动给涉及到的表加写锁。</p>
<ol>
<li>对MyIsam中的表进行读取操作，其他用户可以进行读取，但是不能修改；</li>
<li>对MyIsam中的表进行更新操作，其他用户不能进行读取，更不能进行操作。</li>
</ol>
</li>
<li><p>InnoDb锁模式<br>  对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。<br>  共享锁：SELECT … LOCK IN SHARE MODE;<br>  排他锁：SELECT … FOR UPDATE; SELECT … FOR UPDATE NOWAIT;</p>
</li>
</ul>
</li>
<li><p>Hint</p>
<pre><code class="sql">-- 强制索引 FORCE INDEX 
SELECT * FROM TABLE1 FORCE INDEX (FIELD1) …
-- 以上的SQL语句只使用建立在FIELD1上的索引，而不使用其它字段上的索引。

-- 忽略索引 IGNORE INDEX 
SELECT * FROM TABLE1 IGNORE INDEX (FIELD1, FIELD2) …
-- 在上面的SQL语句中，TABLE1表中FIELD1和FIELD2上的索引不被使用。 

-- 关闭查询缓冲 SQL_NO_CACHE 
SELECT SQL_NO_CACHE field1, field2 FROM TABLE1;
-- 有一些SQL语句需要实时地查询数据，或者并不经常使用（可能一天就执行一两次）,这样就需要把缓冲关了,不管这条SQL语句是否被执行过，服务器都不会在缓冲区中查找，每次都会执行它。

-- 强制查询缓冲 SQL_CACHE
SELECT SQL_CALHE * FROM TABLE1;
-- 如果在my.ini中的query_cache_type设成2，这样只有在使用了SQL_CACHE后，才使用查询缓冲。

-- 优先操作 HIGH_PRIORITY
-- HIGH_PRIORITY可以使用在select和insert操作中，让MYSQL知道，这个操作优先进行。
SELECT HIGH_PRIORITY * FROM TABLE1;

-- 滞后操作 LOW_PRIORITY
-- LOW_PRIORITY可以使用在insert和update操作中，让mysql知道，这个操作滞后。
update LOW_PRIORITY table1 set field1= where field1= …

-- 延时插入 INSERT DELAYED
INSERT DELAYED INTO table1 set field1= …
-- INSERT DELAYED INTO，是客户端提交数据给MySQL，MySQL返回OK状态给客户端。而这是并不是已经将数据插入表，而是存储在内存里面等待排队。当mysql有空余时，再插入。另一个重要的好处是，来自许多客户端的插入被集中在一起，并被编写入一个块。这比执行许多独立的插入要快很多。坏处是，不能返回自动递增的ID，以及系统崩溃时，MySQL还没有来得及插入数据的话，这些数据将会丢失。

-- 强制连接顺序 STRAIGHT_JOIN
SELECT TABLE1.FIELD1, TABLE2.FIELD2 FROM TABLE1 STRAIGHT_JOIN TABLE2 WHERE …
-- 由上面的SQL语句可知，通过STRAIGHT_JOIN强迫MySQL按TABLE1、TABLE2的顺序连接表。如果你认为按自己的顺序比MySQL推荐的顺序进行连接的效率高的话，就可以通过STRAIGHT_JOIN来确定连接顺序。

-- 强制使用临时表 SQL_BUFFER_RESULT
SELECT SQL_BUFFER_RESULT * FROM TABLE1 WHERE … 
-- 当我们查询的结果集中的数据比较多时，可以通过SQL_BUFFER_RESULT.选项强制将结果集放到临时表中，这样就可以很快地释放MySQL的表锁（这样其它的SQL语句就可以对这些记录进行查询了），并且可以长时间地为客户端提供大记录集。
</code></pre>
</li>
</ul>
</li>
<li><p>DDL（数据定义语言）</p>
<blockquote>
<p>MySQL 的 DDL 语句是非事务的，即不能对 DLL 语句进行回滚操作</p>
</blockquote>
<ul>
<li><p>数据库管理</p>
<ul>
<li>创建数据库 commerce<br>  <code>create database commerce;</code>  </li>
<li>删除数据库 commerce<br>  <code>drop database commerce;</code></li>
</ul>
</li>
<li><p>数据表管理</p>
<ul>
<li><p>创建数据表 users</p>
<pre><code class="sql">use commerce;

-- create table users (
--     name varchar(20),
--     sex char(1),
--     birth date
-- );

create table if not exists users (
    id int not null auto_increment,
    name varchar(32) not null,
    -- age int not null,
    sex enum(&#39;male&#39;, &#39;female&#39;) not null default &#39;male&#39;,
    -- check(sex like &#39;男&#39; or sex like &#39;女&#39;), -- mysql 中 check 无效，使用 enum 替代
    birth date null,
    telephone char(11) not null,
    -- check(len(telephone) = 11),
    address varchar(255) null,
    updatetime datetime not null default now(),
    primary key(id)
    -- primary key(id, name) -- 联合主键
) engine = InnoDB default charset = utf8;
</code></pre>
<blockquote>
<p>引擎类型，多为 engine = InnoDB，如果省略了 engine = … 语句，则使用默认的引擎 MyISAM</p>
</blockquote>
</li>
<li><p>删除数据表 users<br>  <code>drop table users;</code></p>
</li>
<li><p>修改数据表</p>
<pre><code class="sql">-- 删除字段
alter table users drop telephone;

-- 添加字段
alter table users add telephone char(11);

-- 修改字段类型
-- alter table users modify telephone varchar(20);

-- 修改字段名称及类型
-- alter table users change telephone telephone2 char(14) not null;

-- 修改字段默认值
-- alter table users alter telephone set default &#39;13212345678&#39;;

-- 修改表名
-- alter table users rename to users2;
</code></pre>
</li>
</ul>
</li>
<li><p>创建索引</p>
<pre><code class="sql">-- 主键索引，一种特殊的唯一索引，不允许有空值。
alter table `users` add primary key(`id`);

-- 唯一索引，与“普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。
alter table `users` add unique(`id`);

-- 普通索引，最基本的索引，没有任何限制
alter table `users` add index index04(`id`);

-- 全文索引，仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。
alter table `users` add fulltext(`id`);

-- 组合索引，为了更多的提高 mysql 效率可建立组合索引，遵循“最左前缀”原则。
alter table `users` add index index04(`id`, `name`);
</code></pre>
</li>
<li><p>外键约束</p>
<pre><code class="sql">create table orders (
    ...
    user_id int not null,
    ...
    -- constraint constraint_name -- （可选）为外键约束定义约束名称，默认将自动生成一个名称
    foreign key fk_user(user_id) -- 指定子表（当前所在表）中引用父表中主键列的列
    references users(id) -- 指定父表及其子表中列的引用
    -- on update action -- （可选）指定在父表中的行更新时，子表中的行会怎样执行操作
    -- on delete action -- （可选）
);

alter orders drop foreign key fk_user;

alter orders add constraint constraint_name foreign key fk_user(user_id) references users(id) on update action on delete action;

-- 查看 orders 表的外键
-- show create table orders;
</code></pre>
</li>
<li><p>存储过程</p>
<pre><code class="sql">drop procedure if exists fake_users;

delimiter $$
create procedure fake_users(count int)
begin
    declare i int default 0;
    -- declare r int default 0;
    declare rand_name varchar(32);
    declare rand_sex enum(&#39;male&#39;, &#39;female&#39;);
    declare rand_date date;
    declare rand_phone char(11);

    set @charset = &#39;abcdefghijklmnopqrstuvwxyz&#39;;
    set @numberset = &#39;0123456789&#39;;

    while i &lt; count
    do
        set @j = 0;
        set rand_name = &#39;&#39;;
        while @j &lt; floor(3 + rand() * 6) -- 随机生成值为 [3, 8] 的整数（FLOOR(min + RAND() * (max – min + 1))）
        do
            set rand_name = concat(rand_name, substr(@charset, floor(rand() * length(@charset)) + 1, 1));
            set @j = @j + 1;
        end while;

        if round(rand()) = 0 then
            set rand_sex = &#39;male&#39;;
        else
            set rand_sex = &#39;female&#39;;
        end if;

        set rand_date = date_add(&#39;1990-01-01&#39;, interval floor(1 + (rand() * 3650)) day); -- 随机生成起始日期为 1990-1-1，最高 10 年的日期

        set @j = 1;
        set rand_phone = &#39;1&#39;;
        while @j &lt; 11
        do
            set rand_phone = concat(rand_phone, substring(@numberset, floor(1 + rand() * 10), 1));
            set @j = @j + 1;
        end while;

        insert into users(name, sex, birth, telephone) values(rand_name, rand_sex, rand_date, rand_phone);

        set i = i + 1;
    end while;
end
$$
delimiter ;

call fake_users(20); -- 随机生成 20 条 users 数据
</code></pre>
</li>
<li><p>触发器</p>
<ul>
<li><p>查看触发器<br>  <code>show triggers;</code></p>
</li>
<li><p>创建触发器</p>
<pre><code class="sql">drop trigger if exists `users_trigger`;

delimiter //
create trigger users_trigger before update
on users for each row
begin
    set NEW.updatetime = now(); -- 当 users 表有数据更新时，修改该记录的 updatetime 为当前时间
end //

delimiter ;
</code></pre>
<blockquote>
<p>创建触发器格式如下</p>
<pre><code class="sql">CREATE TRIGGER [触发器名] [触发时机: BEFORE|AFTER] [触发事件: INSERT|DELETE|UPDATE]
ON [表名] FOR EACH ROW
BEGIN
    [执行语句列表]
END
</code></pre>
</blockquote>
</li>
</ul>
</li>
<li><p>视图</p>
<ul>
<li><p>创建视图</p>
<pre><code class="sql">create view v_users as select id, name, sex from users;
-- create view v_users(ID, 姓名, 性别) as select id, name, sex from users;
</code></pre>
</li>
<li><p>修改、删除视图</p>
<pre><code class="sql">-- 创建视图，已存在则替换
create or replace view v_users as select id, name, sex from users;

-- 修改视图
alter view v_users as select * from users;

-- 删除视图
drop view v_users;
</code></pre>
</li>
<li><p>查看视图</p>
<pre><code class="sql">-- 查看所有视图
show table status where comment = &#39;view&#39;;

-- 查看视图 v_users
show create view v_users;
</code></pre>
</li>
<li><p>使用视图</p>
<pre><code class="sql">select * from v_users;

update v_users set name = &#39;小红&#39; WHERE id = 2;
</code></pre>
</li>
</ul>
</li>
<li><p>事务</p>
<ul>
<li><p>手动执行事务</p>
<pre><code class="sql">start transaction; -- 开启事务

...

commit;
-- rollback;
</code></pre>
</li>
<li><p>事务管理</p>
<pre><code class="sql">-- 查看当前运行的事务
select * from information_schema.innodb_trx;
-- kill [trx_mysql_thread_id]; -- 杀掉指定事务线程，其中 trx_mysql_thread_id 来自上一步查询的事务线程 id

-- 查看当前运行的事务的账户和事务开始的时间，及其事务语句
select a.id, a.user, a.host, b.trx_started, b.trx_query from information_schema.processlist a right outer join information_schema.innodb_trx b on a.id = b.trx_mysql_thread_id;
</code></pre>
</li>
<li><p>事务隔离级别设置</p>
<pre><code class="sql">-- 查看当前会话的事务隔离级别
show variables like &#39;%transaction_isolation%&#39;;

-- 设置全局事务隔离级别，事务的隔离级别有：未提交读(read uncommitted)、已提交读(read committed)、可重复读(repeatable read)、串行化(serializable)
set global transaction isolation level read committed;

-- 设置当前会话的事务隔离级别
set session transaction isolation level read committed;
</code></pre>
<blockquote>
<ul>
<li>嵌套事务：有多个 begin / commit / rollback 这样的事务块的事务，并且有父子关系。子事务的提交完成后不会真的提交，而是等到父事务提交才会真正的提交。</li>
<li>MySQL 不支持事务嵌套：已经开启事务后，再开启事务（start transaction），会隐式的提交（commit）上一个事务（即第二个 begin 语句默认会变为 commit;begin;）。可以通过部分事务（savepoint）来实现嵌套。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>锁管理</p>
<pre><code class="sql">-- 查询是否锁表
show OPEN TABLES where In_Use &gt; 0;

-- 查看所有进程
show processlist; -- MySQL
show full processlist; -- MariaDB

-- 根据查询的进程，kill 指定连接的进程
kill $pid

-- 查看正在锁的事务
select * from information_schema.innodb_locks;
select * from performance_schema.data_locks; -- MySQL 版本 ≥ 8.0.13
-- 查看等待锁的事务
select * from information_schema.innodb_lock_waits;
select * from performance_schema.data_lock_waits; -- MySQL 版本 ≥ 8.0.13

-- 查看 innodb 引擎的运行时信息
show engine innodb status\G;

-- 查看服务器状态
show status like &#39;%lock%&#39;;

-- 查看超时时间
show variables like &#39;%timeout%&#39;;
</code></pre>
</li>
<li><p>日志<br>  general_log：该日志用于记录 MySQL 中所有运行过的 SQL</p>
<pre><code class="sql">-- 查看 general_log 是否开启，及文件名
show variables like &#39;%general_log%&#39;;

-- 开启 general_log
set global general_log = 1;

-- 关闭 general_log
set global general_log = 0;
</code></pre>
</li>
</ul>
</li>
<li><p>DCL（数据控制语言）</p>
<ul>
<li><p>用户管理、授权</p>
<ul>
<li><p>添加用户</p>
<ul>
<li><p>方法一：新增一个用户 test01，允许任意远程主机可以登录，并设置其密码为 123456<br>  <code>create user &#39;test01&#39;@&#39;%&#39; identified by &#39;123456&#39;;</code></p>
<blockquote>
<p>新增用户命令的格式为<br><code>CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</code><br>其中，  </p>
<ul>
<li>username 表示将创建的用户名；</li>
<li>host 指定该用户在哪个主机上可以登录，如 “localhost” 只允许本地用户；”%” 允许任意远程主机。</li>
<li>password 表示该用户的登录密码，密码可以为空,即无需密码可以直接登录。</li>
</ul>
</blockquote>
</li>
<li><p>方法二：新增一个用户 test02，密码为 123，只允许本地访问<br>  <code>insert into mysql.user(Host, User, Password) values(&quot;localhost&quot;, &quot;test02&quot;, password(&quot;123&quot;));</code></p>
</li>
<li><p>方法三：不使用以上方法创建用户，直接<a href="#grant-user">对一个新用户授权</a></p>
</li>
</ul>
</li>
<li><p>用户授权</p>
<ol>
<li><p><span id="grant-user">授权</span><br> 授权用户 test03 拥有数据库 db01 的所有权限<br> <code>grant all privileges on db01.* to test03@localhost identified by &#39;123&#39;;</code><br> 授权用户 test03 可以在任何主机上登录，并对所有数据库的表有查询、插入、修改、删除的权限<br> <code>grant select, insert, update, delete on *.* to &quot;test03&quot; Identified by &quot;123&quot;;</code></p>
<blockquote>
<p>授权命令的格式为<br><code>GRANT privileges ON database.table TO username@host IDENTIFIED BY &quot;password&quot;;</code><br>其中，</p>
<ul>
<li>权限 privileges 可以为 select、delete、update、create、drop</li>
<li>数据库、数据表表示格式为 <code>database.table</code>，如 “<em>.</em>“ 表示所有数据库的所有表，”db01.user” 表示数据库 db01 的 user 表</li>
<li>授权的用户（如 test03）如果不存在，则会自动创建该用户</li>
</ul>
</blockquote>
</li>
<li><p><span id="flush-privileges">刷新系统权限表</span><br> <code>flush privileges;</code></p>
</li>
</ol>
</li>
<li><p>删除用户</p>
<ol>
<li>删除用户 test03<ul>
<li>方法一：<br>  <code>drop user test03@&#39;localhost&#39;;</code></li>
<li>方法二：<br>  <code>delete from user where User = &#39;test03&#39;;</code></li>
</ul>
</li>
<li><a href="#flush-privileges">刷新系统权限表</a></li>
</ol>
</li>
<li><p>修改密码<br>  设置（mysql 用户中的）root 用户的密码为 123456<br>  <code>set password for root=password(&quot;123456&quot;);</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><ul>
<li><p>远程访问连接拒绝</p>
<ul>
<li><p><span id="allow-root-remote">设置允许 mysql 用户中的 root 用户远程访问</span><br>  默认情况下，mysql 用户中的 root 用户只允许本地访问（Host 为 localhost），远程无法访问。<br>  如需要允许 root 用户远程访问，则需修改数据库 mysql 下的表 user 中相关 Host 的值为 “%”<br>  <code>mysql -u root –p</code></p>
<pre><code class="bash">use mysql;

update user set host = &#39;%&#39; where user = &#39;root&#39;;
</code></pre>
</li>
<li><p>mysql 可以用 localhost 连接，但不能用 ip 连接的问题解决方法<br>  在本机上通过 “mysql -h locathost -P 3306 -u test -p123456” 可以访问，但是通过 “mysql -h 192.168.128.137 -P 3306 -u test -p123456” 无法访问，把mysql 里面 user 表里面的 Host 设置为了 % 也没有作用，最后通过修改配置文件 /etc/mysql/my.cnf，注释掉 bind-address 所在行即可<br>  <code>sed -i &#39;s/^bind-address/#bind-address/g&#39; /etc/mysql/my.cnf</code><br>  <a href="#restart-mysqld">重启 mysql 服务</a></p>
</li>
</ul>
</li>
<li><p><span id="error-1290"><a href="http://blog.csdn.net/HHTNAN/article/details/78520511">导出文件时抛出异常 “ERROR 1290 (HY000): The MySQL server is running with the –secure-file-priv option so it cannot execute this statement”</a></span><br>  默认情况下，mysql 限制了导出文件的路径，执行以下命令查看当前 secure-file-priv 的值<br>  <code>show variables like &#39;%secure%&#39;;</code><br>  编辑配置文件 /etc/mysql/conf.d/mysql.cnf，在 “[mysqld]” 节点下添加/修改 secure-file-priv 配置项<br>  <code>echo &#39;[mysqld]&#39; &gt;&gt; /etc/mysql/conf.d/mysql.cnf</code><br>  <code>echo &#39;secure_file_priv = &quot;/&quot;&#39; &gt;&gt; /etc/mysql/conf.d/mysql.cnf</code><br>  <a href="#restart-mysqld">重启 mysql 服务</a></p>
</li>
<li><p>中文乱码<br>  查看编码格式<br>  <code>show variables like &#39;char%&#39;;</code><br>  设置编码格式<br>  <del><code>set character_set_database = utf8;</code></del><br>  <del><code>set character_set_server = utf8;</code></del><br>  <code>set names utf8</code></p>
</li>
</ul>
<h2 id="mysql-数据类型"><a href="#mysql-数据类型" class="headerlink" title="mysql 数据类型"></a><a href="http://www.cnblogs.com/JemBai/archive/2009/08/20/1550683.html">mysql 数据类型</a></h2><table>
<thead>
<tr>
<th align="left">mysql 数据类型</th>
<th align="left">说明</th>
<th align="left">java 数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean</code> 或 <code>tinyint(1)</code></td>
<td align="left">insert value：true、false</td>
<td align="left"><code>java.lang.Boolean</code></td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><details>
<summary>在 docker 中运行 mysql</summary>

<ol>
<li>启动 mysql 实例<br> <del><code>docker run --name mysql01 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:tag</code></del><br> <code>docker run --name mysql01 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql</code><blockquote>
<p>其中，<br><code>mysql01</code> 为容器别名<br><code>123456</code> 为初始化设置的 root 用户的密码<br><code>tag</code> 为 mysql 的版本，不写默认使用最新版<br><code>-p 3306:3306</code> 表示在这个容器中使用 3306 端口（第二个）映射到本机的端口号也为 3306（第一个）</p>
</blockquote>
</li>
<li>连接到 mysql 实例<ul>
<li>连接到本地 mysql<br>  <code>docker run -it --link mysql01:mysql --rm mysql sh -c &#39;exec mysql -h&quot;$MYSQL_PORT_3306_TCP_ADDR&quot; -P&quot;$MYSQL_PORT_3306_TCP_PORT&quot; -uroot -p&quot;$MYSQL_ENV_MYSQL_ROOT_PASSWORD&quot;&#39;</code></li>
<li>连接其他地方的 mysql<br>  <code>docker run -it --rm mysql mysql -hsome.mysql.host -umysql01-user -p</code></li>
</ul>
</li>
<li>切换到容器 shell 中<br> <code>docker exec -it mysql01 bash</code><br> 退出输入<br> <code>exit</code></li>
<li>查看日志<br> <code>docker logs mysql01</code></li>
</ol>
</details>

<p><a href="https://blog.csdn.net/weixin_39703170/article/details/79011704">SQL语言的分类（DQL、DML、DDL、DCL的概念与区别）</a></p>
<p><a href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2025/03/22/nginx/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><ol>
<li><p>安装依赖</p>
<pre><code class="bash"># cat &gt; /etc/apt/sources.list &lt;&lt; EOF
# deb http://cn.archive.ubuntu.com/ubuntu/ trusty main restricted
# deb http://cn.archive.ubuntu.com/ubuntu/ trusty-updates main restricted
# deb http://cn.archive.ubuntu.com/ubuntu/ trusty universe
# deb http://cn.archive.ubuntu.com/ubuntu/ trusty-updates universe
# EOF

apt-get update

apt-get -y install build-essential
apt-get -y install libpcre++-dev libssl-dev make \
    libxml2-dev libxslt-dev libgd-dev libgeoip-dev \
    libgoogle-perftools-dev libatomic-ops-dev libperl-dev
</code></pre>
</li>
<li><p>下载源码</p>
<pre><code class="bash">cd /usr/local/src

curl -O http://nginx.org/download/nginx-1.15.0.tar.gz

# 解压
tar zxvf nginx-1.15.0.tar.gz
</code></pre>
</li>
<li><p>新建 nginx 用户及用户组</p>
<pre><code class="bash">groupadd nginx
useradd -g nginx -M nginx -s /sbin/nologin
</code></pre>
</li>
<li><p>编译配置、编译、安装  </p>
<pre><code class="bash">cd /usr/local/src/nginx*

./configure --prefix=/usr/local/nginx \
    --pid-path=/usr/local/nginx/run/nginx.pid \
    --with-http_ssl_module \
    --user=nginx \
    --group=nginx \
    --with-pcre \
    --without-mail_pop3_module \
    --without-mail_imap_module \
    --without-mail_smtp_module

make
make install
</code></pre>
<blockquote>
<p>–prefix=/usr/local/nginx 指定安装到 /usr/local/nginx 目录下</p>
</blockquote>
</li>
<li><p>查看安装后的程序版本<br> <code>/usr/local/nginx/sbin/nginx -v</code></p>
</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote>
<p><a href="https://nginxconfig.io/">可视化配置并生成配置文件</a></p>
</blockquote>
<p>编辑配置文件 /usr/local/nginx/conf/nginx.conf</p>
<h3 id="标准配置"><a href="#标准配置" class="headerlink" title="标准配置"></a>标准配置</h3><pre><code class="nginx">events &#123;
    worker_connections  1024;
&#125;

http &#123;
    server &#123;
        listen      80;
        server_name localhost;
        location / &#123;
            root    html; # /usr/local/nginx/html
            index   index.html index.htm; # /usr/local/nginx/html/index.html
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>curl <a href="http://127.0.0.1/">http://127.0.0.1:80/</a></p>
</blockquote>
<h3 id="虚拟目录配置"><a href="#虚拟目录配置" class="headerlink" title="虚拟目录配置"></a><a href="https://www.cnblogs.com/kevingrace/p/6187482.html">虚拟目录配置</a></h3><pre><code class="nginx">events &#123;
    worker_connections  1024;
&#125;

http &#123;
    server &#123;
        listen      80;
        server_name localhost;
        location / &#123;
            root    html; # /usr/local/nginx/html
            index   index.html index.htm; # /usr/local/nginx/html/index.html
        &#125;

        location /hls &#123;
            types &#123;
                application/vnd.apple.mpegurl m3u8;
                video/mp2t ts;
            &#125;

            # root 响应的路径：配置的路径 + 完整访问路径(完整的 location 配置路径 + 静态文件)
            # root /usr/share/nginx/html; # &quot;/usr/share/nginx/html&quot; + &quot;/hls/oceans.m3u8&quot;
            # alias 响应的路径：配置路径 + 静态文件(去除 location 中配置的路径)
            alias /usr/share/nginx/html/hls/; # &quot;/usr/share/nginx/html/hls/&quot; + &quot;oceans.m3u8&quot;

            # expires -1;
            add_header Cache-Control no-cache;
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<ul>
<li>使用 alias 时目录名后面一定要加 “/”</li>
<li>一般情况下，在 location / 中配置 root，在 location /other 中配置 alias</li>
</ul>
</blockquote>
<h3 id="HTTPS-加密"><a href="#HTTPS-加密" class="headerlink" title="HTTPS 加密"></a>HTTPS 加密</h3><p>生成 CA 自签名证书并签发服务器证书</p>
<pre><code class="bash">cd /var/ssl

# 生成 CA 自签名证书
openssl genrsa -out ca.key 4096
openssl req -new -x509 -days 7300 -key ca.key -subj &quot;/C=CN/ST=JS/L=NJ/O=Sunke, Inc./CN=Sunke Root CA&quot; -out ca.crt

# 生成服务器证书
openssl req -newkey rsa:2048 -nodes -keyout server.key -subj &quot;/C=CN/ST=JS/L=NJ/O=Sunke, Inc./CN=localhost&quot; -out server.csr
openssl x509 -sha256 -req -extfile &lt;(printf &quot;subjectAltName=DNS:localhost,IP:127.0.0.1&quot;) -days 365 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt

cat server.crt ca.crt &gt; server.b.crt # 证书链
</code></pre>
<p>在 <code>/http</code> 节点下，配置 <code>server</code> 如下</p>
<pre><code class="nginx">server &#123;
    listen 443 ssl;
    server_name localhost;

    ssl_protocols TLSv1.2; # 支持 TLSv1.2 协议

    ssl_certificate /var/ssl/server.b.crt; # server 公钥，需使用绝对路径
    ssl_certificate_key /var/ssl/server.key; # server 私钥

    location / &#123;
        ...
    &#125;
&#125;
</code></pre>
<h3 id="HTTPS-双向认证"><a href="#HTTPS-双向认证" class="headerlink" title="HTTPS 双向认证"></a>HTTPS 双向认证</h3><p>生成客户端证书</p>
<pre><code class="bash">cd /var/ssl

openssl req -newkey rsa:2048 -nodes -keyout client.key -subj &quot;/C=CN/ST=JS/L=NJ/O=/CN=&quot; -out client.csr
openssl x509 -sha256 -req -days 365 -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt
</code></pre>
<p>在 <code>/http</code> 节点下，配置 <code>server</code> 如下</p>
<pre><code class="nginx">server &#123;
    listen 443 ssl;
    server_name localhost;

    ssl_protocols TLSv1.2; # 支持 TLSv1.2 协议

    ssl_certificate /var/ssl/server.b.crt; # server 公钥
    ssl_certificate_key /var/ssl/server.key; # server 私钥

    ssl_client_certificate /var/ssl/ca.crt; # 根级证书公钥，用于验证各个二级 client
    ssl_verify_client on;

    location / &#123;
        ...

        # proxy_set_header X-SSL-Client-Cert $ssl_client_cert; # 客户端证书内容信息
        # proxy_set_header X-SSL-serial $ssl_client_serial; # 客户端证书序列号
        # proxy_set_header cert-subject $ssl_client_s_dn; # 客户端证书 subject 信息
    &#125;
&#125;
</code></pre>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>在 <code>/http</code> 节点下，新增 <code>upstream</code> 配置如下</p>
<pre><code class="nginx">http &#123;
    upstream myproject &#123;
        server 127.0.0.1:8000 weight=3;
        server 127.0.0.1:8001;
        server 127.0.0.1:8002;
        server 127.0.0.1:8003;
        ip_hash; # 配置 ip hash，可用于解决 session 不同步的问题
    &#125;       
    server &#123;
        listen 80;
        server_name www.domain.com;
        location / &#123;
            proxy_pass http://myproject;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="双机热备"><a href="#双机热备" class="headerlink" title="双机热备"></a>双机热备</h3><p>在 <code>/http</code> 节点下，新增 <code>upstream</code> 配置如下</p>
<pre><code class="nginx">http &#123;
    upstream myserver &#123;
        server 192.168.1.101:8080;
        server 127.0.0.1:8080 backup;
    &#125;
    server &#123;
        listen 8000;
        location / &#123;
            proxy_set_header Host $http_host;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            proxy_pass http://myserver;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="配置静态内容服务器"><a href="#配置静态内容服务器" class="headerlink" title="配置静态内容服务器"></a>配置静态内容服务器</h3><p>在 <code>/http/server</code> 节点下，配置 <code>location</code> 如下</p>
<pre><code class="nginx">location / &#123;
    root   html;
    index  index.html index.htm;
&#125;
location /image/ &#123;
    root   /usr/local/myImage/;
    autoindex on;
&#125;
</code></pre>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>在 <code>/http/server</code> 节点下，配置 <code>location</code> 如下</p>
<pre><code class="nginx">location / &#123;
    proxy_pass http://127.0.0.1:8080; # 反向代理服务器的地址
    index index.html index.htm;  
&#125;
location /a &#123;
    proxy_pass http://127.0.0.1:8081;
    proxy_set_header Host $host:$proxy_port; # 区别于 add_header 只能用于新增响应消息头，proxy_set_header 用于设置 Nginx 转发至上游服务的请求消息头
&#125;
location /b &#123;
    proxy_pass http://192.168.1.102:8081/b;
    proxy_cookie_path /a /b;
&#125;

location /api &#123;
    # 代理转发
    proxy_pass http://192.168.1.101:3000/; # 如果在 proxy_pass 中的 url 后面加 /，表示绝对根路径，如 http://127.0.0.1:80/api/greeting =&gt; http://192.168.1.101:3000//greeting
    # proxy_pass http://192.168.1.101:3000; # 否则表示相对路径，把匹配的路径部分也给代理走，如 http://127.0.0.1:80/api/greeting =&gt; http://192.168.1.101:3000/api/greeting
&#125;
# location /api/ &#123;
#     proxy_pass http://192.168.1.101:3000/; # 绝对路径，如 http://127.0.0.1:80/api/greeting =&gt; http://192.168.1.101:3000/greeting
#     proxy_pass http://192.168.1.101:3000; # 相对路径，如 http://127.0.0.1:80/api/greeting =&gt; http://192.168.1.101:3000/api/greeting
#     proxy_pass http://192.168.1.101:3000/user/; # 如 http://127.0.0.1:80/api/greeting =&gt; http://192.168.1.101:3000/user/greeting
#     proxy_pass http://192.168.1.101:3000/user; # 如 http://127.0.0.1:80/api/greeting =&gt; http://192.168.1.101:3000/usergreeting
# &#125;
</code></pre>
<h4 id="修改上游服务的响应头"><a href="#修改上游服务的响应头" class="headerlink" title="修改上游服务的响应头"></a>修改上游服务的响应头</h4><pre><code class="nginx">location / &#123;
    proxy_hide_header X-Frame-Options; # Nginx 会将上游服务器的响应转发给客户端，但默认不会转发以下 HTTP 头部字段：Date、Server、X-Pad和X-Accel-*。使用 proxy_hide_header 后可以任意地指定哪些 HTTP 头部字段不能被转发。
    add_header X-Frame-Options SAMEORIGIN; # 新增响应头
    proxy_pass http://127.0.0.1:8080; # 反向代理服务器的地址  
&#125;
</code></pre>
<h3 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h3><p>在 <code>/http</code> 节点下，配置 <code>server</code> 如下</p>
<pre><code class="nginx">server &#123;
    gzip on;
    gzip_types      text/plain application/xml;
    gzip_proxied    no-cache no-store private expired auth;
    gzip_min_length 1000;
    ...
&#125;
</code></pre>
<h3 id="内容缓存"><a href="#内容缓存" class="headerlink" title="内容缓存"></a>内容缓存</h3><p>在 <code>/http</code> 节点下，配置 <code>server</code> 如下</p>
<pre><code class="nginx">server &#123;
    listen 80;
    server_name localhost;
    location ~ .*.(html|htm)$ &#123;
        # 缓存开关
        expires 24h;
        root /home/project/nginx-code;
    &#125;
&#125;
</code></pre>
<h3 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a>配置日志</h3><p>在 <code>/</code> 节点下，配置 <code>http</code> 如下</p>
<pre><code class="nginx">http &#123;
    ...
    log_format main &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;
                    &#39;$upstream_addr $upstream_response_time $request_time&#39;;

    access_log  logs/access.log  main;
    ...
&#125;
</code></pre>
<h3 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h3><p>在 <code>/http/server</code> 节点下，配置 <code>location</code> 如下</p>
<pre><code class="nginx">server &#123;
    listen 80;
    server_name localhost;
    location ~ .*.(html|htm)$ &#123;
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;
        root /home/project/nginx-code;
    &#125;
&#125;
</code></pre>
<h3 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h3><p>在 <code>/http/server</code> 节点下，配置 <code>location</code> 如下</p>
<pre><code class="nginx">location ~* \.(gif|jpg|png|swf|flv)$ &#123; # 表示对 gif、jpg、png、swf、flv 后缀的文件实行防盗链
    root html # 如果在 server &#123;...&#125; 中有设置，这里可以不设置
    valid_referers none blocked 127.0.0.1 *.nginxcn.com; # 表示对 127.0.0.1、*.nginxcn.com 这 2 个 url 进行判断
    if ($invalid_referer) &#123;
        rewrite ^/ www.nginx.cn # 如果不是指定 url 就跳转到 www.nginx.cn
        # return 403; # 或这可以直接返回 403 状态码
    &#125;
&#125;
</code></pre>
<blockquote>
<p>valid_referers 指令后面可以接 none、blocked、serevr_names、string 或正则表达式</p>
<ul>
<li>none 代表没有 referer</li>
<li>blocked 代表有 referer 但是被防火墙或者是代理给去除了</li>
<li>string 或正在表达式，用来匹配 referer</li>
</ul>
</blockquote>
<h3 id="配置使用-WebSocket"><a href="#配置使用-WebSocket" class="headerlink" title="配置使用 WebSocket"></a>配置使用 WebSocket</h3><p>在 <code>/http/server</code> 节点下，配置 <code>location</code> 如下</p>
<pre><code class="nginx">location /api/ &#123;
    proxy_pass ws://127.0.0.1:3000/;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &quot;upgrade&quot;;
&#125;
</code></pre>
<h3 id="获取自定义-cookie-和-header，设置-header"><a href="#获取自定义-cookie-和-header，设置-header" class="headerlink" title="获取自定义 cookie 和 header，设置 header"></a>获取自定义 cookie 和 header，设置 header</h3><p>在 <code>/http</code> 节点下，配置 <code>server</code> 如下</p>
<pre><code class="nginx">location /api/ &#123;
    set $token &quot;&quot;;
    if ( $http_cookie ~* &quot;X-Token=(.+?)(?=;|$)&quot; ) &#123;
        set $token $1; # 获取请求 cookie 中的 X-Token 值
    &#125;
    if ( $http_x_token != &quot;&quot; ) &#123;
        set $token $http_x_token; # 获取请求 header 中的 X-Token 值
    &#125;
    proxy_set_header X-Auth-Token $token;
    proxy_pass http://127.0.0.1:3000/;
&#125;
</code></pre>
<h3 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h3><h4 id="方法一：使用正则将子域名的请求映射到对应目录中"><a href="#方法一：使用正则将子域名的请求映射到对应目录中" class="headerlink" title="方法一：使用正则将子域名的请求映射到对应目录中"></a>方法一：使用正则将子域名的请求映射到对应目录中</h4><p>在 <code>/http/server</code> 节点下，配置如下</p>
<pre><code class="nginx">if ( $host ~* (\b(?!www\b)\w+)\.\w+\.\w+ ) &#123;
    set $subdomain /$1;
&#125;
location / &#123;
    root /home/web/public_html$subdomain; # 如 www.myserver.com 映射目录 /home/web/public_html，blog.myserver.com 映射目录 /home/web/public_htmlblog
    index index.html index.php;
&#125;
</code></pre>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>在 <code>/http</code> 节点下，配置 <code>server</code> 如下</p>
<pre><code class="nginx">server &#123;
    listen      80;
    server_name www.myserver.com myserver.com;
    location / &#123;
        root    html;
        index   index.html;
    &#125;
&#125;
server &#123;
    listen      80;
    server_name blog.myserver.com;
    location / &#123;
        root    html;
        index   index.html;
    &#125;
&#125;

# 动态配置如下
server &#123;
    listen      80;
    server_name ~$ (.*).myserver.com;
    root        $root_path;
    if ( $host ~* blog.myserver.com ) &#123;
        set root_path &#39;/home/web/public_htmlblog&#39;;
    &#125;
&#125;
</code></pre>
<p>修改 <code>/etc/hosts</code> 文件（windows 下位于 C:\Windows\System32\drivers\etc\hosts）如下</p>
<pre><code>127.0.0.1    blog.myserver.com
</code></pre>
<h3 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a><a href="https://www.jianshu.com/p/163c26766a80">安全配置</a></h3><ul>
<li><p>限制请求率<br>  <font color="grey">将 Nginx 可接受的入站请求率限制为某个适合真实用户的值。例如，根据 ip 限制每个用户每两秒钟才能访问一次页面</font></p>
<pre><code class="nginx">http &#123;
    # limit_req_zone $binary_remote_addr $uri zone=api_read:20m rate=50r/s;
    limit_req_zone $binary_remote_addr zone=one:10m rate=30r/m;

    server &#123;
        location / &#123;
            # limit_req zone=api_read burst=5;
            limit_req zone=one;
            ...
        &#125;
        ...
    &#125;
&#125;
</code></pre>
<blockquote>
<ul>
<li>limit_req_zone 配置参数：<ul>
<li><code>$binary_remote_addr</code> 表示通过 remote_addr 这个标识来做限制，”binary_” 的目的是缩写内存占用量，是限制同一客户端 ip 地址</li>
<li><code>zone=api_read:20m</code> 表示生成一个大小为 20M，名字为 api_read 的内存区域，用来存储访问的频次信息</li>
<li><code>rate=50r/s</code> 表示允许相同标识的客户端的访问频次，这里限制的是每秒 50 次，还可以有比如 30r/m 的</li>
</ul>
</li>
<li>limit_req 配置参数：<ul>
<li><code>zone=api_read</code> 设置使用哪个配置区域来做限制，与上面 limit_req_zone 里的 name 对应</li>
<li><code>burst=5</code>（可选，默认为 0），burst（英文为爆发的意思）配置是指设置一个大小为 5 的缓冲区当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内</li>
<li><code>nodelay</code>（可选），如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回 503，如果没有设置，则所有请求会等待排队</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>限制连接的数量<br>  <font color="grey">将某个客户端 ip 地址所能打开的连接数限制为真实用户的合理值。例如，限制每一个 ip 对网站打开的连接数不超过 10 个</font></p>
<pre><code class="nginx">http &#123;
    # # 按 ip 配置一个连接 zone
    # limit_conn_zone $binary_remote_addr zone=perip_conn:10m;
    
    # # 按 server 配置一个连接 zone
    # limit_conn_zone $server_name zone=perserver_conn:100m;

    limit_conn_zone $binary_remote_addr zone=addr:10m;

    server &#123;
        location / &#123;
            # # 连接数限制,每个 ip 并发请求为 2
            # limit_conn perip_conn 2;
            
            # # 服务所限制的连接数（即限制了该 server 并发连接数量）
            # limit_conn perserver_conn 1000;

            limit_conn addr 10;
            ...
        &#125;
        ...
    &#125;
&#125;
</code></pre>
</li>
<li><p>关闭慢连接<br>  <font color="grey">关闭那些一直保持打开同时写数据又特别频繁的连接，因为它们会降低服务器接受新连接的能力。Slowloris 就是这种类型的攻击。对此，可以通过 client_body_timeout 和 client_header_timeout 指令控制请求体或者请求头的超时时间，例如，通过下面的配置将等待时间控制在 5s 之内</font></p>
<pre><code class="nginx">http &#123;
    ...
    server &#123;
        client_body_timeout 5s;
        client_header_timeout 5s;
        ...
    &#125;
&#125;
</code></pre>
</li>
<li><p>设置 ip 黑名单<br>  <font color="grey">如果能识别攻击者所使用的客户端 ip 地址，那么通过 deny 指令将其屏蔽，拒绝来自这些地址的连接或请求。例如，通过下面的指令拒绝来自 123.123.123.3、123.123.123.5 的请求</font></p>
<pre><code class="nginx">http &#123;
    ...
    server &#123;
        location / &#123;
            deny 123.123.123.3;
            deny 123.123.123.5;
            ...
        &#125;
        ...
    &#125;
&#125;
</code></pre>
</li>
<li><p>设置 ip 白名单<br>  <font color="grey">如果允许访问的 ip 地址比较固定，那么通过 allow 和 deny 指令让网站或者应用程序只接受来自于某个 ip 地址或者某个 ip 地址段的请求。例如，通过下面的指令将访问限制为本地网络的一个 ip 段</font></p>
<pre><code class="nginx">http &#123;
    ...
    server &#123;
        location / &#123;
            allow 192.168.1.0/24;
            deny all;
            ...
        &#125;
        ...
    &#125;
&#125;
</code></pre>
</li>
<li><p>阻塞请求<br>  <font color="grey">通过下面的配置阻塞已识别出的 User-Agent 头的值是 foo 或者 bar 的 DDoS 攻击</font></p>
<pre><code class="nginx">http &#123;
    ...
    server &#123;
        location / &#123;
            if ($http_user_agent ~* foo|bar) &#123;
                return 403;
            &#125;
            ...
        &#125;
        ...
    &#125;
&#125;
</code></pre>
</li>
<li><p>限制对后端服务器的连接数<br>  <font color="grey">例如，通过下面的配置限制每一台后端服务器之间建立的连接数不多于 200 个</font></p>
<pre><code class="nginx">http &#123;
    ...
    upstream website &#123;
        server 192.168.100.1:80 max_conns=200;
        server 192.168.100.2:80 max_conns=200;
        queue 10 timeout=30s;
        ...
    &#125;
&#125;
</code></pre>
</li>
<li><p>连接限速<br>  <font color="grey">例如，通过下面的配置限制连接速度小于 100k</font></p>
<pre><code class="nginx">http &#123;
    ...
    server &#123;
        ...
        location / &#123;
            # 连接限速
            limit_rate 100k;
            ...
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<details>
<summary>官方完整示例</summary>

<pre><code class="nginx">user www www; # 使用的用户和组

worker_processes  2; # 指定工作衍生进程数

pid /var/run/nginx.pid; # 指定 pid 存放的路径

# 错误日志级别，可以为 [ debug | info | notice | warn | error | crit ]
error_log  /var/log/nginx.error_log  info;

events &#123;
    worker_connections   2000;  # 允许的连接数

    # use [ kqueue | epoll | /dev/poll | select | poll ];
    use kqueue; # 具体内容查看 http://wiki.codemongers.com/ 事件模型
&#125;

http &#123;

    include       conf/mime.types;
    default_type  application/octet-stream;


    log_format main      &#39;$remote_addr - $remote_user [$time_local] &#39;
                         &#39;&quot;$request&quot; $status $bytes_sent &#39;
                         &#39;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &#39;
                         &#39;&quot;$gzip_ratio&quot;&#39;;

    log_format download  &#39;$remote_addr - $remote_user [$time_local] &#39;
                         &#39;&quot;$request&quot; $status $bytes_sent &#39;
                         &#39;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &#39;
                         &#39;&quot;$http_range&quot; &quot;$sent_http_content_range&quot;&#39;;

    client_header_timeout  3m;
    client_body_timeout    3m;
    send_timeout           3m;

    client_header_buffer_size    1k;
    large_client_header_buffers  4 4k;

    gzip on;
    gzip_min_length  1100;
    gzip_buffers     4 8k;
    gzip_types       text/plain;

    output_buffers   1 32k;
    postpone_output  1460;

    sendfile         on;
    tcp_nopush       on;
    tcp_nodelay      on;
    send_lowat       12000;

    keepalive_timeout  75 20;

    #lingering_time     30;
    #lingering_timeout  10;
    #reset_timedout_connection  on;


    server &#123;
        listen        one.example.com;
        server_name   one.example.com  www.one.example.com;

        access_log   /var/log/nginx.access_log  main;

        location / &#123;
            proxy_pass         http://127.0.0.1/;
            proxy_redirect     off;

            proxy_set_header   Host             $host;
            proxy_set_header   X-Real-IP        $remote_addr;
            #proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;

            client_max_body_size       10m;
            client_body_buffer_size    128k;

            client_body_temp_path      /var/nginx/client_body_temp;

            proxy_connect_timeout      70;
            proxy_send_timeout         90;
            proxy_read_timeout         90;
            proxy_send_lowat           12000;

            proxy_buffer_size          4k;
            proxy_buffers              4 32k;
            proxy_busy_buffers_size    64k;
            proxy_temp_file_write_size 64k;

            proxy_temp_path            /var/nginx/proxy_temp;

            charset  koi8-r;
        &#125;

        error_page  404  /404.html;

        location /404.html &#123;
            root  /spool/www;
        &#125;

        location /old_stuff/ &#123;
            rewrite   ^/old_stuff/(.*)$  /new_stuff/$1  permanent;
        &#125;

        location /download/ &#123;

            valid_referers  none  blocked  server_names  *.example.com;

            if ($invalid_referer) &#123;
                #rewrite   ^/   http://www.example.com/;
                return   403;
            &#125;

            #rewrite_log  on;

            # rewrite /download/*/mp3/*.any_ext to /download/*/mp3/*.mp3
            rewrite ^/(download/.*)/mp3/(.*)\..*$
                    /$1/mp3/$2.mp3                   break;

            root         /spool/www;
            #autoindex    on;
            access_log   /var/log/nginx-download.access_log  download;
        &#125;

        location ~* \.(jpg|jpeg|gif)$ &#123;
            root         /spool/www;
            access_log   off;
            expires      30d;
        &#125;
    &#125;
&#125;
</code></pre>
</details>

<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><pre><code class="bash"># 验证配置文件是否合法
/usr/local/nginx/sbin/nginx -t

# 启动 nginx
/usr/local/nginx/sbin/nginx
# /usr/local/nginx/sbin/nginx -c ./nginx.conf

# 重启 nginx
/usr/nginx/sbin/nginx -s reload

# 停止
nginx -s stop

# 退出
nginx -s quit
</code></pre>
<h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><h3 id="nginx-启动后，js、html-可以加载，但是引用的-css-样式失效"><a href="#nginx-启动后，js、html-可以加载，但是引用的-css-样式失效" class="headerlink" title="nginx 启动后，js、html 可以加载，但是引用的 css 样式失效"></a>nginx 启动后，js、html 可以加载，但是引用的 css 样式失效</h3><ul>
<li><p>现象<br>  查看引用失效的 css 文件后发现请求头中 Accept 为 text/css，但是响应头中 Content-Type 为 text/plain</p>
</li>
<li><p>解决方案  </p>
<ol>
<li><p>在 nginx.conf 文件中 http 内增加配置 <code>include mime.types;</code> 如下</p>
<pre><code class="nginx">events &#123;
    worker_connections  1024;
&#125;

http &#123;
    include mime.types;

    server &#123;
        listen      80;
        server_name localhost;
        location / &#123;
            root    html; # /usr/local/nginx/html
            index   index.html index.htm; # /usr/local/nginx/html/index.html
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>在 /etc/nginx/mime.types 放入配置文件</p>
<pre><code>types &#123;
    text/html                                        html htm shtml;
    text/css                                         css;
    text/xml                                         xml;
    image/gif                                        gif;
    image/jpeg                                       jpeg jpg;
    application/javascript                           js;
    application/atom+xml                             atom;
    application/rss+xml                              rss;

    text/mathml                                      mml;
    text/plain                                       txt;
    text/vnd.sun.j2me.app-descriptor                 jad;
    text/vnd.wap.wml                                 wml;
    text/x-component                                 htc;

    image/png                                        png;
    image/svg+xml                                    svg svgz;
    image/tiff                                       tif tiff;
    image/vnd.wap.wbmp                               wbmp;
    image/webp                                       webp;
    image/x-icon                                     ico;
    image/x-jng                                      jng;
    image/x-ms-bmp                                   bmp;

    application/font-woff                            woff;
    application/java-archive                         jar war ear;
    application/json                                 json;
    application/mac-binhex40                         hqx;
    application/msword                               doc;
    application/pdf                                  pdf;
    application/postscript                           ps eps ai;
    application/rtf                                  rtf;
    application/vnd.apple.mpegurl                    m3u8;
    application/vnd.google-earth.kml+xml             kml;
    application/vnd.google-earth.kmz                 kmz;
    application/vnd.ms-excel                         xls;
    application/vnd.ms-fontobject                    eot;
    application/vnd.ms-powerpoint                    ppt;
    application/vnd.oasis.opendocument.graphics      odg;
    application/vnd.oasis.opendocument.presentation  odp;
    application/vnd.oasis.opendocument.spreadsheet   ods;
    application/vnd.oasis.opendocument.text          odt;
    application/vnd.openxmlformats-officedocument.presentationml.presentation
                                                    pptx;
    application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
                                                    xlsx;
    application/vnd.openxmlformats-officedocument.wordprocessingml.document
                                                    docx;
    application/vnd.wap.wmlc                         wmlc;
    application/x-7z-compressed                      7z;
    application/x-cocoa                              cco;
    application/x-java-archive-diff                  jardiff;
    application/x-java-jnlp-file                     jnlp;
    application/x-makeself                           run;
    application/x-perl                               pl pm;
    application/x-pilot                              prc pdb;
    application/x-rar-compressed                     rar;
    application/x-redhat-package-manager             rpm;
    application/x-sea                                sea;
    application/x-shockwave-flash                    swf;
    application/x-stuffit                            sit;
    application/x-tcl                                tcl tk;
    application/x-x509-ca-cert                       der pem crt;
    application/x-xpinstall                          xpi;
    application/xhtml+xml                            xhtml;
    application/xspf+xml                             xspf;
    application/zip                                  zip;

    application/octet-stream                         bin exe dll;
    application/octet-stream                         deb;
    application/octet-stream                         dmg;
    application/octet-stream                         iso img;
    application/octet-stream                         msi msp msm;

    audio/midi                                       mid midi kar;
    audio/mpeg                                       mp3;
    audio/ogg                                        ogg;
    audio/x-m4a                                      m4a;
    audio/x-realaudio                                ra;

    video/3gpp                                       3gpp 3gp;
    video/mp2t                                       ts;
    video/mp4                                        mp4;
    video/mpeg                                       mpeg mpg;
    video/quicktime                                  mov;
    video/webm                                       webm;
    video/x-flv                                      flv;
    video/x-m4v                                      m4v;
    video/x-mng                                      mng;
    video/x-ms-asf                                   asx asf;
    video/x-ms-wmv                                   wmv;
    video/x-msvideo                                  avi;
&#125;
</code></pre>
</li>
<li><p>重启 nginx</p>
</li>
</ol>
</li>
</ul>
<h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><details>
<summary>使用 nginx-rtmp-module 搭建流媒体服务器</summary>

<ol>
<li><p>下载 nginx-rtmp-module  </p>
<pre><code class="bash"># apt-get -y install git

git clone https://github.com/arut/nginx-rtmp-module.git /usr/local/src/nginx-rtmp-module
</code></pre>
</li>
<li><p>安装 nginx</p>
<pre><code class="bash"># apt-get install openssl openssl-devel

# cd /usr/local/src
# curl -O http://nginx.org/download/nginx-1.15.0.tar.gz
# tar -zxvf nginx-1.15.0.tar.gz

cd /usr/local/src/nginx-1.15.0

make clean

./configure --prefix=/usr/local/nginx \
            --add-module=../nginx-rtmp-module \
            --with-http_ssl_module

make &amp;&amp; make install

mkdir -p /usr/share/nginx/html/hls
mkdir -p /usr/share/nginx/html/vod
</code></pre>
<blockquote>
<p>查看 nginx 版本、编译参数信息 <code>/usr/local/nginx/sbin/nginx -V</code></p>
</blockquote>
</li>
<li><p>修改 nginx 配置文件<br> <code>vi /usr/local/nginx/conf/nginx.conf</code><br> 添加 rtmp 配置如下</p>
<pre><code class="nginx">events &#123;
    worker_connections  1024;
&#125;

http &#123;
    server &#123;
        listen      80;
        server_name localhost;
        
        location / &#123;
            root    html; # /usr/local/nginx/html
            index   index.html index.htm; # /usr/local/nginx/html/index.html
        &#125;
    &#125;
&#125;

rtmp &#123;
    server &#123;
        listen 1935; # 监听的端口
        chunk_size 4096;

        application live &#123; # rtmp 推流请求路径
            live on; # 开启 rtmp 直播
        &#125;

        application vod &#123;
            play /usr/share/nginx/html/vod; # 视频文件如 oceans.mp4 存放路径
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>启动 nginx<br> <del><code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code></del><br> <code>/usr/local/nginx/sbin/nginx</code></p>
</li>
<li><p><span id="streaming">推流</span>  </p>
<pre><code class="bash">ffmpeg -re -i oceans.mp4 -c copy -f flv rtmp://127.0.0.1:1935/live/oceans
</code></pre>
</li>
<li><p>播放  </p>
<pre><code class="bash">ffplay rtmp://127.0.0.1:1935/live/oceans

ffplay rtmp://127.0.0.1:1935/vod/oceans.mp4 # /usr/share/nginx/html/vod/oceans.mp4
</code></pre>
</li>
</ol>
<ul>
<li><p>搭建 hls 直播</p>
<ol>
<li><p>修改 nginx 配置文件<br> <code>vi /usr/local/nginx/conf/nginx.conf</code><br> 配置 nginx.conf 如下</p>
<pre><code class="nginx">user root;

events &#123;
    worker_connections  1024;
&#125;

http &#123;
    server &#123;
        listen      80;
        server_name localhost;
        
        location / &#123;
            root    html; # /usr/local/nginx/html
            index   index.html index.htm; # /usr/local/nginx/html/index.html
        &#125;

        location /hls &#123;
            types &#123;
                application/vnd.apple.mpegurl m3u8;
                video/mp2t ts;
            &#125;

            alias /usr/share/nginx/html/hls/; # &quot;/usr/share/nginx/html/hls/&quot; + &quot;oceans.m3u8&quot;

            # expires -1;
            add_header Cache-Control no-cache;

            # valid_referers blocked 127.0.0.1 192.168.56.5; # 开启防盗链功能，只允许本站（192.168.56.5）网页上访问
            # if ($invalid_referer) &#123;
            #     return 403;
            # &#125;
        &#125;
    &#125;
&#125;

rtmp &#123;
    server &#123;
        listen 1935; # 监听的端口
        chunk_size 4096;

        application live &#123; # rtmp 推流请求路径
            live on; # 开启 rtmp 直播

            hls on; # 开启 hls 直播
            hls_path /usr/share/nginx/html/hls; # hls 的 m3u8 文件保存路径
            hls_fragment 5s; # 切片长度

            hls_cleanup off; # 关闭自动清理 m3u8、ts 文件功能，默认为开启 on
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>创建 live.html<br> <code>vi /usr/local/nginx/html/live.html</code><br> 编辑 live.html 如下</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;live&lt;/title&gt;
        &lt;!-- PC 端不支持播放 m3u8 格式，需要引入 video.js --&gt;
        &lt;link href=&quot;https://unpkg.com/video.js/dist/video-js.css&quot; rel=&quot;stylesheet&quot;&gt;
        &lt;script src=&quot;https://unpkg.com/video.js/dist/video.js&quot;&gt;&lt;/script&gt;
        &lt;script src=&quot;https://unpkg.com/videojs-contrib-hls/dist/videojs-contrib-hls.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;video id=&quot;video&quot; class=&quot;video-js vjs-default-skin fillWidth&quot; controls width=&quot;800&quot; height=&quot;480&quot; data-setup=&#39;&#123;&#125;&#39;&gt;
            &lt;source id=&quot;source&quot; type=&quot;application/x-mpegURL&quot; /&gt;
            &lt;p&gt;Your browser does not support HTML5 video.&lt;/p&gt;
        &lt;/video&gt;

        &lt;script type=&quot;text/javascript&quot;&gt;
            var m = window.location.href.match(/#(.+)$/);
            if(null != m) &#123;
                var name = m[1];

                document.getElementById(&quot;source&quot;).src = &quot;/hls/&quot; + name + &quot;.m3u8&quot;
                document.getElementById(&quot;video&quot;).load();
                document.title = &quot;Live - &quot; + name;
            &#125;
        &lt;/script&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre>
<blockquote>
<p>在 html5 中播放（需开启 hls 直播）</p>
<pre><code class="html">&lt;video&gt;
    &lt;source src=&quot;http://127.0.0.1:80/hls/oceans.m3u8&quot;/&gt;
    &lt;p&gt;Your browser does not support HTML5 video.&lt;/p&gt;
&lt;/video&gt;
</code></pre>
</blockquote>
</li>
<li><p>重启 nginx<br> <code>/usr/local/nginx/sbin/nginx -s reload</code></p>
</li>
<li><p><a href="#streaming">推流</a></p>
</li>
<li><p>播放<br> <code>ffplay http://127.0.0.1:80/hls/oceans.m3u8</code></p>
</li>
<li><p>访问 <a href="http://127.0.0.1/live.html#oceans">http://127.0.0.1/live.html#oceans</a></p>
</li>
</ol>
</li>
</ul>
</details>]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs</title>
    <url>/2025/03/22/nodejs/</url>
    <content><![CDATA[<h1 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ul>
<li><p>使用仓库安装<br>  <code>apt-get install nodejs</code></p>
</li>
<li><p>从官网下载安装</p>
<ol>
<li>下载并解压<br> <code>cd /opt</code><br> <code>curl -O https://nodejs.org/dist/v16.15.0/node-v16.15.0-linux-x64.tar.xz</code><br> <code>tar -xvf node-v16.15.0-linux-x64.tar.xz</code></li>
<li>设置环境变量  <ul>
<li>设置全局环境变量<br>  <code>echo &#39;export PATH=&quot;$PATH:/opt/node-v16.15.0-linux-x64/bin&quot;&#39; &gt;&gt; /etc/profile</code></li>
<li><del>设置临时环境变量<br>  <code>export PATH=&quot;$PATH:/opt/node-v16.5.0-linux-x64/bin&quot;</code></del></li>
</ul>
</li>
<li>注销并重新登录后即可生效<br> <code>logout</code></li>
<li>安装coffee script（可选）<br> <code>npm install -g coffee-script</code></li>
</ol>
</li>
</ul>
<h2 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h2><ul>
<li><p>cnpm（使用国内淘宝源，速度较快）</p>
<ul>
<li>安装 cnpm<br>  <code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></li>
<li>使用 cnpm 代替 npm，如<br>  <code>cnpm install -g typescript</code></li>
</ul>
</li>
<li><p>yarn</p>
<ul>
<li>安装<br>  <code>npm install -g yarn</code></li>
<li>配置淘宝源，用于加速<br>  <code>yarn config set registry &#39;https://registry.npm.taobao.org&#39;</code></li>
</ul>
</li>
<li><p>npm</p>
<ul>
<li><p>配置</p>
<ul>
<li><p>通过 config 命令</p>
<ul>
<li>查看当前配置内容<br>  <del><code>npm config ls</code></del><br>  <code>npm config list</code></li>
<li>设置远程仓库地址（使用 taobao 源镜像加速）<br>  <code>npm config set registry https://registry.npm.taobao.org</code></li>
<li>设置 npm 安装 package 的全局 node_modules 路径<br>  <code>npm config set prefix &quot;E:\nodejs&quot;</code></li>
<li>设置代理服务器<br>  <code>npm config set proxy http://username:password@server:port</code><br>  <code>npm config set https-proxy http://username:password@server:port</code></li>
<li>设置不校验 SSL 证书<br>  <code>npm config set strict-ssl false</code></li>
</ul>
</li>
<li><p>通过编辑配置文件 ~/.npmrc（或 nodejs 安装目录下的 node_modules/npm/.npmrc 或 node_modules/npm/npmrc 文件）</p>
<pre><code># 设置远程仓库地址
# registry = https://registry.npm.taobao.org

# 设置 npm 安装 package 的全局 node_modules 路径
prefix = E:\nodejs
</code></pre>
</li>
</ul>
</li>
<li><p>从 npm 默认远程仓库下载安装 uglify-js 到全局 node_modules 路径下（参数 “-g” 表示下载到全局 node_modules 路径下并安装到 node_modules 的上一级目录，这里即 nodejs 安装目录下）<br>  <code>npm install uglify-js -g</code></p>
<blockquote>
<p>从 npm 默认远程仓库下载安装 uglify-js 到当前路径下的 node_modules 目录中<br><code>npm install uglify-js</code><br>从 npm 远程仓库 “–registry <a href="https://registry.npm.taobao.org&quot;/">https://registry.npm.taobao.org&quot;</a> 下载安装 uglify-js<br><code>npm install uglify-js --registry https://registry.npm.taobao.org</code></p>
</blockquote>
</li>
<li><p>在当前目录下，初始化一个 node 工程<br>  <code>npm init</code></p>
</li>
<li><p>安装依赖（package.json 中定义的依赖）<br>  <code>npm install</code><br>  安装 <a href="http://www.expressjs.com.cn/">express</a> 并将依赖添加至 package.json 中<br>  <code>npm install express --save</code></p>
</li>
<li><p>自定义运行</p>
<ol>
<li>编辑 package.json 如下<pre><code class="json">&quot;scripts&quot;: &#123;
    &quot;start&quot;: &quot;electron .&quot;
&#125;
</code></pre>
</li>
<li>运行上一步骤中的 start 命令<br> <code>npm run start</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="第三方-nodejs-应用"><a href="#第三方-nodejs-应用" class="headerlink" title="第三方 nodejs 应用"></a>第三方 nodejs 应用</h2><ul>
<li><p>快速搭建本地 http 服务器</p>
<pre><code class="bash"># 安装
npm i -g http-server

# 在当前目录下启动 http 服务器
http-server .

# 在当前目录下启动 https 服务器
http-server \
    -p 443 \ # 要使用的端口（默认为8080）
    -S \ # 启用 https
    -C server.crt \ # 证书文件的路径（默认值：cert.pem）
    -K server.key \ # 密钥文件的路径（默认值：key.pem）
    --cors \ # 通过 Access-Control-Allow-Origin 标题启用 CORS
    .
</code></pre>
</li>
<li><p>使用 uglify-js 压缩 js 文件</p>
<ol>
<li>安装 uglify-js<br> <code>npm install -g uglify-js</code></li>
<li><del>压缩 js 文件 template.js 并将结果打印到控制台<br> <code>uglifyjs template.js</code></del><br> 使用 uglify-js 高度压缩（混淆变量名）js 文件 template.js，并保存到 文件 template.min.js 中<br> <code>uglifyjs -m toplevel template.js -o template.min.js</code></li>
</ol>
</li>
<li><p><a href="typescript.md#install">typescript</a></p>
</li>
<li><p>gitbook</p>
<ol>
<li>安装 gitbook<br> <code>npm install -g gitbook-cli</code></li>
<li>在当前目录下，初始化一个 gitbook 工程<br> <code>gitbook init</code></li>
<li>构建<br> <del><code>gitbook build</code></del><br> <code>gitbook build --gitbook=2.6.7</code>  <blockquote>
<p>2.6.7 版本支持离线 html 跳转链接</p>
</blockquote>
</li>
<li>运行服务<br> <code>gitbook serve</code><br> 浏览器中访问 <a href="http://127.0.0.1:4000/">http://127.0.0.1:4000/</a> 即可浏览</li>
</ol>
</li>
<li><p>docsify</p>
<ol>
<li>安装 docsify<br> <code>npm install -g docsify-cli</code></li>
<li>在当前目录下，初始化一个工程<br> <code>docsify init .</code></li>
<li>运行服务<br> <code>docsify serve .</code><br> 浏览器中访问 <a href="http://127.0.0.1:3000/">http://127.0.0.1:3000/</a> 即可浏览</li>
</ol>
</li>
<li><p><a href="https://github.com/iizukanao/node-rtsp-rtmp-server">node-rtsp-rtmp-server(RTSP/RTMP/HTTP hybrid server)</a>  </p>
<ol>
<li>下载源码<br> <code>git clone https://github.com/iizukanao/node-rtsp-rtmp-server.git</code></li>
<li>安装依赖（需要nodejs版本 &gt;= 0.12）<br> <code>cd node-rtsp-rtmp-server</code><br> <code>npm install -d</code></li>
<li>安装 coffeescript<br> <code>npm install -g coffeescript</code></li>
<li>运行服务（服务配置见config.coffee）  <ul>
<li>直接使用coffee运行<br>  <code>coffee server.coffee</code>  </li>
<li><del>使用coffee编译后，使用nodejs运行<br>  <code>coffee -c .</code><br>  <code>node server.js</code></del></li>
</ul>
</li>
<li>访问（192.168.1.200为服务器ip，80端口和1935端口号配置见config.coffee）<ul>
<li>点播  <ol>
<li>复制媒体文件video.mp4到file目录下  </li>
<li>访问<br> rtsp://192.168.1.200:80/file/video.mp4<br> rtmp://192.168.1.200/file/mp4:video.mp4</li>
</ol>
</li>
<li>直播<ol>
<li>使用ffmpeg推流<br> <code>ffmpeg -re -i input.mp4 -c:v copy -c:a copy -f rtsp rtsp://192.168.1.200:80/live/video</code><br> <code>ffmpeg -re -i video.mp4 -c:v copy -c:a copy -f flv rtmp://192.168.1.200/live/video</code></li>
<li>访问<br> rtsp://192.168.1.200:80/live/video<br> rtmp://192.168.1.200/live/video</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p><a href="https://github.com/swagger-api/swagger-editor">swagger-editor</a></p>
</li>
<li><p><a href="https://github.com/electron/electron">electron</a></p>
<ul>
<li>运行当前目录下的工程<br>  <code>electron .</code></li>
</ul>
</li>
<li><p>electron-packager</p>
<ul>
<li>打包成可执行程序<br>  <code>electron-packager . electron-quick-start</code></li>
</ul>
</li>
<li><p>grunt<br>  <code>npm install -g grunt grunt-electron-installer</code></p>
<ul>
<li><p>构建安装程序</p>
<ol>
<li><p>在项目根目录下（即与 package.json 同级目录下），新建 Gruntfile.js 文件如下</p>
<pre><code class="javascript">var grunt = require(&quot;grunt&quot;);
grunt.config.init(&#123;
    pkg: grunt.file.readJSON(&quot;package.json&quot;),
    &quot;create-windows-installer&quot;: &#123;
        x64: &#123;
            appDirectory: &quot;./electron-quick-start-win32-x64&quot;,
            authors: &quot;no one&quot;,
            exe: &quot;electron-quick-start.exe&quot;,
            description:&quot;electron-quick-start&quot;,
        &#125;       
    &#125;
&#125;)

grunt.loadNpmTasks(&quot;grunt-electron-installer&quot;);
grunt.registerTask(&quot;default&quot;, [&quot;create-windows-installer&quot;]);
</code></pre>
</li>
<li><p>执行命令<br> <code>grunt</code></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>使用 zan-proxy 代理服务器</p>
<pre><code class="bash">npm install zan-proxy -g
zan-proxy --no-update
</code></pre>
</li>
<li><p>使用 whistle 代理服务器，浏览器可搭配使用 SwitchyOmega</p>
<pre><code class="bash">npm install whistle -g
w2 start
</code></pre>
</li>
<li><p>使用 marp-cli 转换 markdown 为 ppt/pdf</p>
<pre><code class="bash">npm install -g @marp-team/marp-cli

marp-cli readme.md
marp-cli readme.md -o readme.pptx

marp-cli -p --server .
</code></pre>
</li>
<li><p>增强 shell 脚本工具 <a href="https://github.com/google/zx">zx</a></p>
<ul>
<li><p>安装（依赖 node.js 需 ≥ 14.8 版本）</p>
<pre><code class="bash">npm i -g zx
</code></pre>
</li>
<li><p>示例</p>
<blockquote>
<p>将编写的脚本放在 .mjs 后缀的文件中，或者使用 .js 后缀，但是需要 void async function () {…}() 对脚本进行包装</p>
</blockquote>
<pre><code class="javascript">#!/usr/bin/env zx

$.verbose = false; // 默认为 true。关闭打印所有命令以及输出

await $`cat package.json | grep name`

let branch = await $`git branch --show-current`
await $`dep deploy --branch=$&#123;branch&#125;`

await Promise.all([
    $`sleep 1; echo 1`,
    $`sleep 2; echo 2`,
    $`sleep 3; echo 3`,
])

let name = &quot;foo bar&quot;
await $`mkdir /tmp/$&#123;name&#125;`
</code></pre>
</li>
<li><p>执行脚本</p>
<pre><code class="bash"># 执行远程脚本
zx https://medv.io/example-script.mjs
</code></pre>
</li>
</ul>
</li>
<li><p>使用 <a href="https://github.com/mscdex/ssh2">ssh2</a> 连接 sftp 服务器</p>
<ol>
<li><p>安装</p>
<pre><code class="bash">npm install ssh2
</code></pre>
</li>
<li><p>示例</p>
<pre><code class="javascript">const &#123; readFileSync &#125; = require(&quot;fs&quot;);
const &#123; Client &#125; = require(&quot;ssh2&quot;);

const conn = new Client();
conn.on(&quot;ready&quot;, () =&gt; &#123;
    console.log(&quot;SSH connection ready.&quot;);

    conn.sftp((err, sftp) =&gt; &#123;
        if (err) throw err;

        // 读取 &quot;./&quot; 目录
        sftp.readdir(&quot;./&quot;, (err, list) =&gt; &#123;
            if (err) throw err;
            console.dir(list.map(f =&gt; f.filename));
            conn.end(); // 退出 ssh 连接
        &#125;);

        // 读取文件内容
        sftp.readFile(&quot;./webdav.txt&quot;, (err, buf) =&gt; &#123;
            if (err) throw err;
            console.log(buf.toString(&quot;base64&quot;));
            conn.end();
        &#125;);

        // 删除文件
        sftp.unlink(&quot;./webdav.txt&quot;, (err) =&gt; &#123;
            if (err) throw err;
            console.log(&quot;Delete file successfully.&quot;);
            conn.end();
        &#125;);

        // 下载 &quot;./webdav.txt&quot; 到本地当前目录下
        sftp.fastGet(&quot;./webdav.txt&quot;, &quot;./webdav.txt&quot;, (err) =&gt; &#123;
            if (err) throw err;
            console.log(&quot;Download file successfully.&quot;);
            conn.end();
        &#125;);

        // 上传文件
        sftp.fastPut(&quot;./package.json&quot;, &quot;./package.json&quot;, (err) =&gt; &#123;
            if (err) throw err;
            console.log(&quot;Upload file successfully.&quot;);
            conn.end();
        &#125;);
    &#125;);
&#125;).on(&quot;error&quot;, (err) =&gt; &#123;
    throw err;
&#125;).connect(&#123;
    host: &quot;127.0.0.1&quot;,
    port: 22,
    username: &quot;sftpuser&quot;,
    // privateKey: readFileSync(&quot;~/.ssh/id_rsa&quot;),
    password: &quot;123456&quot;,
    // debug: function(s) &#123; console.log(new Date(), s); &#125; // 打开调试日志
&#125;);
</code></pre>
</li>
</ol>
</li>
<li><p>使用 <a href="https://github.com/pegjs/pegjs">PEG.js</a> 自定义 DSL 解析</p>
<ol>
<li><p>安装</p>
<pre><code class="bash">npm install -g pegjs
</code></pre>
</li>
<li><p>编写语法文件，可参考<a href="https://pegjs.org/online">在线语法设计</a></p>
<pre><code>Expression
  = head:Term tail:(_ (&quot;+&quot; / &quot;-&quot;) _ Term)* &#123;
      return tail.reduce(function(result, element) &#123;
        if (element[1] === &quot;+&quot;) return result + element[3];
        if (element[1] === &quot;-&quot;) return result - element[3];
      &#125;, head);
    &#125;

Term
  = head:Factor tail:(_ (&quot;*&quot; / &quot;/&quot;) _ Factor)* &#123;
      return tail.reduce(function(result, element) &#123;
        if (element[1] === &quot;*&quot;) return result * element[3];
        if (element[1] === &quot;/&quot;) return result / element[3];
      &#125;, head);
    &#125;

Factor
  = &quot;(&quot; _ expr:Expression _ &quot;)&quot; &#123; return expr; &#125;
  / Integer
  / arr:Array &quot;[&quot; _ idx:Expression _ &quot;]&quot; &#123; return arr[idx]; &#125;

Array
  = &quot;[&quot; _ &quot;]&quot; &#123; return []; &#125; // 空数组
  / &quot;[&quot; head:(_ Integer _ &quot;,&quot;)* tail:(_ Integer _) &quot;]&quot; &#123; return head.concat([tail]) .map((element) =&gt; element[1]); &#125;

Integer &quot;integer&quot;
  = _ [0-9]+ &#123; return parseInt(text(), 10); &#125;

_ &quot;whitespace&quot;
  = [ \t\n\r]*
</code></pre>
</li>
<li><p>根据步骤二的语法文件（如 arithmetics.pegjs），生成 js 解析代码</p>
<pre><code class="bash">pegjs arithmetics.pegjs
# pegjs -o arithmetics-parser.js arithmetics.pegjs
</code></pre>
</li>
<li><p>使用</p>
<pre><code class="javascript">const parser = require(&quot;./arithmetics&quot;);
parser.parse(&quot;2 * (3 + 4)&quot;);
parser.parse(&quot;[1,2][1] + 2&quot;);
</code></pre>
</li>
</ol>
</li>
<li><p>使用 <a href="https://github.com/remy/inliner">inliner</a> 转换 web 页面到单个 html 文件中</p>
<ol>
<li>安装<pre><code class="bash">npm install -g inliner
</code></pre>
</li>
<li>压缩<pre><code class="bash">inliner https://www.baidu.com &gt; baidu.html
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="Snippets"><a href="#Snippets" class="headerlink" title="Snippets"></a><em>Snippets</em></h2><ul>
<li><p><a href="http://nodejs.cn/api/process.html#process_process_memoryusage">获取内存信息</a></p>
<pre><code class="javascript">process.memoryUsage();
// &#123; // 单位：字节（byte）
//     rss: 34009088, // 常驻集大小, 是为进程分配的物理内存（总分配内存的子集）的大小，包括所有的 C++ 和 JavaScript 对象与代码
//     heapTotal: 5455872, // V8 堆内存大小，包括已使用的和未使用的
//     heapUsed: 3022072, // V8 已使用堆内存大小
//     external: 1583051, // V8 管理的绑定到 Javascript 对象的 C++ 对象的内存使用情况
//     arrayBuffers: 9399 // 分配给 ArrayBuffer 和 SharedArrayBuffer 的内存，包括所有的 Node.js Buffer。这也包含在 external 值中。当 Node.js 被用作嵌入式库时，此值可能为 0，因为在这种情况下可能无法跟踪 ArrayBuffer 的分配。
// &#125;
</code></pre>
</li>
<li><p>Socket（TCP&amp;UDP）</p>
<ul>
<li>TCP<ul>
<li>服务端<pre><code class="javascript">var net = require(&quot;net&quot;);
var server = net.createServer();
server.on(&quot;connection&quot;, function(socket) &#123;
    socket.setEncoding(&quot;utf8&quot;);
    socket.on(&quot;data&quot;, function(data) &#123;
        console.log(data.toString());
    &#125;);
    socket.on(&quot;end&quot;, function() &#123;
        console.log(&quot;end&quot;);
    &#125;);
&#125;);
server.listen(8765, &quot;127.0.0.1&quot;);
</code></pre>
</li>
<li>客户端<pre><code class="javascript">var net = require(&quot;net&quot;);
var client = new net.Socket();
client.setEncoding(&quot;utf8&quot;);
client.connect(8765, &quot;127.0.0.1&quot;, function() &#123;
    console.log(&quot;connect&quot;);
    client.write(&quot;to server&quot;);
    client.end(&quot;end&quot;);
&#125;);
client.on(&quot;data&quot;, function(data) &#123;
    console.log(&quot;receive data from server&quot;);
&#125;);
</code></pre>
</li>
</ul>
</li>
<li>UDP<ul>
<li>服务器<pre><code class="javascript">var dgram = require(&quot;dgram&quot;);
var server = dgram.createSocket(&quot;udp4&quot;);
server.on(&quot;message&quot;, function(msg, rinfo) &#123;
    console.log(msg);
    var buf = new Buffer(&quot;测试&quot;);
    server.send(buf, 0, buf.length, rinfo.port, rinfo.address);
&#125;);
server.on(&quot;listening&quot;, function() &#123;
    console.log(&quot;listen&quot;);
&#125;);
server.bind(12345, &quot;127.0.0.1&quot;);
</code></pre>
</li>
<li>客户端<pre><code class="javascript">server.on(&quot;message&quot;, function(msg, rinfo) &#123;
    console.log(msg);
    var buf = new Buffer(&quot;测试&quot;);
    server.send(buf, 0, buf.length, rinfo.port, rinfo.address);
&#125;);
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>读取文件内容</p>
<pre><code class="javascript">var fs = require(&quot;fs&quot;);

fs.readFile(&quot;./services.txt&quot;, &quot;utf-8&quot;, function(err, data) &#123;
    if (err) throw err;
    console.info(data);
&#125;);
</code></pre>
</li>
<li><p>创建一个简单的 http 服务</p>
<pre><code class="javascript">var http = require(&quot;http&quot;);

var server = http.createServer(function(req, res) &#123;
    res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html&quot; &#125;);

    res.end(&quot;&lt;!DOCTYPE html&gt;&lt;html lang=\&quot;en\&quot;&gt;&lt;head&gt;&lt;meta charset=\&quot;UTF-8\&quot;&gt;&lt;title&gt;greeting&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello, world&lt;/body&gt;&lt;/html&gt;&quot;);
&#125;);

server.listen(8080, function() &#123;
    console.log(&quot;Server is running at http://localhost:8080/&quot;);
&#125;);
</code></pre>
</li>
<li><p>创建一个简单的 https 服务（双向认证）  </p>
<pre><code class="bash"># 生成 CA 自签名证书
openssl genrsa -out ca.key 4096
openssl req -new -x509 -days 7300 -key ca.key -subj &quot;/C=CN/ST=JS/L=NJ/O=Sunke, Inc./CN=Sunke Root CA&quot; -out ca.crt

# 生成服务器证书
openssl req -newkey rsa:2048 -nodes -keyout server.key -subj &quot;/C=CN/ST=JS/L=NJ/O=Sunke, Inc./CN=localhost&quot; -out server.csr
openssl x509 -sha256 -req -extfile &lt;(printf &quot;subjectAltName=DNS:localhost,IP:127.0.0.1&quot;) -days 365 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt
# cat server.crt ca.crt &gt; server.b.crt

# 生成客户端证书
openssl req -newkey rsa:2048 -nodes -keyout client.key -subj &quot;/C=CN/ST=JS/L=NJ/O=/CN=&quot; -out client.csr
openssl x509 -sha256 -req -days 365 -in client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client.crt
</code></pre>
<pre><code class="javascript">const https = require(&quot;https&quot;);
const fs = require(&quot;fs&quot;);

https.createServer(&#123;
    key: fs.readFileSync(&quot;./server.key&quot;),
    // passphrase: &quot;123456&quot;, // server.key 加密秘钥
    cert: fs.readFileSync(&quot;./server.crt&quot;),
    ca: fs.readFileSync(&quot;./ca.crt&quot;),
    requestCert:true, // 请求客户端证书
    rejectUnauthorized: true // 如果请求的客户端没有来自信任 CA 颁发的证书，拒绝客户端的连接
&#125;, (req, res) =&gt; &#123;
    res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html&quot; &#125;);
    res.write(&quot;&lt;!DOCTYPE html&gt;&lt;html lang=\&quot;en\&quot;&gt;&lt;head&gt;&lt;meta charset=\&quot;UTF-8\&quot;&gt;&lt;title&gt;greeting&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello, world&lt;/body&gt;&lt;/html&gt;&quot;);
    res.end();
&#125;).listen(8443, function() &#123;
    console.log(&quot;Server is running at https://127.0.0.1:8443/&quot;);
&#125;);
</code></pre>
<pre><code class="bash">curl --cacert ./ca.crt --cert ./client.crt --key ./client.key https://127.0.0.1:8443
</code></pre>
</li>
<li><p>sqlite</p>
<pre><code class="bash">npm install sqlite3
</code></pre>
<pre><code class="javascript">const sqlite3 = require(&quot;sqlite3&quot;);
const db = new sqlite3.Database(&quot;mydb.db&quot;);
</code></pre>
</li>
</ul>
<h1 id="node-webkit"><a href="#node-webkit" class="headerlink" title="node-webkit"></a>node-webkit</h1><ul>
<li><p>创建项目(hello World)</p>
<ol>
<li>创建页面文件 index.html<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello World!&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
<li>创建配置文件 package.json<pre><code class="json">&#123;
    &quot;name&quot;: &quot;helloworld&quot;,
    &quot;main&quot;: &quot;index.html&quot;
&#125;
</code></pre>
</li>
</ol>
</li>
<li><p>运行</p>
<ol>
<li>将index.html和package.json这两个文件压缩到一个zip压缩包里，命名为helloworld.zip</li>
<li>把helloworld.zip这个文件的扩展名改为nw,变为 helloworld.nw</li>
<li>之前得到的helloworld.nw这个文件就可以用nw.exe来执行了，直接把helloworld.nw拖到nw.exe上就可以了。</li>
<li>把helloworld.nw这个文件跟node-webkit的环境文件一起打包成一个可执行文件，打开windows的cmd,然后输入如下命令：<br> <code>copy /b nw.exe+app.nw app.exe</code></li>
<li>但我们大多数人想的是给用户一个exe文件，用户就可以使用了，不用再附带一些其他文件。需要一个软件叫Enigma Virtual Box，首先下载和安装这个软件，然后打开它。然后在Enter Input File Name那里输入我们的app.exe的路径，在Enter Output File Name那里填写我们要把打包出来的可执行文件输出到哪里。最后是把除app.exe外的其它文件拖入到Files那里，遇到提示的话默认就可以了。<blockquote>
<ul>
<li>The nw.pak and icudt.dll must be shipped along with nw.exe, the former one contains important javascript lib files, and the latter one is a important network library.  </li>
<li>ffmpegsumo.dll are media library, if you want to use &lt;video&gt; and &lt;audio&gt; tag, or other media related features, you should ship it.  </li>
<li>libEGL.dll and libGLESv2.dll are used for WebGL and GPU acceleration, you had better ship them. And D3DCompiler_43.dll and d3dx9_43.dll as well if you want to make sure WebGL works on more hardware. These 2 files are from DirectX redistributable.</li>
</ul>
</blockquote>
</li>
</ol>
</li>
</ul>
<h1 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h1><ul>
<li><p>环境搭建</p>
<ol>
<li>npm install electron</li>
<li>npm install electron-packager –save-dev</li>
<li>npm install electron-packager -g</li>
</ol>
</li>
<li><p>创建项目(hello World)</p>
<ol>
<li><p>创建目录helloworld</p>
</li>
<li><p>在helloworld目录下创建页面文件 index.html</p>
<pre><code class="html">&lt;h1&gt;Hello World!&lt;/h1&gt;
</code></pre>
</li>
<li><p>在helloworld目录下创建脚本文件 main.js</p>
<pre><code class="javascript">const &#123;app, BrowserWindow&#125; = require(&quot;electron&quot;);

let mainWindow;

app.on(&quot;ready&quot;, () =&gt; &#123;
    mainWindow = new BrowserWindow(&#123;
        height: 600,
        width: 800
    &#125;);

    mainWindow.loadURL(&quot;file://&quot; + __dirname + &quot;/index.html&quot;);
&#125;);
</code></pre>
</li>
<li><p>在helloworld目录下创建配置文件 package.json</p>
<pre><code class="json">&#123;
    &quot;name&quot;:    &quot;helloworld&quot;,
    &quot;version&quot;: &quot;1.0.1&quot;,
    &quot;main&quot;:    &quot;main.js&quot;
&#125;
</code></pre>
</li>
</ol>
</li>
<li><p>运行</p>
<pre><code class="bash">electron .
</code></pre>
</li>
<li><p>发布</p>
<pre><code class="bash">electron-packager &lt;sourcedir&gt; &lt;appname&gt; --platform=&lt;platform&gt; --arch=&lt;arch&gt; [optional flags...]
</code></pre>
</li>
<li><p><a href="https://m.w3cschool.cn/electronmanual/electronmanual-protocol.html">使用 protocol 注册自定义协议或拦截协议请求</a></p>
<pre><code class="javascript">const electron = require(&quot;electron&quot;);
const app = electron.app;
const path = require(&quot;path&quot;);

app.on(&quot;ready&quot;, function() &#123;
    var protocol = electron.protocol;

    protocol.registerFileProtocol(&quot;atom&quot;, function(request, callback) &#123;
        var url = request.url.substr(7);
        callback(&#123;path: path.normalize(__dirname + &quot;/&quot; + url)&#125;);
    &#125;, function(error) &#123;
        if (error)
            console.error(&quot;Failed to register protocol&quot;)
    &#125;);
    
    // protocol.interceptHttpProtocol(&quot;http&quot;, handler[, completion]); // 拦截 http 请求
&#125;);
</code></pre>
</li>
</ul>
<h1 id="express"><a href="#express" class="headerlink" title="express"></a><a href="https://www.expressjs.com.cn/">express</a></h1><ol>
<li><p>安装 express</p>
<pre><code class="bash">npm install express
</code></pre>
</li>
<li><p>创建 app.js</p>
<pre><code class="javascript">const app = require(&quot;express&quot;)();
const bodyParser = require(&quot;body-parser&quot;);

app.use(bodyParser.json()); // for parsing application/json

app.post(&quot;/greeting&quot;, function(req, res, next) &#123;
    console.log(req.body);
    res.json(req.body);
&#125;);
</code></pre>
</li>
<li><p>运行</p>
<pre><code class="bash">node app.js
</code></pre>
</li>
</ol>
<h1 id="node-fetch"><a href="#node-fetch" class="headerlink" title="node-fetch"></a>node-fetch</h1><ol>
<li><p>安装</p>
<pre><code class="bash">npm install node-fetch
</code></pre>
</li>
<li><p>调用</p>
<pre><code class="javascript">const fetch = require(&quot;node-fetch&quot;);

fetch(&quot;https://www.baidu.com&quot;);
</code></pre>
</li>
<li><p>代理访问</p>
<ol>
<li><p>安装</p>
<pre><code class="bash">npm install https-proxy-agent
</code></pre>
</li>
<li><p>调用</p>
<pre><code class="javascript">const HttpsProxyAgent = require(&quot;https-proxy-agent&quot;);

fetch(&quot;https://www.baidu.com&quot;, &#123;
    agent: new HttpsProxyAgent(&quot;http://192.168.0.1:5566&quot;)
&#125;);
</code></pre>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Solr</title>
    <url>/2025/03/22/solr/</url>
    <content><![CDATA[<h1 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h1><h2 id="Document（官方文档）"><a href="#Document（官方文档）" class="headerlink" title="Document（官方文档）"></a><a href="https://lucene.apache.org/solr/guide/7_5/">Document（官方文档）</a></h2><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ul>
<li><p><a href="http://lucene.apache.org/solr/guide/7_3/solr-tutorial.html">下载、部署与运行</a></p>
<ol>
<li><p>下载二进制包（需安装 java 1.8 版本）<br> <code>wget http://mirrors.hust.edu.cn/apache/lucene/solr/7.3.1/solr-7.3.1.zip</code></p>
<blockquote>
<p>下载源码包<br>  <code>wget http://mirrors.hust.edu.cn/apache/lucene/solr/7.3.1/solr-7.3.1-src.tgz</code></p>
</blockquote>
</li>
<li><p>解压缩<br> <code>unzip -q solr-7.3.1.zip</code></p>
</li>
<li><p>启动</p>
<ul>
<li><p>单机模式</p>
<ol>
<li><p>方法一：使用 jetty 启动 solr<br> <code>cd solr-7.3.1/</code><br> <code>./bin/solr start</code><br> <del><code>./bin/solr start -p 8984</code></del><br> 浏览器中访问 <a href="http://localhost:8983/solr/">http://localhost:8983/solr/</a> 进入管理页面  </p>
<blockquote>
<p>查看 solr 服务状态<br><code>./bin/solr status</code><br>停止 solr 服务<br><code>./bin/solr stop</code><br>创建 solr 库 core4<br><code>.bin/solr create -c core4</code></p>
</blockquote>
</li>
<li><p>方法二：<span id="single_run_with_tomcat"><a href="http://blog.csdn.net/happyzwh/article/details/51741204">使用 tomcat 运行</a></span></p>
<ol>
<li><p>搭建 tomcat 环境</p>
<ol>
<li>下载 tomcat<br> <code>curl -O http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.31/bin/apache-tomcat-8.5.31.zip</code></li>
<li>解压到当前目录下<br> <code>unzip -q apache-tomcat-8.5.31.zip</code></li>
<li>创建 tomcat 软连接<br> <code>ln -s apache-tomcat-8.5.31 tomcat</code></li>
<li>删除 tomcat/webapps 无用的工程<br> <code>rm -rf tomcat/webapps/*</code></li>
<li>设置启动、停止脚本可执行权限<br> <code>chmod +x tomcat/bin/*.sh</code></li>
</ol>
</li>
<li><p>创建 solrhome<br> <code>mkdir tomcat/solrhome</code><br> <code>cp solr-7.3.1/server/solr/solr.xml tomcat/solrhome/</code><br> <del>复制 solr-7.3.1/server/solr/ 目录下所有文件到 tomcat/solrhome/ 目录下</del><br> <del><code>cp -r solr-7.3.1/server/solr/* tomcat/solrhome/</code></del></p>
</li>
<li><p><span id="deploy_solr_in_tomcat_webapp">部署 solr 工程至 tomcat 中</span></p>
<ol>
<li><p>在 tomcat/webapps/ 目录下创建文件夹 solr<br> <code>mkdir tomcat/webapps/solr</code></p>
</li>
<li><p>将 solr-7.3.1/server/solr-webapp/webapp 下的所有文件拷贝到 tomcat/webapps/solr/ 目录下<br> <code>cp -r solr-7.3.1/server/solr-webapp/webapp/* tomcat/webapps/solr/</code></p>
</li>
<li><p>复制 solr 依赖的 jar 包到 WEB-INF/lib 目录下<br> <code>cp solr-7.3.1/server/lib/metrics-* tomcat/webapps/solr/WEB-INF/lib/</code><br> <code>cp solr-7.3.1/server/lib/ext/* tomcat/webapps/solr/WEB-INF/lib/</code></p>
</li>
<li><p>复制日志配置文件到 WEB-INF/classes 目录下<br> <code>mkdir tomcat/webapps/solr/WEB-INF/classes</code><br> <code>cp solr-7.3.1/server/resources/log4j.properties tomcat/webapps/solr/WEB-INF/classes/</code></p>
</li>
<li><p>配置 solrhome 路径</p>
<ul>
<li>方法一：在 tomcat 中配置 solrhome 路径<br>  修改文件 context.xml，在 <code>\\Context</code> 节点下添加 Environment 配置项<pre><code class="xml">&lt;Environment name=&quot;solr/home&quot; type=&quot;java.lang.String&quot; value=&quot;../solrhome&quot; override=&quot;false&quot; /&gt;
</code></pre>
</li>
<li>方法二：在 web.xml 中配置 solrhome 路径<br>  修改文件 web.xml，在 <code>\web-app</code> 节点下，添加（或取消注释并修改 env-entry-value）配置如下<pre><code class="xml">&lt;env-entry&gt;
    &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;
    &lt;env-entry-value&gt;../solrhome&lt;/env-entry-value&gt;
    &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;
&lt;/env-entry&gt;
</code></pre>
  <!-- 修改文件 web.xml，取消配置项 "\<env-entry>" 的注释  
  `sed -i '40d;46d' tomcat/webapps/solr/WEB-INF/web.xml`  
  修改文件 web.xml，将配置项 "\<env-entry-value>" 中的值修改为 solrhome 目录所在位置  
  ~~`sed -i "s#\/put\/your\/solr\/home\/here#$(pwd)\/tomcat\/solrhome#" tomcat/webapps/solr/WEB-INF/web.xml`~~  
  `sed -i "s#\/put\/your\/solr\/home\/here#..\/solrhome#" tomcat/webapps/solr/WEB-INF/web.xml` --></li>
<li>方法三：在启动命令中使用 jvm 启动参数 <code>-Dsolr.solr.solrhome=../solrhome</code></li>
</ul>
</li>
<li><p>修改文件 web.xml，注释节点 <code>\web-app\security-constraint</code>（该配置限制了对 solr 资源的访问，若不注释，则抛出异常 “HTTP Status 403 - Access to the requested resource has been denied”）<br> <code>sed -i &#39;s/&lt;security-constraint&gt;/&lt;!-- &lt;security-constraint&gt;/&#39; tomcat/webapps/solr/WEB-INF/web.xml</code><br> <code>sed -i &#39;s/&lt;\/security-constraint&gt;/&lt;\/security-constraint&gt; --&gt;/&#39; tomcat/webapps/solr/WEB-INF/web.xml</code></p>
 <!-- `sed -i '161i<!--' tomcat/webapps/solr/WEB-INF/web.xml`  
 `sed -i '177i--\>' tomcat/webapps/solr/WEB-INF/web.xml` --></li>
<li><p>（可选）配置安全认证  </p>
<ol>
<li><p>编辑文件 tomcat/conf/tomcat-users.xml，在 <code>\tomcat-users</code> 节点下添加用户、角色配置如下</p>
<pre><code class="xml">&lt;role rolename=&quot;solr_admin&quot; /&gt;
&lt;role rolename=&quot;core3_admin&quot; /&gt;
&lt;user username=&quot;solr_admin&quot; password=&quot;solr_admin&quot; roles=&quot;solr_admin&quot; /&gt;
&lt;user username=&quot;core3_admin&quot; password=&quot;core3_admin&quot; roles=&quot;core3_admin&quot; /&gt;
</code></pre>
</li>
<li><p><a href="tomcat.md#tomcat_setup_ssl">配置 SSL</a></p>
</li>
<li><p>编辑文件 web.xml，在 <code>\web-app</code> 节点下添加 security-constraint 配置如下  </p>
<pre><code class="xml">&lt;!-- 查询接口无需认证 --&gt;
&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;Solr Select Interface&lt;/web-resource-name&gt;
        &lt;url-pattern&gt;/core3/select&lt;/url-pattern&gt;
        &lt;http-method&gt;GET&lt;/http-method&gt;&lt;!-- 仅允许（未认证用户）使用 GET 方法访问该接口 --&gt;
    &lt;/web-resource-collection&gt;
&lt;/security-constraint&gt;

&lt;!-- core 管理接口需 core admin 角色认证 --&gt;
&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;Core3 Admin&lt;/web-resource-name&gt;
        &lt;url-pattern&gt;/core3/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
        &lt;role-name&gt;core3_admin&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
    &lt;user-data-constraint&gt;&lt;!-- 需转换成 https 访问，即禁止以 http 访问该接口 --&gt;
        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
&lt;/security-constraint&gt;

&lt;!-- solr admin 管理接口、页面需 solr admin 角色认证 --&gt;
&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;Solr Admin&lt;/web-resource-name&gt;
        &lt;!-- &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt; --&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
        &lt;role-name&gt;solr_admin&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
    &lt;user-data-constraint&gt;&lt;!-- 需转换成 https 访问，即禁止以 http 访问该接口 --&gt;
        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
&lt;/security-constraint&gt;
&lt;login-config&gt;
    &lt;auth-method&gt;DIGEST&lt;/auth-method&gt;
&lt;/login-config&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p>启动 tomcat<br> <code>tomcat/bin/startup.sh</code></p>
</li>
<li><p>访问 <a href="http://127.0.0.1:8080/solr/index.html">http://127.0.0.1:8080/solr/index.html</a> 可进入 solr 管理页面</p>
</li>
<li><p>创建一个 Core 实例（Core 实例配置可参考<a href="#create_core3">创建、配置 Core 实例 core3</a>）</p>
<ul>
<li><p>快速创建一个 Core 实例 core1</p>
<ol>
<li>创建一个空文件夹 core1<br> <code>mkdir tomcat/solrhome/core1</code></li>
<li>复制示例配置文件<br> <code>cp -r solr-7.3.1/server/solr/configsets/sample_techproducts_configs/conf/ tomcat/solrhome/core1</code></li>
<li>登录进入 solr 管理页面添加 Core</li>
</ol>
</li>
<li><p>创建一个极简配置的 Core 实例 core2</p>
<pre><code class="bash"># 递归创建一个空文件夹 core2/conf
mkdir -p tomcat/solrhome/core2/conf

# 创建配置文件 solrconfig.xml
cat &gt; tomcat/solrhome/core2/conf/solrconfig.xml &lt;&lt; EOF
&lt;config&gt;
    &lt;luceneMatchVersion&gt;7.3.1&lt;/luceneMatchVersion&gt;
    &lt;requestHandler name=&quot;/select&quot; class=&quot;solr.SearchHandler&quot; &gt;
        &lt;lst name=&quot;defaults&quot;&gt;
            &lt;str name=&quot;df&quot;&gt;text&lt;/str&gt;
        &lt;/lst&gt;
    &lt;/requestHandler&gt;
&lt;/config&gt;
EOF

# 创建配置文件 managed-schema
cat &gt; tomcat/solrhome/core2/conf/managed-schema &lt;&lt; EOF
&lt;schema name=&quot;example&quot; version=&quot;1.6&quot;&gt;
    &lt;field name=&quot;text&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot; /&gt;
    &lt;dynamicField name=&quot;*&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;false&quot;  multiValued=&quot;true&quot; /&gt;
    &lt;copyField source=&quot;*&quot; dest=&quot;text&quot; /&gt;
    &lt;fieldType name=&quot;string&quot; class=&quot;solr.StrField&quot; /&gt;
    &lt;fieldType name=&quot;text_general&quot; class=&quot;solr.TextField&quot;&gt;
        &lt;analyzer&gt;
            &lt;tokenizer class=&quot;solr.LowerCaseTokenizerFactory&quot; /&gt;
        &lt;/analyzer&gt;
    &lt;/fieldType&gt;
&lt;/schema&gt;
EOF
</code></pre>
<p>  登录进入 solr 管理页面添加 Core</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>集群模式（SolrCloud）</p>
<ol>
<li><p>方法一：使用 jetty 启动 solr<br> <code>cd solr-7.3.1/</code><br> <code>./bin/solr start -e cloud</code><br> 访问 <a href="http://localhost:8983/solr/">http://localhost:8983/solr/</a> 进入管理页面</p>
</li>
<li><p>方法二：<a href="https://www.jianshu.com/p/4e00db4f8c47">使用 tomcat 运行</a></p>
<ol>
<li><p>部署 zookeeper（原则上，zookeeper 节点数量应大于 tomcat 节点数量的一半。如 zookeeper 有 3 个，tomcat 有 4 个）</p>
<ol>
<li>分别在不同的主机上<a href="zookeeper.md">部署 zookeeper</a><ol>
<li>下载 zookeeper<br> <code>wget http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.11/zookeeper-3.4.11.tar.gz</code></li>
<li>解压到 zookeeper 目录下<br> <code>tar -zxvf zookeeper-3.4.11.tar.gz &amp;&amp; mv zookeeper-3.4.11 zookeeper</code></li>
<li>新建配置文件 zoo.cfg<pre><code class="bash">cat &gt; zookeeper/conf/zoo.cfg &lt;&lt; EOF
tickTime=2000
initLimit=10
syncLimit=5
dataDir=/tmp/zookeeper
clientPort=2181
server.1=192.168.1.101:2888:3888
server.2=192.168.1.102:2888:3888
server.3=192.168.1.103:2888:3888
EOF
</code></pre>
</li>
<li><del>为每个主机建立一个 myid 文件，文件内容不应相同，可以为 1、2、3…<br> <code>echo 1 &gt; ./zookeeper/data/myid</code></del></li>
</ol>
</li>
<li>分别启动各主机上的 zookeeper 实例<br> <del><code>./zookeeper/bin/zkServer.sh start</code></del><br> <code>./zookeeper/bin/zkServer.sh</code></li>
</ol>
</li>
<li><p>部署 solr</p>
<ol>
<li><p>分别在不同的主机上部署 solr，部署方法同<a href="#single_run_with_tomcat">使用 tomcat 运行单机模式下的 solr</a>（需要配置 solrhome，但不需要创建 Core 实例）</p>
</li>
<li><p>修改每个主机中 solrhome 目录下的 solr.xml<br> 编辑 solrhome/solr.xml 文件，修改 <code>/solr/solrcloud</code> 节点下的配置 host、hostPort （即当前主机提供的 solr 服务的 ip 和端口号）如下</p>
<pre><code class="xml">&lt;solrcloud&gt;
    &lt;str name=&quot;host&quot;&gt;192.168.1.101&lt;/str&gt;
    &lt;int name=&quot;hostPort&quot;&gt;8080&lt;/int&gt;
    ...
&lt;/solrcloud&gt;
</code></pre>
<blockquote>
<p>各主机应根据自身实际 ip 设置 host 内容。伪分布式情况下，各 solr 实例的 host、hostPort 不应相同</p>
</blockquote>
</li>
<li><p>分别在不同的主机上设置 tomcat 启动参数<br> 编辑 tomcat/bin/catalina.sh，添加以下 jvm 参数<br> <code>JAVA_OPTS=&quot;-DzkHost=192.168.1.101:2181,192.168.1.101:2181,192.168.1.101:2181&quot;</code></p>
</li>
<li><p>将 solr 配置文件上传到 zookeeper 中，进行统一管理  </p>
 <!-- `./zookeeper/bin/zkCli.sh -zkhost 192.168.1.101:2181,192.168.1.101:2181,192.168.1.101:2181 -cmd upconfig -confdir tomcat/solrhome/configsets/_default/conf/ -confname collection1` -->
<p> <code>java -cp tomcat/webapps/solr/WEB-INF/lib/* org.apache.solr.cloud.ZkCLI -zkhost 192.168.1.101:2181,192.168.1.101:2181,192.168.1.101:2181 -cmd upconfig -confdir tomcat/solrhome/configsets/_default/conf/ -confname collection1</code></p>
<blockquote>
<p>删除配置文件<br><code>java -cp tomcat/webapps/solr/WEB-INF/lib/* org.apache.solr.cloud.ZkCLI -zkhost 192.168.1.101:2181,192.168.1.101:2181,192.168.1.101:2181 -cmd clear /configs/collection1</code></p>
</blockquote>
</li>
<li><p>分别启动各主机上的 solr 实例，参考<a href="#single_run_with_tomcat">使用 tomcat 运行单机模式下的 solr</a>中的 “启动 tomcat” 步骤</p>
</li>
<li><p>访问 <a href="http://192.168.1.101:8080/solr/index.html">http://192.168.1.101:8080/solr/index.html</a> 可进入 solr 管理页面</p>
</li>
<li><p>创建 Collection 实例<br> <code>curl http://192.168.1.101:8080/solr/admin/collections?action=CREATE&amp;name=collection1&amp;numShards=2&amp;replicationFactor=2</code><br> 删除 Collection 实例<br> <code>curl http://192.168.1.101:8080/solr/admin/collections?action=DELETE&amp;name=collection1</code></p>
<blockquote>
<ul>
<li>实测，linux 环境中 solr 以 cloud 模式运行时，collection 名称（如 test_test）中带有 “_” 的需要指定 collection.configName<br><code>curl http://127.0.0.1:8080/solr/admin/collections?action=CREATE&amp;name=test_test&amp;numShards=2&amp;replucationFactor=2&amp;collection.configName=test_test</code></li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<p><a href="http://www.cnblogs.com/xiazh/articles/4084025.html">伪分布式情况</a>下，ip 相同，zookeeper 的 dataDir、clientPort 不应相同，server 的路径和端口号不应相同，其他操作步骤同以上的集群模式搭建过程。伪分布式 solr cloud 环境自动化搭建脚本见 <a href="#/Source/shell/setup_fake_solr_cloud.sh">setup_fake_solr_cloud.sh</a>。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p><span id="create_core3">创建、配置 Core 实例 core3</span></p>
<ol>
<li><p>在 solrhome 目录下创建配置文件<br> <code>mkdir -p tomcat/solrhome/core3/conf &amp;&amp; cd tomcat/solrhome/core3/conf</code><br> <code>touch solrconfig.xml managed-schema</code></p>
</li>
<li><p><span id="config_core3">编辑配置文件</span></p>
<ul>
<li><p>solrconfig.xml</p>
<pre><code class="xml">&lt;config&gt;
    &lt;luceneMatchVersion&gt;7.3.1&lt;/luceneMatchVersion&gt;
    &lt;requestHandler name=&quot;/select&quot; class=&quot;solr.SearchHandler&quot; &gt;
        &lt;lst name=&quot;defaults&quot;&gt;
            &lt;str name=&quot;df&quot;&gt;text&lt;/str&gt;
        &lt;/lst&gt;
    &lt;/requestHandler&gt;
&lt;/config&gt;
</code></pre>
</li>
<li><p>managed-schema</p>
<pre><code class="xml">&lt;schema name=&quot;example&quot; version=&quot;1.6&quot;&gt;
    &lt;field name=&quot;id&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot; multiValued=&quot;false&quot; /&gt;
    &lt;uniqueKey&gt;id&lt;/uniqueKey&gt;

    &lt;field name=&quot;text&quot; type=&quot;text_general&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;true&quot; /&gt;
    &lt;dynamicField name=&quot;*&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;false&quot;  multiValued=&quot;true&quot; /&gt;

    &lt;fieldType name=&quot;string&quot; class=&quot;solr.StrField&quot; /&gt;
    &lt;fieldType name=&quot;text_general&quot; class=&quot;solr.TextField&quot;&gt;
        &lt;analyzer&gt;
            &lt;tokenizer class=&quot;solr.LowerCaseTokenizerFactory&quot; /&gt;
        &lt;/analyzer&gt;
    &lt;/fieldType&gt;
&lt;/schema&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
<ul>
<li><p><a href="http://www.cnblogs.com/blog-zuo/p/4819058.html">配置拼写检查（纠错）</a></p>
<ol>
<li>编辑 solrconfig.xml，在 <code>/config</code> 节点下，新增 searchComponent 配置项并替换 requestHandler 配置项，如下<pre><code class="xml">&lt;config&gt;
    ...
    &lt;searchComponent name=&quot;spellcheck&quot; class=&quot;solr.SpellCheckComponent&quot;&gt;
        &lt;!-- 将输入关键词当做text_general类型进行处理 --&gt;
        &lt;str name=&quot;queryAnalyzerFieldType&quot;&gt;text_general&lt;/str&gt;
        &lt;!-- a spellchecker built from a field of the main index --&gt;
        &lt;lst name=&quot;spellchecker&quot;&gt;
            &lt;!-- 拼写检查模块名 --&gt;
            &lt;str name=&quot;name&quot;&gt;default&lt;/str&gt;
            &lt;!-- 对索引中的哪个字段进行拼写检查 --&gt;
            &lt;str name=&quot;field&quot;&gt;text&lt;/str&gt;
            &lt;!-- 自定义拼写检查，可以用自定义拼写检查类代替默认类 --&gt;
            &lt;str name=&quot;classname&quot;&gt;solr.DirectSolrSpellChecker&lt;/str&gt;
            &lt;!-- 拼写检查编辑距离, 默认使用internal levenshtein --&gt;
            &lt;str name=&quot;distanceMeasure&quot;&gt;internal&lt;/str&gt;
            &lt;!-- minimum accuracy needed to be considered a valid spellcheck suggestion --&gt;
            &lt;float name=&quot;accuracy&quot;&gt;0.5&lt;/float&gt;
            &lt;!-- 最大编辑距离，与输入字符串编辑距离小于等于2的字符串被检索出来作为纠错结果 --&gt;
            &lt;int name=&quot;maxEdits&quot;&gt;2&lt;/int&gt;
            &lt;!-- 与输入字符串最少有一个字符相等，才能被检索出来 --&gt;
            &lt;int name=&quot;minPrefix&quot;&gt;1&lt;/int&gt;
            &lt;!-- maximum number of inspections per result. 一次纠错探测最大数量 --&gt;
            &lt;int name=&quot;maxInspections&quot;&gt;5&lt;/int&gt;
            &lt;!-- 纠错元词最小长度，元词长度小于4不进行纠错 --&gt;
            &lt;int name=&quot;minQueryLength&quot;&gt;4&lt;/int&gt;
            &lt;!-- maximum threshold of documents a query term can appear to be considered for correction --&gt;
            &lt;float name=&quot;maxQueryFrequency&quot;&gt;0.01&lt;/float&gt;
        &lt;/lst&gt;
        &lt;lst name=&quot;spellchecker&quot;&gt;
            &lt;str name=&quot;name&quot;&gt;wordbreak&lt;/str&gt;
            &lt;str name=&quot;classname&quot;&gt;solr.WordBreakSolrSpellChecker&lt;/str&gt;
            &lt;str name=&quot;field&quot;&gt;text&lt;/str&gt;
            &lt;str name=&quot;combineWords&quot;&gt;true&lt;/str&gt;
            &lt;str name=&quot;breakWords&quot;&gt;true&lt;/str&gt;
            &lt;int name=&quot;maxChanges&quot;&gt;10&lt;/int&gt;
        &lt;/lst&gt;
        &lt;!-- 拼写检查器，使用 JaroWinklerDistance 距离算法 --&gt;
        &lt;!-- &lt;lst name=&quot;spellchecker&quot;&gt;
            &lt;str name=&quot;name&quot;&gt;jarowinkler&lt;/str&gt;
            &lt;str name=&quot;classname&quot;&gt;solr.IndexBasedSpellChecker&lt;/str&gt;
            &lt;str name=&quot;field&quot;&gt;spell&lt;/str&gt;
            &lt;str name=&quot;distanceMeasure&quot;&gt;org.apache.lucene.search.spell.JaroWinklerDistance&lt;/str&gt;
            &lt;str name=&quot;spellcheckIndexDir&quot;&gt;./spellchecker2&lt;/str&gt;
            &lt;str name=&quot;buildOnCommit&quot;&gt;true&lt;/str&gt;
        &lt;/lst&gt; --&gt;
    &lt;/searchComponent&gt;
    ...
    &lt;requestHandler name=&quot;/select&quot; class=&quot;solr.SearchHandler&quot; startup=&quot;lazy&quot;&gt;
        &lt;lst name=&quot;defaults&quot;&gt;
            &lt;str name=&quot;df&quot;&gt;text&lt;/str&gt;
            &lt;!-- 下边配置了两个拼写检查子模块，是前边定义好的default和wordbreak，solr会分别用两个模块对输入进行拼写检查，最终将结果整合到一块 --&gt;
            &lt;str name=&quot;spellcheck.dictionary&quot;&gt;default&lt;/str&gt;
            &lt;str name=&quot;spellcheck.dictionary&quot;&gt;wordbreak&lt;/str&gt;
            &lt;str name=&quot;spellcheck&quot;&gt;on&lt;/str&gt;
            &lt;!-- 为纠错后的提示词添加额外信息，如在索引中的频率 --&gt;
            &lt;str name=&quot;spellcheck.extendedResults&quot;&gt;true&lt;/str&gt;
            &lt;!-- 一次纠错返回结果数量 --&gt;
            &lt;str name=&quot;spellcheck.count&quot;&gt;10&lt;/str&gt;
            &lt;!-- The maximum number of suggestions to return for terms that exist in the index --&gt;
            &lt;str name=&quot;spellcheck.alternativeTermCount&quot;&gt;5&lt;/str&gt;
            &lt;!-- The maximum number of results the query can return while still triggering spelling suggestions --&gt;
            &lt;str name=&quot;spellcheck.maxResultsForSuggest&quot;&gt;5&lt;/str&gt;
            &lt;!-- 是否添加校验结果 --&gt;
            &lt;str name=&quot;spellcheck.collate&quot;&gt;true&lt;/str&gt;
            &lt;!-- 是否添加校验拓展结果 --&gt;
            &lt;str name=&quot;spellcheck.collateExtendedResults&quot;&gt;true&lt;/str&gt;
            &lt;!-- The maximum # of collation possibilities to try before giving up. --&gt;
            &lt;str name=&quot;spellcheck.maxCollationTries&quot;&gt;10&lt;/str&gt;
            &lt;!-- 返回校验结果的最大数目 --&gt;
            &lt;str name=&quot;spellcheck.maxCollations&quot;&gt;5&lt;/str&gt;
        &lt;/lst&gt;
        &lt;!-- 必须将拼写检查控件添加到搜索控件序列中，若无此项则不进行拼写检查 --&gt;
        &lt;arr name=&quot;last-components&quot;&gt;
            &lt;str&gt;spellcheck&lt;/str&gt;
        &lt;/arr&gt;
    &lt;/requestHandler&gt;
    ...
&lt;/config&gt;
</code></pre>
</li>
<li>重启 solr 服务，执行查询操作，查询结果的 spellcheck.suggestions.suggestion 下将会显示检查纠正的单词 word 和频率 freq<blockquote>
<p>参考 <a href="http://wiki.apache.org/solr/SpellCheckComponent">http://wiki.apache.org/solr/SpellCheckComponent</a></p>
</blockquote>
</li>
</ol>
</li>
<li><p><a href="http://www.cnblogs.com/wander1129/p/6658828.html">配置 solr 自带的中文分词（和 iK 的区别是不能自己添加词库）</a></p>
<ol>
<li><span id="setup_smartcn_analyzer">复制 lucene-analyzers-smartcn-7.3.1.jar 到 tomcat/webapps/solr/WEB-INF/lib/ 目录下</span><br> <code>cp solr-7.3.1/contrib/analysis-extras/lucene-libs/lucene-analyzers-smartcn-7.3.1.jar tomcat/webapps/solr/WEB-INF/lib/</code></li>
<li>编辑 managed-schema，在 <code>/schema/fieldType[@name=&quot;text_general&quot;]</code> 节点下，添加 analyzer 配置项，如下<pre><code class="xml">&lt;schema ...&gt;
    ...
    &lt;fieldType name=&quot;text_general&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;0&quot;&gt;
        ...
        &lt;analyzer type=&quot;index&quot;&gt;
            &lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory&quot;/&gt;
        &lt;/analyzer&gt;
        &lt;analyzer type=&quot;query&quot;&gt;
            &lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory&quot;/&gt;
        &lt;/analyzer&gt;
    &lt;/fieldType&gt;
    ...
&lt;/schema&gt;
</code></pre>
</li>
</ol>
</li>
<li><p><a href="http://www.cnblogs.com/wander1129/p/6658828.html">配置 ik 中文分词器</a><!-- http://www.cnblogs.com/zhuxiaojie/p/5764680.html --></p>
<ol>
<li><span id="setup_ik_analyzer">下载 <a href="http://files.cnblogs.com/files/wander1129/ikanalyzer-solr6.5.zip">IKAnalyzer</a></span><ol>
<li>复制 <a href="https://github.com/EugenePig/ik-analyzer-solr5">ik-analyzer-solr5-5.x.jar</a> 至 tomcat/webapps/solr/WEB-INF/lib 目录下</li>
<li>将 IKAnalyzer.cfg.xml、ext.dic、stopword.dic 复制到 tomcat/webapps/solr/WEB-INF/classes 目录下<blockquote>
<p>其中，文件  </p>
<ul>
<li>ext.dic 为扩展字典，可增加自己的扩展词典，如：唯品会 聚美优品  </li>
<li>stopword.dic 为停止词字典  </li>
<li>IKAnalyzer.cfg.xml 为配置文件  </li>
<li>solr-analyzer-ik-5.1.0.jar、ik-analyzer-solr5-5.x.jar 为分词 jar 包<br>stopword.dic、ext.dic 的编码方式为 UTF-8 无 BOM 的编码方式</li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li>编辑 managed-schema，在 <code>/schema/fieldType[@name=&quot;text_general&quot;]</code> 节点下，添加 analyzer 配置项，如下<pre><code class="xml">&lt;schema ...&gt;
    ...
    &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;
        &lt;analyzer type=&quot;index&quot;&gt;
            &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot;/&gt;
        &lt;/analyzer&gt;
        &lt;analyzer type=&quot;query&quot;&gt;
            &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot;/&gt;
        &lt;/analyzer&gt;
    &lt;/fieldType&gt;
    ...
&lt;/schema&gt;
</code></pre>
<blockquote>
<p>测试：</p>
<ol>
<li>建立字段如 summary，字段类型为 text_ik</li>
<li>建立索引数据如 { “id”: 1, “summary”: “明月装饰了你的窗子，你装饰了别人的梦。” }</li>
<li>执行查询语句如 <a href="http://localhost:8080/solr/xxx/select?q=summary:%E6%98%8E%E6%9C%88">http://localhost:8080/solr/xxx/select?q=summary:明月</a></li>
</ol>
</blockquote>
</li>
</ol>
</li>
<li><p>配置拼音检索&amp;简拼检索</p>
<ol>
<li>复制 pinyin4j-2.5.0.jar、<a href="https://github.com/liangbaolin/pinyinAnalyzer">pinyinAnalyzer.jar</a>（可从 <a href="http://files.cnblogs.com/files/wander1129/pinyin.zip">pinyin.zip</a> 中解压获取）至 tomcat/webapps/solr/WEB-INF/lib 目录下</li>
<li>下载并安装分词器 <a href="#setup_ik_analyzer">ik 中文分词器</a> <del>或 <a href="#setup_smartcn_analyzer">lucene-analyzers-smartcn 中文分词器</a></del></li>
<li>编辑 managed-schema，在 <code>/schema/fieldType[@name=&quot;text_pinyin&quot;]</code> 节点下，添加 analyzer 配置项，如下<pre><code class="xml">&lt;schema ...&gt;
    ...
    &lt;fieldType name=&quot;text_pinyin&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;0&quot;&gt;
        &lt;analyzer type=&quot;index&quot;&gt;
            &lt;tokenizer class=&quot;org.apache.lucene.analysis.ik.IKTokenizerFactory&quot;/&gt;&lt;!-- 依赖 ik 中文分词器 --&gt;
            &lt;!-- &lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory&quot;/&gt; --&gt;&lt;!-- 依赖 lucene-analyzers-smartcn 中文分词器 --&gt;
            &lt;filter class=&quot;com.shentong.search.analyzers.PinyinTransformTokenFilterFactory&quot; minTermLenght=&quot;2&quot; /&gt;
            &lt;filter class=&quot;com.shentong.search.analyzers.PinyinNGramTokenFilterFactory&quot; minGram=&quot;1&quot; maxGram=&quot;20&quot; /&gt;
        &lt;/analyzer&gt;
        &lt;analyzer type=&quot;query&quot;&gt;
            &lt;tokenizer class=&quot;org.apache.lucene.analysis.ik.IKTokenizerFactory&quot;/&gt;
            &lt;!-- &lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory&quot;/&gt; --&gt;
            &lt;filter class=&quot;com.shentong.search.analyzers.PinyinTransformTokenFilterFactory&quot; minTermLenght=&quot;2&quot; /&gt;
            &lt;filter class=&quot;com.shentong.search.analyzers.PinyinNGramTokenFilterFactory&quot; minGram=&quot;1&quot; maxGram=&quot;20&quot; /&gt;
        &lt;/analyzer&gt;
    &lt;/fieldType&gt;
    ...
&lt;/schema&gt;
</code></pre>
<blockquote>
<p>测试：</p>
<ol>
<li>建立字段如 summary，字段类型为 text_pinyin</li>
<li>建立索引数据如 { “id”: 1, “summary”: “明月装饰了你的窗子，你装饰了别人的梦。” }</li>
<li>执行查询语句如 <a href="http://localhost:8080/solr/xxx/select?q=summary:minyue">http://localhost:8080/solr/xxx/select?q=summary:minyue</a>、<a href="http://localhost:8080/solr/xxx/select?q=summary:my">http://localhost:8080/solr/xxx/select?q=summary:my</a>（简拼暂只适用于 ik 分词器）</li>
</ol>
</blockquote>
</li>
</ol>
</li>
<li><p><span id="config_uuid">配置自动生成 id</span></p>
<ol>
<li>编辑 managed-schema，在 <code>/schema</code> 节点下，新增 uuid 字段类型<pre><code class="xml">&lt;fieldType name=&quot;uuid&quot; class=&quot;solr.UUIDField&quot; indexed=&quot;true&quot; /&gt;
</code></pre>
 在 <code>/schema/field[@name=&quot;id&quot;]</code> 节点中，修改字段 id 的类型为 uuid<br> <code>sed -i &#39;s/&lt;field name=&quot;id&quot; type=&quot;string&quot;/&lt;field name=&quot;id&quot; type=&quot;uuid&quot;/g&#39; managed-schema</code>  </li>
<li>编辑 solrconfig.xml，在 <code>/config</code> 节点下，新增更新策略配置，调用 Solr 中的 UUIDUpdateProcessorFactory 生成全局唯一的 UUID<pre><code class="xml">&lt;updateRequestProcessorChain name=&quot;uuid&quot;&gt;
    &lt;processor class=&quot;solr.UUIDUpdateProcessorFactory&quot;&gt;
        &lt;str name=&quot;fieldName&quot;&gt;id&lt;/str&gt;
    &lt;/processor&gt;
    &lt;processor class=&quot;solr.LogUpdateProcessorFactory&quot; /&gt;
    &lt;processor class=&quot;solr.DistributedUpdateProcessorFactory&quot; /&gt;
    &lt;processor class=&quot;solr.RunUpdateProcessorFactory&quot; /&gt;
&lt;/updateRequestProcessorChain&gt;
</code></pre>
 在 <code>/config/requestHandler/lst</code> 节点下（配置 requestHandler 如 /dataimport、/update 等，使其能够自动生成 UUID），新增<span id="chain_uuid">自动生成 UUID 的策略</span>如下<pre><code class="xml">&lt;str name=&quot;update.chain&quot;&gt;uuid&lt;/str&gt;
</code></pre>
</li>
</ol>
</li>
<li><p>从 mysql 数据库中导入数据</p>
<ol>
<li><p>添加依赖 jar 包</p>
<ol>
<li>复制 solr-dataimporthandler-7.3.1.jar、solr-dataimporthandler-extras-7.3.1.jar 到 solr 的 lib 中<br> <code>cp solr-7.3.1/dist/solr-dataimporthandler-*.jar tomcat/webapps/solr/WEB-INF/lib/</code></li>
<li>下载 mysql 驱动包<br> <code>curl -O http://repo1.maven.org/maven2/mysql/mysql-connector-java/6.0.6/mysql-connector-java-6.0.6.jar</code></li>
<li>编辑 solrconfig.xml，在 <code>/config</code> 节点下，新增 DataImport、mysql-connector 的 lib 配置项如下<pre><code class="xml">&lt;lib dir=&quot;~/tomcat/webapps/solr/WEB-INF/lib&quot; regex=&quot;solr-dataimporthandler-\d.*\.jar&quot; /&gt;
&lt;lib dir=&quot;~/tomcat/webapps/solr/WEB-INF/lib&quot; regex=&quot;mysql-connector-java-\d.*\.jar&quot; /&gt;
</code></pre>
</li>
</ol>
</li>
<li><p>配置数据源</p>
<blockquote>
<p>例如，远程主机 192.168.128.137 上安装有 mysql 数据库服务，其中用户名为 test，密码为 test，现需要获取数据库 mysql 下数据表 user 中的数据，且取该表中列 Host、User、Password 数据并将其导入到索引库中。<br>默认情况下，mysql 中的 root 用户禁止远程访问，需要远程访问可参考配置 <a href="mysql.md#allow_root_remote">mysql 设置允许 root 用户远程访问</a></p>
</blockquote>
<ol>
<li>在 solrconfig.xml 同级目录下，新建配置文件 data-config.xml 并配置 dataConfig 信息<ul>
<li><span id="config_solr_dataConfig">方法一：直接配置数据源，配置内容如下</span><pre><code class="xml">&lt;dataConfig&gt;
    &lt;dataSource driver=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://192.168.128.137:3306/mysql&quot; user=&quot;test&quot; password=&quot;test&quot; /&gt;
    &lt;document&gt;
        &lt;entity name=&quot;user&quot; query=&quot;select Host, User, Password as Pass from user;&quot;&gt;
            &lt;field column=&quot;Host&quot; name=&quot;host&quot; /&gt;
            &lt;field column=&quot;User&quot; name=&quot;user&quot; /&gt;
            &lt;field column=&quot;Pass&quot; name=&quot;pass&quot; /&gt;
        &lt;/entity&gt;
    &lt;/document&gt;
&lt;/dataConfig&gt;
</code></pre>
</li>
<li><a href="https://www.cnblogs.com/edwinchen/p/3975004.html">方法二：使用 tomcat 数据源，即 jndi</a><ol>
<li><a href="tomcat.md#config_datasource">在 tomcat 中配置数据源</a></li>
<li>配置 dataConfig 信息同<a href="#config_solr_dataConfig">方法一</a>，其中节点 <code>/dataConfig/dataSource</code> 替换为以下内容<pre><code class="xml">&lt;dataSource name=&quot;solr&quot; jndiName=&quot;java:comp/env/jdbc/solr&quot; type=&quot;JdbcDataSource&quot;/&gt;
</code></pre>
 可配置多个 dataSource 节点可实现多数据源配置</li>
</ol>
</li>
</ul>
</li>
<li>编辑 managed-schema，在 <code>/schema</code> 节点下，新增字段（用于映射第一步中配置的 field）如下<pre><code class="xml">&lt;field name=&quot;host&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;false&quot; /&gt;
&lt;field name=&quot;user&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;false&quot; /&gt;
&lt;field name=&quot;pass&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;false&quot; /&gt;
</code></pre>
</li>
<li>编辑 solrconfig.xml 文件，在 <code>/config</code> 节点下，新增 requestHandler 配置项如下<pre><code class="xml">&lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;
    &lt;lst name=&quot;defaults&quot;&gt;
        &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt;
    &lt;/lst&gt;
&lt;/requestHandler&gt;
</code></pre>
</li>
<li>参照<a href="#config_uuid">配置自动生成 id</a>，在文件 solrconfig.xml 的 <code>/config/requestHandler[@name=&quot;/dataimport&quot;]/lst</code> 节点下，新增<a href="#chain_uuid">自动生成 UUID 的策略</a></li>
<li>进入页面 <a href="http://localhost:8080/solr/index.html#/core3/dataimport//dataimport">http://localhost:8080/solr/index.html#/core3/dataimport//dataimport</a> 执行导入操作</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p><a href="https://www.jianshu.com/p/2ac7dac7f6f2">solr 配置说明</a></p>
<ul>
<li>schema<ul>
<li><p><span id="schema_field"><a href="http://lucene.apache.org/solr/guide/6_6/defining-fields.html">field</a></span><br>  用于字段的定义（位于 <code>/schema</code> 节点下），如</p>
<pre><code class="xml">&lt;field name=&quot;title&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; multiValued=&quot;false&quot; /&gt;
</code></pre>
<blockquote>
<p>其中，属性  </p>
<ul>
<li><code>name</code> 标示这个字段的名称</li>
<li><code>type</code> 标示字段的类型，值对应 <a href="#schema_fieldType">fieldType</a> 元素的 name 属性值 <code>/schema/fieldType/@name</code></li>
<li><code>indexed</code> 定义文档是否被索引（也可以理解为是否在此字段上进行搜索），值为 true 或 false</li>
<li><code>stored</code> 定义这个字段内容是否存储（也可以理解为是否可以作为返回结果的一部分），值为 true 或 false<br><a href="#field_config_with_indexed_and_stored">字段 field 定义中的 indexed、stored 配置</a></li>
<li><code>multiValued</code> 这个字段是否存在多个值，如果存在多个值设置为 true</li>
</ul>
</blockquote>
</li>
<li><p><span id="schema_fieldType">fieldType</span></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>solr 接口调用</p>
<ol>
<li><p><a href="#config_core3">创建配置基本 Core 实例 core3</a></p>
</li>
<li><p>接口调用</p>
<ul>
<li><p><a href="http://lucene.apache.org/solr/guide/7_2/using-solrj.html">使用 solrj 调用 solr 接口</a></p>
<ol>
<li><p>引入 maven 依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;
    &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt;
    &lt;version&gt;7.3.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li><p>调用（完整实例可参考 <a href="https://gitee.com/904243852/Source/tree/master/java/snippets/3rdparty/SolrJExample.java">SolrJExample.java</a>）</p>
<ul>
<li><p>添加或修改索引</p>
<pre><code class="java">SolrClient client = new HttpSolrClient.Builder(&quot;http://127.0.0.1:8080/solr&quot;).build();

SolrInputDocument doc = new SolrInputDocument();

doc.addField(&quot;id&quot;, &quot;0a8f4e36-0f20-42d5-9d2d-c68343f6861f&quot;);
doc.addField(&quot;text&quot;, &quot;hello, world&quot;);

client.add(&quot;core3&quot;, doc);
client.commit(&quot;core3&quot;);

client.close();
</code></pre>
</li>
<li><p>查询</p>
<pre><code class="java">SolrClient client = new HttpSolrClient.Builder(&quot;http://127.0.0.1:8080/solr&quot;).build();

Map&lt;String, String&gt; queryParamMap = new HashMap&lt;String, String&gt;();
queryParamMap.put(&quot;q&quot;, &quot;*:*&quot;);
queryParamMap.put(&quot;fl&quot;, &quot;id, text&quot;);
MapSolrParams params = new MapSolrParams(queryParamMap);

QueryResponse response = client.query(&quot;core3&quot;, params);
SolrDocumentList documents = response.getResults();

for (SolrDocument document : documents) &#123;
    assertTrue(document.getFieldNames().contains(&quot;id&quot;));

    List&lt;String&gt; text = (List&lt;String&gt;) document.getFieldValue(&quot;text&quot;);
    assertEquals(&quot;hello, world&quot;, text.get(0));
&#125;

client.close();
</code></pre>
</li>
<li><p>删除索引</p>
<pre><code class="java">SolrClient client = new HttpSolrClient.Builder(&quot;http://127.0.0.1:8080/solr/core3&quot;).build();

client.deleteById(&quot;0a8f4e36-0f20-42d5-9d2d-c68343f6861f&quot;);
// client.deleteByQuery(&quot;id:0a8f4e36-0f20-42d5-9d2d-c68343f6861f&quot;);
// client.deleteByQuery(&quot;*:*&quot;);

client.commit();
client.close();
</code></pre>
</li>
</ul>
</li>
</ol>
</li>
<li><p>使用 python 调用 solr 接口</p>
<pre><code class="python">import json
import requests

# 查询
r = requests.get(&#39;http://127.0.0.1:8080/solr/core3/select?q=*:*&amp;wt=json&#39;, verify = False)
assert 0 &lt; r.json()[&#39;response&#39;][&#39;numFound&#39;]
print r.json()

# 索引
r = requests.post(&#39;http://127.0.0.1:8080/solr/core3/update?wt=json&#39;, json = &#123;
    &quot;add&quot;: &#123;
        &quot;doc&quot;: &#123; &quot;id&quot;: &quot;doc_2&quot;, &quot;text&quot;: &quot;hello, doc 2&quot; &#125;
    &#125;
&#125;, params = &#123; &quot;boost&quot;: 1.0, &quot;overwrite&quot;: &quot;true&quot;, &quot;commitWithin&quot;: 1000 &#125;, headers = &#123; &quot;Content-Type&quot;: &quot;application/json&quot; &#125;)
print r.text
</code></pre>
</li>
<li><p><a href="https://www.cnblogs.com/shaosks/p/7845576.html">使用 pysolr 调用 solr 接口</a></p>
<blockquote>
<p>安装 pysolr 模块<br>  <code>python -m pip install pysolr</code></p>
</blockquote>
<pre><code class="python">import pysolr

solr = pysolr.Solr(&#39;http://127.0.0.1:8080/solr/core3/&#39;, timeout = 10)

# 索引
result = solr.add([
    &#123; &quot;id&quot;: &quot;doc_1&quot;, &quot;text&quot;: &quot;hello, doc 1&quot; &#125;,
    &#123; &quot;id&quot;: &quot;doc_2&quot;, &quot;text&quot;: &quot;hello, doc 2&quot; &#125;
])
print result
</code></pre>
</li>
<li><p>直接调用 solr 接口</p>
<ul>
<li><p>单机（standalone）模式下添加/删除 core</p>
<ul>
<li>卸下 core 实例的同时，删除对应的 core 实例目录<br>  <code>curl http://127.0.0.1:8080/solr/admin/cores?action=UNLOAD&amp;deleteInstanceDir=true&amp;core=test</code></li>
</ul>
</li>
<li><p>新增/修改</p>
<ul>
<li>使用 post 方法提交 json 格式数据<br>  <code>curl -X POST -H &#39;Content-Type: application/json&#39; http://localhost:8080/solr/test/update?commit=true -d &#39;[&#123; &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 19, &quot;sex&quot;: &quot;male&quot; &#125;]&#39;</code><br>  <del><code>curl -X POST -H &#39;Content-Type: application/json&#39; http://localhost:8983/solr/xxx/update/json/docs -d &#39;&#123; &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;zhangsan&quot; &#125;&#39;</code></del></li>
<li>上传 json 文件<br>  <code>curl http://localhost:8080/solr/test/update?commit=true --data-binary @/temp/userinfo.json -H &#39;Content-type: application/json&#39;</code></li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li>删除所有数据<br>  <code>curl -X POST -H &#39;Content-type: application/json&#39; http://localhost:8080/solr/test/update?commit=true -d &#39;&#123; delete: &#123; query: &quot;*:*&quot; &#125; &#125;&#39;</code><br>  <del><code>curl -X POST -H &#39;Content-type: application/json&#39; http://localhost:8080/solr/test/update -d &#39;&#123; delete: &#123; query: &quot;name:zhangsan&quot; &#125;, commit: &#123;&#125; &#125;&#39;</code></del></li>
<li>根据 id 删除数据<br>  <code>curl -X POST -H &#39;Content-type: application/json&#39; http://localhost:8080/solr/test/update?commit=true -d &#39;&#123; delete: &#123; &quot;id&quot;: &quot;0a8f4e36-0f20-42d5-9d2d-c68343f6861f&quot; &#125;, delete: &#123; &quot;id&quot;: &quot;550e8400-e29b-41d4-a716-446655440000&quot; &#125; &#125;&#39;</code></li>
</ul>
</li>
<li><p>查询</p>
<blockquote>
<p><a href="http://www.cnblogs.com/zhangweizhong/p/5056884.html">查询参数</a></p>
<ul>
<li><code>q</code> 指定查询的关键字。例如，q=id:1，默认为 q=<em>:</em></li>
<li><code>fl</code> 指定返回哪些字段，用逗号或空格分隔，字段区分大小写。例如，fl=id,title,sort</li>
<li><code>start</code> 返回结果的第几条记录开始，一般分页用，默认 0 开始</li>
<li><code>rows</code> 指定返回结果最多有多少条记录，默认值为 10，配合 start 实现分页</li>
<li><code>sort</code> 排序方式，例如 id desc 表示按照 “id” 降序</li>
<li><code>wt</code> 指定输出格式，有 xml、json、php 等</li>
<li><code>fq</code> 过虑查询，提供一个可选的筛选器查询。返回在 q 查询符合结果中同时符合的 fq 条件的查询结果。例如，q=id:1&amp;fq=sort:[1 TO 5]，找关键字 id 为 1 的，并且 sort 是 1 到 5 之间的</li>
<li><code>df</code> 默认的查询字段，一般默认指定</li>
<li><code>qt</code> 指定那个类型来处理查询请求，一般不用指定，默认是 standard</li>
<li><code>indent</code> 返回的结果是否缩进，默认关闭，用 indent=true|on 开启，一般调试 json、php、phps、ruby 输出才有必要用这个参数</li>
<li><code>version</code> 查询语法的版本，建议不使用它，由服务器指定默认值</li>
</ul>
</blockquote>
<ul>
<li><p>常用查询<br>  查询 name 字段为 zhangsan 的数据，且在返回结果中只展示 name 字段<br>  <a href="http://localhost:8080/solr/test/select?name=zhangsan&amp;fl=name">http://localhost:8080/solr/test/select?name=zhangsan&amp;fl=name</a><br>  其他<br>  <a href="http://localhost:8080/solr/test/select?q=name:zhang">http://localhost:8080/solr/test/select?q=name:zhang</a><br>  <a href="http://localhost:8080/solr/test/select?q=name:&quot;zhang">http://localhost:8080/solr/test/select?q=name:&quot;zhang</a> san”<br>  <a href="http://localhost:8080/solr/test/select?q=zhang">http://localhost:8080/solr/test/select?q=zhang</a> san&amp;df=name</p>
</li>
<li><p>词权重查询<br>  使用 dismax 查询解析器查询关键词 zhangsan<br>  <a href="http://localhost:8080/solr/test/select?defType=dismax&fl=name,age&q=zhangsan&qf=name%5E0+age%5E1.0">http://localhost:8080/solr/test/select?defType=dismax&amp;fl=name,age&amp;q=zhangsan&amp;qf=name^0 age^1.0</a><br>  使用 edismax 查询解析器查询关键词 zhangsan<br>  <a href="http://localhost:8080/solr/test/select?bq=sex:female%5E3&defType=edismax&fl=name,age&q=zhangsan&qf=name%5E0+age%5E1.0">http://localhost:8080/solr/test/select?bq=sex:female^3.0&amp;defType=editmax&amp;fl=name,age&amp;q=zhangsan&amp;qf=name^0 age^1.0</a></p>
<blockquote>
<p>其中，查询参数  </p>
<ul>
<li><code>defType</code> 指定查询（词权重）解析器，值可以为 dismax、edismax  </li>
<li><code>qf</code> 即 query field，指定 q 中的词项要在哪些字段上执行查询。可以设置多列以及每一列的权重。如 name^0.1 age^2.0</li>
<li><code>bq</code>（edismax）接受一个和 q 一样的查询，它和 q 的区别是不影响返回的结果集，只会影响排名</li>
<li><code>bf</code>（edismax）提升函数，通过数学公式来影响评分，而且不局限在 qf 中的字段  </li>
</ul>
</blockquote>
<blockquote>
<p>通过附加参数 <code>fl=name, age, [explain]</code>，可以直接在结果中查看 name、age、权重计算详细值</p>
</blockquote>
</li>
<li><p>其他查询参数</p>
<ul>
<li>使用 facet 聚合查询<br>  <code>facet=on&amp;facet.field=color&amp;facet.field=memory</code></li>
<li>开启 debug 调试<br>  <code>debugQuery=on</code></li>
</ul>
</li>
<li><p>DateField 类型的查询<br>  例如，字段 publishTime 为 DateField 类型</p>
<pre><code class="javascript">// [] 包含范围检索，如检索某时间段记录，包含头尾，date:[200707 TO 200710]，&#123;&#125; 不包含范围检索，如检索某时间段记录，不包含头尾

// 查询 2015 年 8 月 28 日当天的数据
publishTime:[publishTime:[2015-08-28T00:00:00Z TO 2015-08-28T23:59:59.999Z]
// 查询 2015 年 8 月 28 日以后的数据，包含当天的数据
publishTime:[publishTime:[2015-08-28T00:00:00Z TO *]

// 查询 2015 年 8 月 28 日以前的数据
publishTime:[publishTime:[* TO 2015-08-28T00:00:00Z]
// 或
publishTime:[publishTime:[* TO 2015-08-27T23:59:59.999Z]
</code></pre>
</li>
</ul>
</li>
<li><p>Schema API<br>  使用 curl 发送 post 请求，格式如下<br>  <code>curl -X POST -H &#39;Content-type:application/json&#39; http://localhost:8080/solr/test/schema --data-binary &#39;$JSON_REQUEST&#39;</code><br>  其中请求的正文 $JSON_REQUEST 内容可参考以下</p>
<ul>
<li>field（field 各属性可参考 <a href="#schema_field">field 定义</a>）<ul>
<li>创建 field<pre><code class="json">&#123; &quot;add-field&quot;: &#123; &quot;name&quot;:&quot;sell-by&quot;, &quot;type&quot;:&quot;tdate&quot;, &quot;stored&quot;:true &#125; &#125;
</code></pre>
</li>
<li>删除 field<pre><code class="json">&#123; &quot;delete-field&quot;: &#123; &quot;name&quot;:&quot;sell-by&quot; &#125; &#125;
</code></pre>
</li>
<li>替换 field<pre><code class="json">&#123; &quot;replace-field&quot;: &#123; &quot;name&quot;:&quot;sell-by&quot;, &quot;type&quot;:&quot;tdate&quot;, &quot;stored&quot;:true &#125; &#125;
</code></pre>
</li>
</ul>
</li>
<li>dynamic field<ul>
<li>创建 dynamic field<pre><code class="json">&#123; &quot;add-dynamic-field&quot;: &#123; &quot;name&quot;:&quot;*_s&quot;, &quot;type&quot;:&quot;string&quot;, &quot;stored&quot;:true &#125; &#125;
</code></pre>
</li>
<li>删除 dynamic field<pre><code class="json">&#123; &quot;delete-dynamic-field&quot;: &#123; &quot;name&quot;:&quot;*_s&quot; &#125; &#125;
</code></pre>
</li>
<li>替换 dynamic field<pre><code class="json">&#123; &quot;replace-dynamic-field&quot;: &#123; &quot;name&quot;:&quot;*_s&quot;, &quot;type&quot;:&quot;text_general&quot;, &quot;stored&quot;:false  &#125; &#125;
</code></pre>
</li>
</ul>
</li>
<li>field type<ul>
<li>创建 field type<pre><code class="json">&#123;
    &quot;add-field-type&quot; : &#123;
        &quot;name&quot;:&quot;myNewTxtField&quot;,
        &quot;class&quot;:&quot;solr.TextField&quot;,
        &quot;positionIncrementGap&quot;:&quot;100&quot;,
        &quot;analyzer&quot; : &#123;
            &quot;charFilters&quot;:[&#123;
            &quot;class&quot;:&quot;solr.PatternReplaceCharFilterFactory&quot;,
            &quot;replacement&quot;:&quot;$1$1&quot;,
            &quot;pattern&quot;:&quot;([a-zA-Z])\\\\1+&quot; &#125;],
            &quot;tokenizer&quot;:&#123;
            &quot;class&quot;:&quot;solr.WhitespaceTokenizerFactory&quot; &#125;,
            &quot;filters&quot;:[&#123;
            &quot;class&quot;:&quot;solr.WordDelimiterFilterFactory&quot;,
            &quot;preserveOriginal&quot;:&quot;0&quot; &#125;]&#125;&#125;
&#125;
</code></pre>
</li>
<li>删除 field type<pre><code class="json">&#123; &quot;delete-field-type&quot;:&#123; &quot;name&quot;:&quot;myNewTxtField&quot; &#125; &#125;
</code></pre>
</li>
<li>替换 field type<pre><code class="json">&#123;
    &quot;replace-field-type&quot;:&#123;
        &quot;name&quot;:&quot;myNewTxtField&quot;,
        &quot;class&quot;:&quot;solr.TextField&quot;,
        &quot;positionIncrementGap&quot;:&quot;100&quot;,
        &quot;analyzer&quot;:&#123;
            &quot;tokenizer&quot;:&#123;
            &quot;class&quot;:&quot;solr.StandardTokenizerFactory&quot; &#125;&#125;&#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li>copy field<blockquote>
<p>多个 json 格式请求正文也可同时/批量发送，如</p>
<pre><code class="json">&#123;
    &quot;add-field&quot;:&#123;
        &quot;name&quot;:&quot;shelf&quot;,
        &quot;type&quot;:&quot;myNewTxtField&quot;,
        &quot;stored&quot;:true &#125;,
    &quot;add-field&quot;:&#123;
        &quot;name&quot;:&quot;location&quot;,
        &quot;type&quot;:&quot;myNewTxtField&quot;,
        &quot;stored&quot;:true &#125;,
    &quot;add-copy-field&quot;:&#123;
        &quot;source&quot;:&quot;shelf&quot;,
        &quot;dest&quot;:[ &quot;location&quot;, &quot;catchall&quot; ]&#125;
&#125;
</code></pre>
</blockquote>
</li>
</ul>
</li>
<li><p>Config API</p>
<ul>
<li><p>查询 requestHandler 配置<br>  <code>curl http://localhost:8080/solr/test/config/requestHandler</code></p>
<p>使用 curl 发送 post 请求，格式如下<br><code>curl http://localhost:8080/solr/test/config -H &#39;Content-type:application/json&#39;  -d &#39;$JSON_REQUEST&#39;</code><br>其中请求的正文 $JSON_REQUEST 内容可参考以下</p>
</li>
<li><p>修改 requesthandler 配置  </p>
<pre><code class="json">&#123;
    &quot;update-requesthandler&quot;: &#123;
        &quot;name&quot;: &quot;/select&quot;,
        &quot;class&quot;: &quot;solr.SearchHandler&quot;,
        &quot;defaults&quot;: &#123;
            &quot;defType&quot;: &quot;dismax&quot;,
            &quot;qf&quot;: &quot;name^10 summary^1&quot; &#125; &#125; &#125;
</code></pre>
</li>
</ul>
</li>
<li><p>cloud 模式下，新增、删除副本<br>  删除一个副本<br>  <code>curl http://localhost:8080/admin/collections?action=DELETEREPLICA&amp;collection=prodIndex&amp;shard=shard1&amp;replica=core_node3</code><br>  新增一个副本<br>  <code>curl http://localhost:8080/admin/collections?action=ADDREPLICA&amp;collection=prodIndex&amp;shard=shard1&amp;node=192.168.1.102:8080_</code></p>
</li>
<li><p>集群模式下，查询指定的 shard 或 replica</p>
<pre><code class="bash">curl http://localhost:8080/solr/test?q=*:*&amp;shards=shard1 # 指定 shard，多个分片名称以“,”分隔
curl http://localhost:8080/solr/test?q=*:*&amp;shards=localhost:8081/solr/test # 指定 replica，多个副本地址以“|”分隔
</code></pre>
</li>
<li><p>检测索引文件<br>  <code>java -cp $CATALINA_HOME/webapps/solr/WEB-INF/lib/lucene-core-*.jar -ea:org.apache.lucene... org.apache.lucene.index.CheckIndex $CATALINA_HOME/solrhome/prodIndex</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>solr 源码解析</p>
<pre><code class="java">// 获取 solrHome 路径
Path solrHome = org.apache.solr.core.SolrResourceLoader.locateSolrHome();
</code></pre>
</li>
</ul>
<h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><ul>
<li><p><a href="https://www.cnblogs.com/rcfeng/p/4287030.html">Recovery 失败造成的宕机原因分析</a><br>  <a href="http://i.ifeng.com/lady/vnzq/news?cid=0&aid=120274197">solrcloud Recovery 原理及无法选举分片 leader</a></p>
</li>
<li><p><span id="field_config_with_indexed_and_stored">字段 field 定义中的 indexed、stored 配置</span></p>
<blockquote>
<p>stored、docValues、indexed 未指定为 false 时，默认值均为 true</p>
</blockquote>
<ol>
<li>indexed = false<br> <code>curl -X POST -H &#39;Content-type:application/json&#39; http://localhost:8080/solr/test/schema --data-binary &#39;&#123; &quot;replace-field&quot;: &#123; &quot;name&quot;:&quot;sex&quot;, &quot;type&quot;:&quot;string&quot;, &quot;indexed&quot;:false &#125; &#125;&#39;</code><ul>
<li>新增数据<br>  <code>&#123; &quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 18, &quot;sex&quot;: &quot;male&quot; &#125;</code></li>
<li>查询<ul>
<li><code>q=*:*</code> 同 4</li>
<li><code>q=sex:male</code><pre><code class="json">&#123; &quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;male&quot;, &quot;id&quot;:&quot;...&quot;, &quot;_version_&quot;:... &#125;,
&#123; &quot;name&quot;:&quot;zhaoliu&quot;, &quot;age&quot;:21, &quot;id&quot;:&quot;...&quot;, &quot;_version_&quot;:..., &quot;sex&quot;:&quot;male&quot; &#125;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>stored = false, docValues = false<br> <code>curl -X POST -H &#39;Content-type:application/json&#39; http://localhost:8080/solr/test/schema --data-binary &#39;&#123; &quot;replace-field&quot;: &#123; &quot;name&quot;:&quot;sex&quot;, &quot;type&quot;:&quot;string&quot;, &quot;stored&quot;:false, &quot;docValues&quot;:false &#125; &#125;&#39;</code><ul>
<li>新增数据<br>  <code>&#123; &quot;name&quot;: &quot;lisi&quot;, &quot;age&quot;: 19, &quot;sex&quot;: &quot;female&quot; &#125;</code></li>
<li>查询<ul>
<li><code>q=*:*</code> 同 4</li>
<li><code>q=sex:male</code> 同 4</li>
</ul>
</li>
</ul>
</li>
<li>stored = false, docValues = false, indexed = false<br> <code>curl -X POST -H &#39;Content-type:application/json&#39; http://localhost:8080/solr/test/schema --data-binary &#39;&#123; &quot;replace-field&quot;: &#123; &quot;name&quot;:&quot;sex&quot;, &quot;type&quot;:&quot;string&quot;, &quot;stored&quot;:false, &quot;docValues&quot;:false, &quot;indexed&quot;:false &#125; &#125;&#39;</code><ul>
<li>新增数据<br>  <code>&#123; &quot;name&quot;: &quot;wangwu&quot;, &quot;age&quot;: 20, &quot;sex&quot;: &quot;unknow&quot; &#125;</code></li>
<li>查询<ul>
<li><code>q=*:*</code> 同 4</li>
<li><code>q=sex:male</code> 同 4</li>
</ul>
</li>
</ul>
</li>
<li>stored = false<br> <code>curl -X POST -H &#39;Content-type:application/json&#39; http://localhost:8080/solr/test/schema --data-binary &#39;&#123; &quot;replace-field&quot;: &#123; &quot;name&quot;:&quot;sex&quot;, &quot;type&quot;:&quot;string&quot;, &quot;stored&quot;:false &#125; &#125;&#39;</code><ul>
<li>新增数据<br>  <code>&#123; &quot;name&quot;: &quot;zhaoliu&quot;, &quot;age&quot;: 21, &quot;sex&quot;: &quot;male&quot; &#125;</code></li>
<li>查询<ul>
<li><code>q=*:*</code><pre><code class="json">&#123; &quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;male&quot;, &quot;id&quot;:&quot;...&quot;, &quot;_version_&quot;:... &#125;,
&#123; &quot;name&quot;:&quot;lisi&quot;, &quot;age&quot;:19, &quot;id&quot;:&quot;...&quot;, &quot;_version_&quot;:..., &quot;sex&quot;:&quot;female&quot; &#125;,
&#123; &quot;name&quot;:&quot;wangwu&quot;, &quot;age&quot;:20, &quot;id&quot;:&quot;...&quot;, &quot;_version_&quot;:... &#125;,
&#123; &quot;name&quot;:&quot;zhaoliu&quot;, &quot;age&quot;:21, &quot;id&quot;:&quot;...&quot;, &quot;_version_&quot;:..., &quot;sex&quot;:&quot;male&quot; &#125;
</code></pre>
</li>
<li><code>q=sex:male</code><pre><code class="json">&#123; &quot;name&quot;:&quot;zhaoliu&quot;, &quot;age&quot;:21, &quot;id&quot;:&quot;...&quot;, &quot;_version_&quot;:..., &quot;sex&quot;:&quot;male&quot; &#125;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>indexed = true, stored = false<br> 可搜索（到这条记录），但不返回结果（不能返回该字段的值或原始文档）</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>solr</category>
      </categories>
      <tags>
        <tag>solr</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat</title>
    <url>/2025/03/22/tomcat/</url>
    <content><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><ul>
<li><p>环境搭建</p>
<ol>
<li>下载 tomcat-8.5.31.zip<br> <code>curl -O http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.5.31/bin/apache-tomcat-8.5.31.zip</code></li>
<li>解压 tomcat-8.5.31.zip<br> <code>unzip -q apache-tomcat-8.5.31.zip</code></li>
<li>创建 tomcat 软连接<br> <code>ln -s apache-tomcat-8.5.31 tomcat</code></li>
</ol>
</li>
<li><p><span id="start-or-stop-tomcat">停止、启动 Tomcat 服务</span></p>
<ol>
<li>切换至 $CATALINA_HOME/bin 目录<br> <code>cd tomcat/bin</code></li>
<li>停止、启动服务<ul>
<li>停止服务<br>  <code>./shutdown.sh</code><br>  <code>ps -ef | grep tomcat | grep -v grep | awk &#39;&#123;print $2&#125;&#39; | xargs kill -s 9</code></li>
<li>启动服务<br>  <code>./startup.sh</code></li>
</ul>
</li>
<li>返回目录<br> <code>cd -</code></li>
</ol>
</li>
<li><p><span id="tomcat-setup-ssl">开启 SSL</span></p>
<ol>
<li><a href="java.md#createKeystore">创建 keystore 文件</a>(如 tomcat.keystore)<br> <code>keytool -genkeypair -alias tomcat -keyalg RSA -keystore keystore.jks</code><br> 根据提示输入证书信息，如密码为 123456</li>
<li>将 keystore.jks 移动至 $CATALINA_HOME/conf 目录下<br> <code>mv keystore.jks tomcat/conf</code></li>
<li>编辑文件 $CATALINA_HOME/conf/server.xml，在 <code>/Server/Service/Connector[@port=&quot;8443&quot;]</code> 节点中，配置 keystoreFile 和 keystorePass，如下<pre><code class="xml">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;
            maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
            clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot;
            keystoreFile=&quot;$&#123;catalina.home&#125;/conf/keystore.jks&quot; keystorePass=&quot;123456&quot;/&gt;
</code></pre>
</li>
<li><a href="#start-or-stop-tomcat">重新启动 Tomcat 服务</a></li>
<li>在浏览器中访问如：<a href="https://localhost:8443/xxx/">https://localhost:8443/xxx/</a></li>
</ol>
</li>
<li><p><a href="https://www.cnblogs.com/Before/p/4244167.html">配置 SSL 双向认证</a></p>
<ol>
<li><p><span id="keytool">（在 $CATALINA_HOME/conf 目录下）生成密钥库和证书</span></p>
<ol>
<li>生成服务器证书库 server.jks<br> <code>keytool -validity 365 -genkey -v -alias server -keyalg RSA -keystore server.jks -dname &quot;CN=127.0.0.1,OU=NA,O=NA,L=NA,ST=NA,c=NA&quot; -storepass 123456 -keypass 123456</code></li>
<li>从服务器证书库中导出服务器证书 server.cer<br> <code>keytool -export -v -alias server -keystore server.jks -storepass 123456 -rfc -file server.cer</code></li>
<li>生成客户端证书库 client.p12<br> <code>keytool -validity 365 -genkeypair -v -alias client -keyalg RSA -storetype PKCS12 -keystore client.p12 -dname &quot;CN=client&quot; -storepass 123456 -keypass 123456</code></li>
<li>从客户端证书库中导出客户端证书 client.cer<br> <code>keytool -export -v -alias client -keystore client.p12 -storetype PKCS12 -storepass 123456 -rfc -file client.cer</code></li>
<li>将客户端证书导入到服务器证书库（使得服务器信任客户端证书）<br> <code>keytool -import -v -alias client -file client.cer -keystore server.jks -storepass 123456 -noprompt</code></li>
<li><del>生成客户端信任证书库（由服务端证书生成的证书库）<br> <code>keytool -import -v -alias server -file server.cer -keystore client.truststore -storepass 123456 -noprompt</code></del><blockquote>
<ul>
<li>查看证书库中的全部证书<br><code>keytool -list -keystore server.jks -storepass 123456</code></li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li><p>编辑文件 $CATALINA_HOME/conf/server.xml，在 <code>/Server/Service/Connector[@port=&quot;8443&quot;]</code> 节点中，配置如下</p>
<pre><code class="xml">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; SSLEnabled=&quot;true&quot;
            maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
            clientAuth=&quot;true&quot; sslProtocol=&quot;TLS&quot;
            keystoreFile=&quot;$&#123;catalina.base&#125;/conf/server.jks&quot; keystorePass=&quot;123456&quot;
            truststoreFile=&quot;$&#123;catalina.base&#125;/conf/server.jks&quot; truststorePass=&quot;123456&quot;/&gt;
</code></pre>
<blockquote>
<ul>
<li><a href="https://www.cnblogs.com/tianjifa/p/9533092.html">servlet 中获取客户端证书</a><pre><code class="java">// HttpServletRequest request = ...
X509Certificate[] chain = (X509Certificate[]) request.getAttribute(&quot;javax.servlet.request.X509Certificate&quot;);
</code></pre>
</li>
</ul>
</blockquote>
</li>
<li><p>（可选）配置角色权限</p>
<ol>
<li><p>编辑文件 $CATALINA_HOME/conf/server.xml，开启 8080 端口（此处用于释放普通权限，对比区别于第二步中配置的权限），配置如下</p>
<pre><code class="xml">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
            connectionTimeout=&quot;20000&quot;
            redirectPort=&quot;8443&quot; /&gt;
</code></pre>
</li>
<li><p>编辑 $CATALINA_HOME/webapps/*/WEB-INF/web.xml 文件，在 <code>/web-app</code> 节点下，添加 security-constraint、login-config 配置如下</p>
<pre><code class="xml">&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;SSL&lt;/web-resource-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;user-data-constraint&gt;
        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
    &lt;security-role&gt;
        &lt;role-name&gt;admin4cert&lt;/role-name&gt;
    &lt;/security-role&gt;
&lt;/security-constraint&gt;
&lt;login-config&gt;
    &lt;auth-method&gt;CLIENT-CERT&lt;/auth-method&gt;
&lt;/login-config&gt;
</code></pre>
</li>
<li><p>编辑 tomcat-users.xml 文件，在 <code>/tomcat-users</code> 节点下，配置角色、用户如下</p>
<pre><code class="xml">&lt;role rolename=&quot;admin4cert&quot; /&gt;

&lt;user username=&quot;CN=client&quot; password=&quot;null&quot; roles=&quot;admin4cert&quot; /&gt;
</code></pre>
</li>
</ol>
</li>
<li><p><a href="#start-or-stop-tomcat">重新启动 Tomcat 服务</a></p>
</li>
<li><p>安装证书 client.p12</p>
</li>
<li><p>在浏览器中访问如：<a href="https://localhost:8443/">https://localhost:8443/</a></p>
</li>
</ol>
</li>
<li><p><a href="https://www.jianshu.com/p/2b4a587db5cb">配置多个虚拟主机与 HTTPS 证书</a></p>
<ol>
<li><p>编辑 $CATALINA_HOME/conf/server.xml 文件，配置 <code>/Server/Service/Connector</code> 节点如下</p>
<pre><code class="xml">&lt;Connector port=&quot;443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;
           maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; URIEncoding=&quot;UTF-8&quot; defaultSSLHostConfigName=&quot;domain.com&quot;&gt;

    &lt;SSLHostConfig hostName=&quot;domain.com&quot; caCertificateFile=&quot;conf/ca.pem&quot;&gt;
        &lt;Certificate certificateKeyFile=&quot;conf/domain.key&quot;
                     certificateFile=&quot;conf/domain.crt&quot;
                     type=&quot;RSA&quot; /&gt;
    &lt;/SSLHostConfig&gt;

    &lt;SSLHostConfig hostName=&quot;x1.domain.top&quot; caCertificateFile=&quot;conf/ca.pem&quot;&gt;
        &lt;Certificate certificateKeyFile=&quot;conf/x1.key&quot;
                     certificateFile=&quot;conf/x1.crt&quot;
                     type=&quot;RSA&quot; /&gt;
    &lt;/SSLHostConfig&gt;
&lt;/Connector&gt;
</code></pre>
</li>
</ol>
</li>
<li><p>全局/局部 url 转换成 https 访问配置（需 <a href="#tomcat-setup-ssl">Tomcat 安装 SSL 证书</a>）<br>  编辑 $CATALINA_HOME/webapps/*/WEB-INF/web.xml 文件，在 <code>/web-app</code> 节点下，添加 security-constraint 配置如下</p>
<pre><code class="xml">&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;SSL&lt;/web-resource-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!-- 全局转换成 https 访问 --&gt;
        &lt;!-- &lt;url-pattern&gt;/test/*&lt;/url-pattern&gt; --&gt;&lt;!-- 局部使用 https 访问，即当访问路径包括 test 的时候，就会强制转换为 https --&gt;
    &lt;/web-resource-collection&gt;
    &lt;user-data-constraint&gt;
        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
&lt;/security-constraint&gt;
</code></pre>
<blockquote>
<p>web-resource-collection 节点可以配置多个，url-pattern 为配置需要强制 https 的 url</p>
</blockquote>
</li>
<li><p><a href="https://stackoverflow.com/questions/30855281/tomcat-support-for-http-2-0">配置 http 2.0（需 tomcat 版本 &gt;= 8.5）</a>  </p>
<ol>
<li><a href="#setup-native-connector">安装 Tomcat Native Connector</a></li>
<li>配置证书（http 2.0 需强制开启 https）<br> <code>openssl req -nodes -new -x509 -keyout $CATALINA_HOME/conf/localhost-rsa-key.pem -out $CATALINA_HOME/conf/localhost-rsa-cert.pem</code></li>
<li>编辑 $CATALINA_HOME/conf/server.xml 文件，配置 <code>/Server/Service/Connector</code> 节点如下<pre><code class="xml">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;
       maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; &gt;
    &lt;UpgradeProtocol className=&quot;org.apache.coyote.http2.Http2Protocol&quot; /&gt;
    &lt;SSLHostConfig&gt;
        &lt;Certificate certificateKeyFile=&quot;conf/localhost-rsa-key.pem&quot;
                    certificateFile=&quot;conf/localhost-rsa-cert.pem&quot;
                    type=&quot;RSA&quot; /&gt;
    &lt;/SSLHostConfig&gt;
&lt;/Connector&gt;
</code></pre>
</li>
</ol>
</li>
<li><p>开启远程调试</p>
<ul>
<li>windows 环境下，在 $CATALINA_HOME/bin/catalina.bat 中添加<br>  <code>SET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8899</code> </li>
<li>linux 环境下，在 $CATALINA_HOME/bin/catalina.sh 中添加<br>  <code>CATALINA_OPTS=&quot;-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8899&quot;</code></li>
</ul>
</li>
<li><p>监控资源文件，文件修改了，则自动重新加载该应用<br>  编辑配置文件（即<a href="#config-datasource">在 Tomcat 中配置数据源</a>中涉及的配置文件），在 <code>//Context</code> 节点下，添加 WatchedResource 配置如下</p>
<pre><code class="xml">&lt;WatchedResource&gt;WEB-INF/web.xml&lt;/WatchedResource&gt;
</code></pre>
<p>  可配置多个 WatchedResource 节点以监听不同文件，当 WatchedResource 中的文件发生修改变动时，当前的 webapp 将自动重新加载</p>
</li>
<li><p><span id="tomcat-protocol"><a href="https://www.cnblogs.com/dijia478/p/8085143.html">Tomcat 在 Linux 服务器上的 BIO、NIO、APR 模式设置</a></span></p>
<ul>
<li>BIO 模式<br>  BIO（blocking I/O），顾名思义，即阻塞式 I/O 操作，表示Tomcat使用的是传统的 Java I/O 操作（即 java.io 包及其子包）。Tomcat 在默认情况下，就是以 bio 模式运行的。遗憾的是，就一般而言，bio 模式是三种运行模式中性能最低的一种。我们可以通过 Tomcat Manager 来查看服务器的当前状态。<pre><code class="xml">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;
       connectionTimeout=&quot;20000&quot;
       redirectPort=&quot;8443&quot; /&gt;
</code></pre>
</li>
<li>NIO 模式<br>  NIO 是 Java SE 1.4 及后续版本提供的一种新的 I/O 操作方式（即 java.nio 包及其子包）。Java nio 是一个基于缓冲区、并能提供非阻塞 I/O 操作的 Java API，因此nio也被看成是 non-blocking I/O 的缩写。它拥有比传统 I/O 操作（bio）更好的并发运行性能。<pre><code class="xml">&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;
       connectionTimeout=&quot;20000&quot;
       redirectPort=&quot;8443&quot; /&gt;
</code></pre>
</li>
<li>APR 模式<br>  APR（Apache Portable Runtime/Apache 可移植运行库），是 Apache HTTP 服务器的支持库。你可以简单地理解为，Tomcat 将以 JNI 的形式调用 Apache HTTP 服务器的核心动态链接库来处理文件读取或网络传输操作，从而大大地提高 Tomcat 对静态文件的处理性能。Tomcat apr 也是在 Tomcat 上运行高并发应用的首选模式。（需依赖安装 apr、apr-util、tomcat-native）<ol>
<li><span id="setup-native-connector">下载并安装 <a href="https://tomcat.apache.org/download-native.cgi">Tomcat Native Connector</a></span><ul>
<li>windows<br>  <code>curl -O http://mirror.bit.edu.cn/apache/tomcat/tomcat-connectors/native/1.1.34/binaries/tomcat-native-1.1.34-win32-bin.zip</code><br>  <code>unzip -j -q tomcat-native-1.1.34-win32-bin.zip &#39;bin/x64/tcnative-1.dll&#39; -d $CATALINA_HOME/bin</code></li>
</ul>
</li>
<li>编辑 $CATALINA_HOME/conf/server.xml 文件，修改属性 <code>/Server/Service/Connector@protocol</code> 为 <code>org.apache.coyote.http11.Http11AprProtocol</code> 如下<pre><code class="xml">&lt;Connector port=&quot;8080&quot; protocol=&quot;org.apache.coyote.http11.Http11AprProtocol&quot;
    connectionTimeout=&quot;20000&quot;
    redirectPort=&quot;8443&quot; /&gt;
</code></pre>
</li>
</ol>
</li>
</ul>
</li>
<li><p><span id="config-datasource">在 Tomcat 中配置数据源</span></p>
<ol>
<li>编辑配置文件<ul>
<li><span id="config-datasource-method-1">方法一：在 $CATALINA_HOME/conf/Catalina/localhost 目录下创建配置文件（文件名称应与 webapp 同名，如 solr.xml，对应 webapps 目录下的 solr 应用），配置信息如下</span><pre><code class="xml">&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;
&lt;Context path=&quot;/solr&quot; docBase=&quot;solr&quot; workDir=&quot;solr&quot;&gt;
    &lt;Resource name=&quot;jdbc/solr&quot; type=&quot;javax.sql.DataSource&quot; auth=&quot;Container&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; url=&quot;jdbc:mysql://127.0.0.1:3306/solr&quot; validationQuery=&quot;select 1 from dual&quot; username=&quot;test&quot; password=&quot;123456&quot; /&gt;
&lt;/Context&gt;
</code></pre>
</li>
<li>方法二：编辑 $CATALINA_HOME/conf/context.xml 文件（区别与 server.xml，该文件修改后，tomcat 将会自动重新加载该文件，而无需重启 tomcat）<br>  在 <code>/</code> 节点下，添加 Context 配置信息（同<a href="#config-datasource-method-1">方法一</a>的 Context 配置信息）</li>
<li>方法三：编辑 $CATALINA_HOME/conf/server.xml 文件（不推荐，server.xml 是不可动态重加载的资源，即修改后必须重启 tomcat 才会生效）<br>  在 <code>/Server/Service/Engine</code> 节点下，添加 Context 配置信息（同<a href="#config-datasource-method-1">方法一</a>的 Context 配置信息）</li>
</ul>
</li>
<li>添加数据库驱动引用（如 mysql-connector-java-6.0.6.jar）至 $CATALINA_HOME/lib 中</li>
</ol>
</li>
<li><p>在 webapp 中引用 Tomcat 中配置的数据源</p>
<ol>
<li><p><a href="#config-datasource">在 Tomcat 中配置数据源</a></p>
</li>
<li><p>编辑 $CATALINA_HOME/webapps/*/WEB-INF/web.xml 文件，在 <code>/web-app</code> 节点下，添加 resource-ref 配置如下</p>
<pre><code class="xml">&lt;resource-ref&gt;
    &lt;res-ref-name&gt;jdbc/solr&lt;/res-ref-name&gt;
    &lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;
    &lt;res-auth&gt;Container&lt;/res-auth&gt;
&lt;/resource-ref&gt;
</code></pre>
</li>
<li><p>添加数据库驱动引用（如 mysql-connector-java-6.0.6.jar）至 $CATALINA_HOME/webapps/*/WEB-INF/lib 目录下</p>
</li>
<li><p>使用</p>
<pre><code class="java">&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%@ page import=&quot;java.sql.*,javax.sql.*,javax.naming.*&quot; %&gt;

&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;JNDI Test&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;%
            Connection connection = null;
            try &#123;
                // 初始化名称查找上下文
                Context ctx = new InitialContext();

                // 通过 JNDI 名称找到 DataSource，格式为 java:comp/env/DataSourceName
                DataSource ds = (DataSource) ctx.lookup(&quot;java:comp/env/jdbc/solr&quot;);

                // 通过 DataSource 取得一个连接
                connection = ds.getConnection();

                // 操作数据库，实现增删改查等
                // ...
            &#125; catch (NamingException e) &#123;
                e.printStackTrace();
            &#125; catch (SQLException e) &#123;
                e.printStackTrace();
            &#125; finally &#123;
                // 关闭数据库，关闭的时候是将连接放回到连接池之中
                connection.close();
            &#125;
        %&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</li>
</ol>
</li>
<li><p>认证配置<br>  Tomcat 支持四种认证方式：<a href="http://www.cnblogs.com/dengyungao/p/7542241.html">BASIC（基本验证）、DIGEST（摘要验证）、FORM（基于表单的验证）、CLIENT-CERT（客户证书验证）</a></p>
<ul>
<li><p>BASIC（基本验证）</p>
<ol>
<li><p><span id="config-security-constraint-for-basic">配置 security-constraint</span><br> 编辑 $CATALINA_HOME/webapps/*/WEB-INF/web.xml 文件，在 <code>/web-app</code> 节点下，添加配置如下</p>
<pre><code class="xml">&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;auth field&lt;/web-resource-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;!-- &lt;url-pattern&gt;/ps/*&lt;/url-pattern&gt; --&gt;
        &lt;!-- &lt;http-method&gt;GET&lt;/http-method&gt; --&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
        &lt;role-name&gt;admin&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
&lt;/security-constraint&gt;
&lt;login-config&gt;
    &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
&lt;/login-config&gt;
</code></pre>
<blockquote>
<p>其中</p>
<ul>
<li>url-pattern 配置匹配的 url，可配置多个进行细化管理</li>
<li>http-method 配置 http 请求的方法，可配置多个，值可为 GET、POST、PUT、DELETE</li>
<li>role-name 配置角色名称</li>
<li>auth-method 配置认证方式，值可为 BASIC（基本验证）、DIGEST（摘要验证，只支持 md5 算法？）以及（不常用）FORM（基于表单的验证）、CLIENT-CERT（客户证书验证）</li>
</ul>
</blockquote>
</li>
<li><p><span id="config-username-and-passwd-for-basic">配置用户名、密码</span></p>
<ul>
<li><p>方法一：使用配置文件 $CATALINA_HOME/conf/tomcat-users.xml 管理用户名、密码、角色  </p>
<ol>
<li><p>配置 Resource（默认情况下，tomcat 已存在该配置，可跳过）<br> 编辑 $CATALINA_HOME/conf/server.xml 文件，在 <code>/Server/GlobalNamingResources</code> 节点下，配置 Resource 如下</p>
<pre><code class="xml">&lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;
    type=&quot;org.apache.catalina.UserDatabase&quot;
    description=&quot;User database that can be updated and saved&quot;
    factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;
    pathname=&quot;conf/tomcat-users.xml&quot; /&gt;
</code></pre>
</li>
<li><p><span id="config-tomcat-users-for-basic">配置用户角色、用户名、密码</span><br> 编辑 tomcat-users.xml 文件，在 <code>/tomcat-users</code> 节点下，配置角色、用户如下</p>
<pre><code class="xml">&lt;role rolename=&quot;admin&quot; /&gt;

&lt;!-- 默认未配置 CredentialHandler，则使用明文密码，不推荐 --&gt;
&lt;!-- &lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;admin&quot; /&gt; --&gt;

&lt;!-- 配置 MessageDigestCredentialHandler 指定使用 MD5 摘要算法 --&gt;
&lt;!-- &lt;user username=&quot;admin&quot; password=&quot;21232f297a57a5a743894a0e4a801fc3&quot; roles=&quot;admin&quot; /&gt; --&gt;
&lt;!-- &lt;user username=&quot;admin&quot; password=&quot;03552ca004c4d197a06f769e36825b3666b27b10a74a035089f27cf48d680f27$1$9299434ea39a82833950ef4c6d8d81af&quot; roles=&quot;admin&quot; /&gt; --&gt;

&lt;!-- 配置 MessageDigestCredentialHandler 指定使用 SHA-256 摘要算法 --&gt;
&lt;!-- &lt;user username=&quot;admin&quot; password=&quot;8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918&quot; roles=&quot;admin&quot; /&gt; --&gt;

&lt;!-- 配置 SecretKeyCredentialHandler 指定使用 PBKDF2WithHmacSHA512 算法 --&gt;
&lt;user username=&quot;admin&quot; password=&quot;9fac50c23deceebc5884015289b111c9$100000$2087629b338449c8446e11ad5d0f8a0a8264c641af10b0ba4ee7a3a5f2df5ae5&quot; roles=&quot;admin&quot; /&gt;
</code></pre>
<blockquote>
<p>其中，若指定摘要算法，则 password 需要进行摘要处理，可使用 <code>digest.(sh|bat) -a $algorithm (-s 0)? $password</code> 命令获取密码（如 “admin”）的摘要值</p>
<ul>
<li><p>指定使用 MD5 摘要算法<br><code>./$CATALINA_HOME/bin/digest.sh -a md5 -s 0 admin</code><br><font color="grey">返回结果如 admin:21232f297a57a5a743894a0e4a801fc3</font><br><code>./$CATALINA_HOME/bin/digest.sh -a md5 admin</code><br><font color="grey">返回结果如 admin:03552ca004c4d197a06f769e36825b3666b27b10a74a035089f27cf48d680f27$1$9299434ea39a82833950ef4c6d8d81af</font></p>
</li>
<li><p>指定使用 SHA-256 摘要算法<br><code>./$CATALINA_HOME/bin/digest.sh -a sha-256 -s 0 admin</code><br><font color="grey">返回结果如 admin:8c6976e5b5410415bde908bd4dee15dfb167a9c873fc4bb8a81f6f2ab448a918</font></p>
</li>
<li><p>指定使用 PBKDF2WithHmacSHA512 算法<br><code>./$CATALINA_HOME/bin/digest.sh -a PBKDF2WithHmacSHA512 -i 100000 -s 16 -k 256 -h org.apache.catalina.realm.SecretKeyCredentialHandler admin</code><br><font color="grey">返回结果如 admin:9fac50c23deceebc5884015289b111c9$100000$2087629b338449c8446e11ad5d0f8a0a8264c641af10b0ba4ee7a3a5f2df5ae5</font></p>
</li>
</ul>
</blockquote>
</li>
<li><p><span id="config-credentialHandler-for-basic"><a href="https://stackoverflow.com/questions/32178822/tomcat-understanding-credentialhandler">配置 CredentialHandler（可选，仅适用于指定使用摘要算法，其他方式可跳过该步骤）</a></span><br> 编辑 server.xml 文件，在 <code>/Server/Service/Engine/Realm[@className=&quot;org.apache.catalina.realm.LockOutRealm&quot;]/Realm[@className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;]</code> 节点下，配置 CredentialHandler 如下</p>
<pre><code class="xml">&lt;!-- 配置 MessageDigestCredentialHandler 指定使用 MD5 摘要算法 --&gt;
&lt;!-- &lt;CredentialHandler className=&quot;org.apache.catalina.realm.MessageDigestCredentialHandler&quot; algorithm=&quot;MD5&quot; /&gt; --&gt;

&lt;!-- 配置 MessageDigestCredentialHandler 指定使用 SHA-256 摘要算法 --&gt;
&lt;!-- &lt;CredentialHandler className=&quot;org.apache.catalina.realm.MessageDigestCredentialHandler&quot; algorithm=&quot;SHA-256&quot; /&gt; --&gt;

&lt;!-- 配置 SecretKeyCredentialHandler 指定使用 PBKDF2WithHmacSHA512 算法 --&gt;
&lt;CredentialHandler className=&quot;org.apache.catalina.realm.SecretKeyCredentialHandler&quot;
    algorithm=&quot;PBKDF2WithHmacSHA512&quot;
    iterations=&quot;100000&quot;
    keyLength=&quot;256&quot;
    saltLength=&quot;16&quot; /&gt;
</code></pre>
</li>
</ol>
</li>
<li><p>方法二：<a href="http://lsz1023-126-com.iteye.com/blog/2072066">使用数据库管理用户名、密码、角色</a>  </p>
<ol>
<li><p><span id="config-db-users">准备数据库，如下</span></p>
<pre><code class="sql">create database db_users;

use db_users;

create table t_users (
    username varchar(20) not null,
    password varchar(64) not null,
    primary key(username)
);

create table t_roles (
    username varchar(20) not null,
    rolename varchar(20) not null,
    primary key(username, rolename)
);

insert into t_users values(&#39;zhangsan&#39;, &#39;123456&#39;);
insert into t_users values(&#39;lisi&#39;, &#39;123456&#39;);

insert into t_roles values(&#39;zhangsan&#39;, &#39;admin&#39;);
insert into t_roles values(&#39;zhangsan&#39;, &#39;tomcat&#39;);
insert into t_roles values(&#39;lisi&#39;, &#39;tomcat&#39;);

commit;
</code></pre>
</li>
<li><p><span id="config-realm">配置 Context</span><br> 如编辑 $CATALINA_HOME/conf/context.xml 文件，在 <code>/Context</code> 节点下添加 Realm 配置如下</p>
<pre><code class="xml">&lt;Realm className=&quot;org.apache.catalina.realm.JDBCRealm&quot;
    connectionName=&quot;test&quot; connectionPassword=&quot;123456&quot;
    connectionURL=&quot;jdbc:mysql://192.168.128.137:3306/db_users&quot;
    driverName=&quot;com.mysql.jdbc.Driver&quot;
    userTable=&quot;t_users&quot;
    userRoleTable=&quot;t_roles&quot;
    userNameCol=&quot;username&quot;
    userCredCol=&quot;password&quot;
    roleNameCol=&quot;rolename&quot;/&gt;
</code></pre>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>DIGEST（摘要验证，当前 tomcat 版本仅支持 md5 算法）</p>
<ol>
<li>配置 security-constraint<br> 参考配置 <a href="#config-security-constraint-for-basic">BASIC</a><br> 其中 auth-method 需要修改为 DIGEST，且需要定义 realm-name，如下<pre><code class="xml">&lt;security-constraint&gt;
    ...
&lt;/security-constraint&gt;
&lt;login-config&gt;
    &lt;auth-method&gt;DIGEST&lt;/auth-method&gt;
    &lt;realm-name&gt;app-realm&lt;/realm-name&gt;
&lt;/login-config&gt;
</code></pre>
</li>
<li>配置用户名、密码<br> 参考配置 <a href="#config-username-and-passwd-for-basic">BASIC</a><br> 其中<strong>方法一：使用配置文件</strong>中的  <ul>
<li>步骤 <a href="#config-tomcat-users-for-basic"><strong>配置用户角色、用户名、密码</strong></a>，配置用户信息需要修改如下<pre><code class="xml">&lt;user username=&quot;admin&quot; password=&quot;817440541acc5a8e3ea991b2d43533f3&quot; roles=&quot;admin&quot; /&gt;
</code></pre>
<blockquote>
<p>其中，若指定摘要算法，则 password 需要进行摘要处理，区别于 BASIC 方式，DIGEST 方式需使用 <code>digest.(sh|bat) -a $algorithm (-s 0)? $username:$realm-name:$password</code> 命令获取密码（如 “admin”，同时用户名为 admin、realm-name 为 app-realm）的摘要值</p>
<ul>
<li>指定使用 MD5 摘要算法<br><code>./$CATALINA_HOME/bin/digest.sh -a md5 -s 0 admin:app-realm:admin</code><br><font color="grey">返回结果如 admin:app-realm:admin:817440541acc5a8e3ea991b2d43533f3</font></li>
</ul>
</blockquote>
</li>
<li>步骤 <a href="#config-credentialHandler-for-basic"><strong>配置 CredentialHandler</strong></a>，需要使用 MD5 摘要算法，如下<pre><code class="xml">&lt;CredentialHandler className=&quot;org.apache.catalina.realm.MessageDigestCredentialHandler&quot; algorithm=&quot;MD5&quot; /&gt;
</code></pre>
</li>
</ul>
</li>
</ol>
</li>
<li><p>FORM（基于表单的验证）</p>
<ol>
<li>配置 security-constraint<br> 参考配置 <a href="#config-security-constraint-for-basic">BASIC</a><br> 其中 login-config 配置需要指定登录页面如下  <pre><code class="xml">&lt;security-constraint&gt;
    ...
&lt;/security-constraint&gt;
&lt;login-config&gt;
    &lt;auth-method&gt;FORM&lt;/auth-method&gt;
    &lt;form-login-config&gt;
        &lt;form-login-page&gt;/form/login.html&lt;/form-login-page&gt;
        &lt;form-error-page&gt;/form/error.html&lt;/form-error-page&gt;
    &lt;/form-login-config&gt;
&lt;/login-config&gt;
</code></pre>
</li>
<li>配置用户名、密码<br> 参考配置 <a href="#config-username-and-passwd-for-basic">BASIC</a></li>
</ol>
</li>
<li><p>CLIENT-CERT（客户证书验证）</p>
<ol>
<li>生成证书<ol>
<li>生成服务器证书容器<br> <code>keytool -validity 36500 -genkey -v -alias server -keyalg RSA -keystore server.jks -dname &quot;CN=192.168.0.104,OU=xx,O=xx,L=shanghai,ST=shanghai,c=cn&quot; -storepass passwd01 -keypass passwd01</code></li>
<li>生成信赖的客户端证书容器<br> <code>keytool -validity 36500 -genkey -v -alias server_trust -keyalg RSA -keystore server_trust.jks -dname &quot;CN=192.168.0.104,OU=xx,O=xx,L=shanghai,ST=shanghai,c=cn&quot; -storepass passwd02 -keypass passwd02</code></li>
<li>生成客户端用秘钥对<br> <code>keytool -validity 36500 -genkeypair -v -alias client_01 -keyalg RSA -storetype PKCS12 -keystore client_01.p12 -dname &quot;CN=client_01,OU=xx,O=xx,L=shanghai,ST=shanghai,c=cn&quot; -storepass passwd03 -keypass passwd03</code><br> 导出客户端用证书<br> <code>keytool -export -v -alias client_01 -keystore client_01.p12 -storetype PKCS12 -storepass passwd03 -rfc -file client_01.cer</code></li>
<li>将客户端用的证书导入至服务端信赖的客户端的证书容器<br> <code>keytool -import -v -alias client_01 -file client_01.cer -keystore server_trust.jks -storepass passwd02</code></li>
</ol>
</li>
<li>配置 https<br> 编辑 $CATALINA_HOME/conf/server.xml，配置 <code>/Server/Service/Connector[@port=&quot;8443&quot;]</code> 节点如下  <pre><code class="xml">&lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;
           maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
           clientAuth=&quot;true&quot; sslProtocol=&quot;TLS&quot;
           keystoreFile=&quot;$&#123;catalina.base&#125;/conf/server.jks&quot; keystorePass=&quot;passwd01&quot;
           truststoreFile=&quot;$&#123;catalina.base&#125;/conf/server_trust.jks&quot; truststorePass=&quot;passwd02&quot; /&gt;
</code></pre>
</li>
<li>设置强制 ssl 访问<br> 编辑 $CATALINA_HOME/*/web.xml，在 <code>/web-app</code> 节点下添加配置 security-constraint 如下<pre><code class="xml">&lt;!-- 强制SSL，即http请求自动跳转成https --&gt; 
&lt;security-constraint&gt;
    &lt;web-resource-collection&gt;
        &lt;web-resource-name&gt;SSL&lt;/web-resource-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;!-- 全站使用SSL --&gt;
    &lt;/web-resource-collection&gt;
    &lt;user-data-constraint&gt;
        &lt;description&gt;SSL required&lt;/description&gt;
        &lt;!-- CONFIDENTIAL: 确保传输数据不被修改，不能被查看 --&gt;
        &lt;!-- INTEGRAL: 确保传输数据不被修改 --&gt;
        &lt;!-- NONE: 不做特殊限制--&gt;
        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
    &lt;/user-data-constraint&gt;
&lt;/security-constraint&gt;
</code></pre>
</li>
<li>客户端PC导入上面生成的 client_01.cer 以及 client_01.p12 后，重启浏览器，即可访问。（初次访问会弹出选择证书的对话框，选中导入的cer证书即可）</li>
</ol>
</li>
</ul>
</li>
<li><p>黑白名单配置</p>
<ol>
<li>编辑 $CATALINA_HOME/conf/server.xml 文件，在 <code>/Server/Service/Engine</code> 节点下、或在 <code>/Server/Service/Engine/Host</code> 节点下、或在 <code>/Server/Service/Engine/Host/Context</code> 节点下，添加 Valve 配置如下<pre><code class="xml">&lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;&quot; deny=&quot;10.17.23.19[1-3]|10.54.233.1(1[6-9]|2[0-6])|62.138.2.(209|12(2|3)|21(3|4))|10.151.(149.222|42.61)|10.239.228.202&quot; denyStatus=&quot;403&quot; /&gt;
</code></pre>
 其中 allow 为白名单，deny 为黑名单，支持正则配置匹配，denyStatus 为黑名单拜访的 http 状态码</li>
</ol>
</li>
<li><p>虚拟主机配置</p>
<ol>
<li><p>编辑 $CATALINA_HOME/conf/server.xml 文件，在 <code>/Server/Service/Engine</code> 节点下，添加一个或多个 Host 配置如下</p>
<pre><code class="xml">&lt;Host name=&quot;www.simple.com&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;false&quot; autoDeploy=&quot;false&quot;&gt;
&lt;/Host&gt;

&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;false&quot; autoDeploy=&quot;false&quot;&gt;
    &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot; prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot; pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;

    &lt;Context path=&quot;/solr&quot; docBase=&quot;solr&quot; reloadable=&quot;true&quot;/&gt;
&lt;/Host&gt;
</code></pre>
<blockquote>
<ul>
<li><p>启动时项目重复加载的问题及解决办法<br>  <font color="grey">Tomcat 在加载工程时首先会根据 <code>//Context</code> 配置内容生成第一个 StandardContext 对象，并加载一次项目。加载完成后会根据 &gt; <code>//Host/appBase</code>（默认不填则为 webapps）配置内容生成第二个 StandardContext，并再加载一次相应的工程（或 war 包）。</font><br>  如配置</p>
<pre><code class="xml">&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; unpackWARs=&quot;false&quot; autoDeploy=&quot;false&quot;&gt;
    &lt;Context path=&quot;/&quot; docBase=&quot;solr&quot; reloadable=&quot;true&quot;/&gt;
&lt;/Host&gt;
</code></pre>
<p>  既配置 Context，又在 webapps 目录下放置了工程目录，Tomcat 针对同一项目 solr 生成两个 StandardContext 是因为其名称不同，因而当作是两个 Context，&gt; 所以加载了两次。第一个 StandardContext 所对应的名称是由标签 Context 的配置来决定的，而第二个 StandardContext 的名称是由项目名称 “/solr” 决定的。&gt;<br>  <font color="green">解决方法：</p>
<ul>
<li><p>方法一：<br>  将对应的工程目录如 $CATALINA_HOME/webapps/solr 重命名为 $CATALINA_HOME/webapps/ROOT</p>
</li>
<li><p>方法二：<br>  编辑 server.xml，配置 <code>//Context@path</code> 为任意名称如 /solr</p>
</li>
<li><p>方法三：<br>  编辑 server.xml，配置 <code>//Context@name</code> 为项目名称如 /solr（其中根目录符号 “/“ 为必须）</p>
</font>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li><p><a href="https://tomcat.apache.org/tomcat-8.5-doc/cluster-howto.html">配置并使用内置的集群功能</a></p>
<ol>
<li>配置 web.xml，开启集群功能（web 工程中的 web.xml 文件中需要配置有 <distributable/> 这个元素才能使用 tomcat 内置的 cluster 功能）<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app ...&gt;
    ...
    &lt;distributable/&gt;
&lt;/web-app&gt;
</code></pre>
</li>
<li>配置 server.xml，在 Engine 节点下配置集群组播地址（见 Cluster 节点及其子节点配置，注意两个 tomcat 中的 path 必须一致，不然会报错(Context manager doesn’t exist)。只有 path 一致，两个 tomcat 才能同步 session）<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;Server ...&gt;
    ...
    &lt;Service name=&quot;Catalina&quot;&gt;
        ...
        &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;
            &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;
                        channelSendOptions=&quot;8&quot;&gt;
                &lt;Manager className=&quot;org.apache.catalina.ha.session.DeltaManager&quot;
                        expireSessionsOnShutdown=&quot;false&quot;
                        notifyListenersOnReplication=&quot;true&quot;/&gt;
                &lt;Channel className=&quot;org.apache.catalina.tribes.group.GroupChannel&quot;&gt;
                &lt;Membership className=&quot;org.apache.catalina.tribes.membership.McastService&quot;
                            address=&quot;228.0.0.4&quot;
                            port=&quot;45564&quot;
                            frequency=&quot;500&quot;
                            dropTime=&quot;3000&quot;/&gt;
                &lt;Receiver className=&quot;org.apache.catalina.tribes.transport.nio.NioReceiver&quot;
                            address=&quot;auto&quot;
                            port=&quot;4000&quot;
                            autoBind=&quot;100&quot;
                            selectorTimeout=&quot;5000&quot;
                            maxThreads=&quot;6&quot;/&gt;
                &lt;Sender className=&quot;org.apache.catalina.tribes.transport.ReplicationTransmitter&quot;&gt;
                    &lt;Transport className=&quot;org.apache.catalina.tribes.transport.nio.PooledParallelSender&quot;/&gt;
                &lt;/Sender&gt;
                &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.TcpFailureDetector&quot;/&gt;
                &lt;Interceptor className=&quot;org.apache.catalina.tribes.group.interceptors.MessageDispatchInterceptor&quot;/&gt;
                &lt;/Channel&gt;
                &lt;Valve className=&quot;org.apache.catalina.ha.tcp.ReplicationValve&quot;
                        filter=&quot;&quot;/&gt;
                &lt;Valve className=&quot;org.apache.catalina.ha.session.JvmRouteBinderValve&quot;/&gt;
                &lt;Deployer className=&quot;org.apache.catalina.ha.deploy.FarmWarDeployer&quot;
                        tempDir=&quot;/tmp/war-temp/&quot;
                        deployDir=&quot;/tmp/war-deploy/&quot;
                        watchDir=&quot;/tmp/war-listen/&quot;
                        watchEnabled=&quot;false&quot;/&gt;
                &lt;ClusterListener className=&quot;org.apache.catalina.ha.session.ClusterSessionListener&quot;/&gt;
            &lt;/Cluster&gt;
            ...
        &lt;/Engine&gt;
    &lt;/Service&gt;
&lt;/Server&gt;
</code></pre>
</li>
</ol>
</li>
</ul>
<details>
<summary>安全加固</summary>

<ul>
<li><p><span id="security-datasource"><a href="http://www.cnblogs.com/benefitworld/p/5832668.html">安全加固：Tomcat 数据源连接池加密 password</a></span></p>
<ol>
<li><p>构建 DataSourceFactory 包</p>
<ol>
<li><p>切换目录至 $CATALINA_HOME/temp 目录下，创建目录<br> <code>mkdir -p ./pers/sunke/tomcat/dbcp</code></p>
</li>
<li><p>新建文件 EncryptedDataSourceFactory.java<br> <code>touch ./pers/sunke/tomcat/dbcp/EncryptedDataSourceFactory.java</code><br> 编辑内容如下</p>
<pre><code class="java">package pers.sunke.tomcat.dbcp;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.ResourceBundle;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.naming.Context;
import javax.naming.Name;
import javax.naming.RefAddr;
import javax.naming.Reference;
import javax.naming.StringRefAddr;

import org.apache.tomcat.dbcp.dbcp2.BasicDataSourceFactory;

public class EncryptedDataSourceFactory extends BasicDataSourceFactory &#123;

    private static final String ALGORITHM = &quot;AES/CBC/PKCS5Padding&quot;;
    private static final String KEYALGORITHM = &quot;AES&quot;;

    // length of key should be 16 byte for 128 bit, 32 byte for 256 bit.
    private static final String KEY = &quot;2QKH3XfuIKALMwnk&quot;;
    // length of iv must be 16 byte.(equal to the length of a data block in aes: 16 byte or 128 bit)
    private static final String IV = &quot;RAk0ygQXIX2ZpMQH&quot;;

    private static final String PROP_PASSWORD = &quot;password&quot;;

    @Override
    public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123;
        try &#123;
            if (obj instanceof Reference) &#123;
                Reference ref = (Reference) obj;
                StringRefAddr passwordRefAddr = (StringRefAddr) ref.get(PROP_PASSWORD);
                if (null != passwordRefAddr) &#123;
                    String encryptedPwd = (String) passwordRefAddr.getContent();
                    String cleartextPwd = decrypt(encryptedPwd);
                    int index = find(PROP_PASSWORD, ref);
                    if (index &gt;= 0) &#123;
                        ref.remove(index);
                        ref.add(index, new StringRefAddr(PROP_PASSWORD, cleartextPwd));
                    &#125;
                &#125;
            &#125;
        &#125; catch (Exception e) &#123;
            System.err.println(&quot;Failed to decrypt password. Please check DataSource definition.&quot;);
            throw e;
        &#125;
        return super.getObjectInstance(obj, name, nameCtx, environment);
    &#125;

    private int find(String addrType, Reference ref) throws Exception &#123;
        Enumeration&lt;RefAddr&gt; enu = ref.getAll();
        for (int i = 0; enu.hasMoreElements(); i++) &#123;
            RefAddr addr = (RefAddr) enu.nextElement();
            if (addr.getType().equals(addrType))
                return i;
        &#125;
        return -1;
    &#125;

    public static String encrypt(String source) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException &#123;
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(KEY.getBytes(), KEYALGORITHM), new IvParameterSpec(IV.getBytes()));
        return new String(Base64.getEncoder().encode(cipher.doFinal(source.getBytes())));
    &#125;

    public static String decrypt(String encryptSource) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException &#123;
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(KEY.getBytes(), KEYALGORITHM), new IvParameterSpec(IV.getBytes()));
        return new String(cipher.doFinal(Base64.getDecoder().decode(encryptSource.getBytes())));
    &#125;

    public static void main(String[] args) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException &#123;
        try &#123;
            if (args.length == 1) &#123;
                System.out.println(encrypt(args[0]));
            &#125; else if (args.length == 2 &amp;&amp; &quot;-e&quot;.equals(args[0])) &#123;
                System.out.println(encrypt(args[1]));
            &#125; else if (args.length == 2 &amp;&amp; &quot;-d&quot;.equals(args[0])) &#123;
                System.out.println(decrypt(args[1]));
            &#125; else &#123;
                ResourceBundle bundle = ResourceBundle.getBundle(&quot;messages&quot;);
                String usageDescription = bundle.getString(&quot;usage.description&quot;);
                System.out.println(usageDescription);
            &#125;
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;Failed to encrypt or decrypt.&quot;);
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>编译<br> <code>javac -cp ../lib/tomcat-dbcp.jar ./pers/sunke/tomcat/dbcp/EncryptedDataSourceFactory.java</code></p>
</li>
<li><p>打包<br> <code>jar cvf ../lib/tomcat-dbcp-patch.jar ./pers/sunke/tomcat/dbcp/EncryptedDataSourceFactory.class</code></p>
</li>
<li><p>切换目录至 $CATALINA_HOME/lib<br> <code>cd ../lib</code></p>
</li>
<li><p>生成密文<br> <code>java -cp &quot;tomcat-dbcp-patch.jar;tomcat-dbcp.jar;../bin/tomcat-juli.jar&quot; pers.sunke.tomcat.dbcp.EncryptedDataSourceFactory -e 123456</code></p>
<blockquote>
<p>解密密文<br><code>java -cp &quot;tomcat-dbcp-patch.jar;tomcat-dbcp.jar;../bin/tomcat-juli.jar&quot; pers.sunke.tomcat.dbcp.EncryptedDataSourceFactory -d UkLthpB/fB7z6yZFUnAE1A==</code></p>
</blockquote>
</li>
<li><p>配置数据源如下</p>
<pre><code class="xml">&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;
&lt;Context path=&quot;/ds01&quot; docBase=&quot;app01&quot;&gt;
    &lt;Resource name=&quot;jdbc/ds01&quot; type=&quot;javax.sql.DataSource&quot; auth=&quot;Container&quot; driverClassName=&quot;com.mysql.jdbc.Driver&quot; factory=&quot;pers.sunke.tomcat.dbcp.EncryptedDataSourceFactory&quot; url=&quot;jdbc:mysql://127.0.0.1:3306/db01&quot; validationQuery=&quot;select 1 from dual&quot; username=&quot;test&quot; password=&quot;UkLthpB/fB7z6yZFUnAE1A==&quot; /&gt;
&lt;/Context&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p>安全加固：Tomcat 鉴权数据源中的用户密码加密（PBKDF2WithHmacSHA256）</p>
<ol>
<li><p><a href="#config-db-users">准备数据源</a>，修改字段长度</p>
<pre><code class="sql">alter table t_users modify password varchar(600) not null;

update t_users set password = &#39;10000:97b10f4dd3f7d5444072b7e57175f069ec1e3b25abaf71386a99fe532212544f:e99cbfcd15d23e93687ccf80d2639746fec83a908062f8b48385908665c8f6c07e65dbdd9b5db62861047a15b35c8653b03f16ac72cef661e4777193056d12c19ec68106fd9f5a9f7d4a6d83029c69ffa54fe795e6ff0b7c3bab97f5c029704e08a6cc4567685c7a8ba42315a4937bc4471a6b280669b9b44e12719beee92e934ff8c0064ef7d08e268c95b73bb506edb484b670e144d25be759485f2be6f50dc4fbe3c119ce8524da7d30a689b8c3a633619acc41e2ebcc431a5ccaca1084910f165812dfcc71889367f8abc1c91c1cc0fcf9330d804a19ace77699190233a24bf87f5126ebc80ef2ef67302ed37fc3bd217aa3d1c7a3e24a0e80fa7b36e530&#39; where username = &#39;zhangsan&#39;;
</code></pre>
</li>
<li><p>继承重写 org.apache.catalina.realm.JDBCRealm，如下</p>
<pre><code class="java">package pers.sunke.tomcat.realm;

import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;

import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;

import org.apache.catalina.realm.JDBCRealm;

public class EncryptedJDBCRealm extends JDBCRealm &#123;

    private static final String ALGORITHM = &quot;PBKDF2WithHmacSHA256&quot;;
    private static final int ITERATIONCOUNT = 10000;
    private static final int KEYLENGTH = 256;
    private static final int SALTLENGTH = 32;

    @Override
    public synchronized Principal authenticate(String username, String credentials) &#123;
        try &#123;
            byte[] salt = getSalt(getPassword(username));
            String credentialsHashed = hash(credentials, salt);
            return super.authenticate(username, credentialsHashed);
        &#125; catch (NoSuchAlgorithmException | InvalidKeySpecException e) &#123;
            e.printStackTrace();
            return null;
        &#125;
    &#125;

    public byte[] generateSalt() &#123;
        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[SALTLENGTH];
        random.nextBytes(salt);
        return salt;
    &#125;

    public byte[] getSalt(String code) &#123;
        String[] params = code.split(&quot;:&quot;);
        if (3 == params.length) &#123;
            byte[] salt = fromHex(params[1]);
            return salt;
        &#125; else &#123;
            System.err.println(&quot;Error cipher code format: &quot; + code);
            return null;
        &#125;
    &#125;

    public String hash(String password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException &#123;
        SecretKeyFactory factory = SecretKeyFactory.getInstance(ALGORITHM);
        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, ITERATIONCOUNT, KEYLENGTH * 8);
        byte[] key = factory.generateSecret(spec).getEncoded();
        return String.format(&quot;%d:%s:%s&quot;, ITERATIONCOUNT, toHex(salt), toHex(key));
    &#125;

    private String toHex(byte[] array) &#123;
        BigInteger bi = new BigInteger(1, array);
        String hex = bi.toString(16);
        int paddingLength = (array.length * 2) - hex.length();
        if (paddingLength &gt; 0)
            return String.format(&quot;%0&quot; + paddingLength + &quot;d&quot;, 0) + hex;
        else
            return hex;
    &#125;

    private byte[] fromHex(String hex) &#123;
        byte[] binary = new byte[hex.length() / 2];
        for (int i = 0; i &lt; binary.length; i++) &#123;
            binary[i] = (byte) Integer.parseInt(hex.substring(2 * i, 2 * i + 2), 16);
        &#125;
        return binary;
    &#125;

    public static void main(String[] args) &#123;
        EncryptedJDBCRealm realm = new EncryptedJDBCRealm();
        try &#123;
            if (args.length == 1) &#123;
                System.out.println(realm.hash(args[0], realm.generateSalt()));
            &#125; else if (args.length == 2 &amp;&amp; &quot;-h&quot;.equals(args[0])) &#123;
                System.out.println(realm.hash(args[1], realm.generateSalt()));
            &#125; else if (args.length == 3 &amp;&amp; &quot;-h&quot;.equals(args[0])) &#123;
                System.out.println(realm.hash(args[1], realm.fromHex(args[2])));
            &#125; else &#123;
                System.out.println(&quot;Usage:&quot;);
                System.out.println(&quot;\tjava [...] [password]&quot;);
                System.out.println(&quot;\tjava [...] -h [password]&quot;);
                System.out.println(&quot;\tjava [...] -h [password] [salt]&quot;);
            &#125;
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;Failed to hash.&quot;);
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li><p>打包部署，可参考<a href="#security-datasource">数据源安全加固</a>中相关步骤，其中编译、打包、生成密钥 code 命令如下<br> <code>javac -cp &quot;../lib/catalina.jar&quot; ./pers/sunke/tomcat/realm/EncryptedJDBCRealm.java</code><br> <code>jar cvf ../lib/catalina-patch.jar ./pers/sunke/tomcat/realm/EncryptedJDBCRealm.class</code><br> <code>java -cp &quot;catalina-patch.jar;catalina.jar;tomcat-util.jar;../bin/tomcat-juli.jar&quot; pers.sunke.tomcat.realm.EncryptedJDBCRealm -h 123456</code></p>
</li>
<li><p>修改<a href="#config-realm">相关配置文件中 Realm 节点</a>的 className 为 pers.sunke.tomcat.realm.EncryptedJDBCRealm</p>
<blockquote>
<ul>
<li>配置文件中 connectionPassword 的安全加固，需重写 getConnectionPassword 方法，方法的实现可参考<a href="#security-datasource">数据源安全加固</a> 中相关实现</li>
<li>使用 tomcat-users.xml 数据源鉴权的，需继承重写 org.apache.catalina.users.MemoryUserDatabaseFactory 对象，可参考<a href="#security-datasource">数据源安全加固</a> 中相关实现</li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li><p>安全加固：Tomcat 基本安全配置</p>
<ol>
<li><p>删除多余的工程项目<br> 删除 $CATALINA_HOME/webapps 目录下所有不需要的工程项目（包括示例工程、webapp 管理工程，如 docs、example、host-manager、manager、ROOT）等项目（目录）</p>
</li>
<li><p>停止 Tomcat shutdown 端口<br> 编辑 $CATALINA_HOME/conf/server.xml，修改 <code>/Server/@port</code> 的值为 -1，如下  </p>
<pre><code class="xml">&lt;Server port=&quot;-1&quot; shutdown=&quot;SHUTDOWN&quot;&gt;
</code></pre>
<blockquote>
<ul>
<li>该端口（默认配置的端口号为 8005）用于远程放送命令（命令内容对应 <code>/Server/@shutdown</code> 的值，默认配置的命令内容为 “SHUTDOWN”）给 Tomcat 以停止服务，可通过配置端口号为 -1 来禁用该端口。  </li>
<li>通过 tcp 连接该端口并发送命令来停止 tomcat 服务<ul>
<li>方法一：使用 telnet 连接<br>  <code>telnet 127.0.0.1 8005</code><br>  输入命令 SHUTDOWN 并回车，则 tomcat 停止服务</li>
<li>方法二：使用 netcat 连接<br>  <code>nc 127.0.0.1 8005</code><br>  输入命令 SHUTDOWN 并回车，则 tomcat 停止服务</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>禁用 AJP<br> 编辑 $CATALINA_HOME/conf/server.xml，注释或删除 <code>/Server/Service/Connector[@protocol=&quot;AJP/1.3&quot;]</code> 节点（即注释或删除使用 AJP/*.* 的 Connector 节点）</p>
</li>
<li><p>Tomcat 降权启动<br> 禁止以 root 特权用户启动 Tomcat，即 Tomcat 应以非 root 权限启动，应用部署目录权限和 Tomcat 服务启动用户分离，如 Tomcat 以 tomcat 用户启动，而部署应用的目录设置为 nobody 用户 750 读写权限</p>
</li>
<li><p>屏蔽 Tomcat 版本信息</p>
<ol>
<li><a href="https://jingyan.baidu.com/article/d2b1d102a9dc955c7e37d487.html">自定义服务版本信息</a><br> 编辑 $CATALINA_HOME/lib/catalina.jar!/org/apache/catalina/util/ServerInfo.properties，自定义修改 server.info 配置项如 “Web Server”，修改 server.number 配置项如 “1.0”</li>
<li>在 http 响应头中屏蔽 Tomcat 版本信息<br> 编辑 $CATALINA_HOME/conf/server.xml，设置 <code>/Server/Service/Connector/@server</code> 的值为与 Tomcat 版本信息无关的名称，如 “Web Server”</li>
</ol>
</li>
<li><p>关闭自动部署<br> 编辑 $CATALINA_HOME/conf/server.xml，设置 <code>/Server/Service/Engine/Host/@unpackWARs</code> 和 <code>/Server/Service/Engine/Host/@autoDeploy</code> 的值为 false</p>
</li>
<li><p>自定义错误页面<br> 编辑 $CATALINA_HOME/conf/web.xml 或 $CATALINA_HOME/webapps/*/WEB-INF/web.xml，在 <code>/web-app/</code> 节点下添加错误页面 error-page 配置，如下</p>
<pre><code class="xml">&lt;error-page&gt;
    &lt;error-code&gt;404&lt;/error-code&gt;
    &lt;location&gt;/404.html&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
    &lt;error-code&gt;500&lt;/error-code&gt;
    &lt;location&gt;/500.html&lt;/location&gt;
&lt;/error-page&gt;
</code></pre>
</li>
<li><p>启用 Cookie 的 HttpOnly 属性<br> 编辑 $CATALINA_HOME/conf/context.xml，设置 <code>/Context/@useHttpOnly</code> 为 true，如下</p>
<pre><code class="xml">&lt;Context useHttpOnly=&quot;true&quot;&gt;
    ...
&lt;/Context&gt;
</code></pre>
</li>
<li><p>开启日志审核，即 Tomcat 的访问日志（高版本默认已开启）<br> 编辑 $CATALINA_HOME/conf/server.xml，设置或取消注释 <code>/Server/Service/Engine/Host/Valve[@className=&quot;org.apache.catalina.valves.AccessLogValve&quot;]</code> 节点，如下</p>
<pre><code class="xml">&lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;
       prefix=&quot;localhost_access_log&quot; suffix=&quot;.txt&quot;
       pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;
</code></pre>
<blockquote>
<p>其中，参数 pattern 指定记录日志的格式，各项的含义如下<br><code>%h</code> 远程主机名或 IP 地址。如果有 nginx 等反向代理服务器进行请求分发，该主机名或 IP 地址代表的是 nginx，否则代表的是客户端<br><code>%l</code> 远程逻辑用户名，一律是 “-“<br><code>%u</code> 授权的远程用户名，如果没有，则是 “-“<br><code>%t</code> 访问的时间<br><code>%r</code> 请求的第一行，即请求方法（get、post 等）、url、协议<br><code>%s</code> 响应状态，200、404 等<br><code>%b</code> 响应的数据量，不包括请求头，如果为 0，则是 “-“</p>
</blockquote>
</li>
<li><p>禁止列目录（高版本默认已禁止）<br>编辑 web.xml，找到 <code>/web-app/servlet/init-param/param-name</code> 参数名为 listings 的节点，设置其参数值为 false，如下</p>
<pre><code class="xml">...
&lt;init-param&gt;
    &lt;param-name&gt;listings&lt;/param-name&gt;
    &lt;param-value&gt;false&lt;/param-value&gt;
&lt;/init-param&gt;
...
</code></pre>
</li>
<li><p>删除用户权限相关配置（高版本默认已禁止）<br>编辑 $CATALINA_HOME/conf/tomcat-users.xml，在 <code>/tomcat-users</code> 节点下，删除或注释所有 role、user 节点（即删除或注释用户、角色配置）</p>
</li>
</ol>
</li>
</ul>
</details>

<details>
<summary>性能优化</summary>

<ul>
<li><p><del>性能优化：Tomcat 内存使用优化</del></p>
<blockquote>
<p>原则上应尽量避免 Full GC</p>
</blockquote>
<ol>
<li>编辑 $CATALINA_HOME/bin/catalina.sh（Linux），添加以下配置<br> <code>JAVA_OPTS=$JAVA_OPT -server -Xms2048m -Xmx2048m</code> <del>-XX:PermSize=256m -XX:MaxPermSize=512m</del> <code>-Djava.awt.headless=true</code><blockquote>
<p>其中，参数  </p>
<ul>
<li><code>-Xms</code>、<code>-Xmx</code> 指定 jvm 占用最小和最大物理内存。一般两者配置一样大，可以避免内存不够用时申请内存的耗时</li>
<li><code>-XX:PermSize</code>、<code>-XX:MaxPermSize</code> 指定 Perm 内存大小<br><font color="red">Java 8 中 PermSize 被 MetaspaceSize 代替，MetaspaceSize 共享 heap，不会再有”java.lang.OutOfMemoryError：PermGen space”，可以不设置</font><br><font color="grey">jvm 的内存分为两大类型：perm 和 generation。perm 区域存放的是 class 这些静态信息，一般默认为 64 MB。如果工程很大，有可能一启动就报错：”out of memory permsize”；如果用 spring 框架的话很多类是动态反射加载的，运行一段时间也有可能出现此异常。此类情况下，设置 permsize 的大小即可。</font></li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li><p>性能优化：Tomcat 启动参数优化（堆内存、栈内存、GC 日志、堆转储等）</p>
<pre><code class="bash">JAVA_OPTS=&quot;$JAVA_OPTS -Xms6144m -Xmx6144m -Xmn2384m -Xss512k -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=1024M -XX:+HeapDumpOnOutOfMemoryError -Djava.protocol.handler.pkgs=org.apache.catalina.webresources&quot;
JAVA_OPTS=&quot;$JAVA_OPTS -Xloggc:$CATALINA_BASE/logs/gc.log -XX:HeapDumpPath=$CATALINA_BASE/logs&quot;
JAVA_OPTS=&quot;$JAVA_OPTS -XX:+PrintGCDetails -XX:+UseParallelGC -XX:ParallelGCThreads=32&quot;
JAVA_OPTS=&quot;$JAVA_OPTS -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=10M&quot;
</code></pre>
</li>
<li><p>性能优化：Tomcat 并发优化</p>
<ol>
<li>编辑 $CATALINA_HOME/conf/server.xml，在 <code>/Server/Service/Connector</code> 节点中，配置如下<pre><code class="xml">&lt;Connector ... 
        protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;
        maxThreads=&quot;500&quot;
        minSpareThreads=&quot;100&quot;
        maxSpareThreads=&quot;200&quot;
        acceptCount=&quot;200&quot;
        enableLookups=&quot;false&quot;
        ... /&gt;
</code></pre>
<blockquote>
<p>其中，参数  </p>
<ul>
<li><code>protocol</code> 指定协议。<a href="#tomcat-protocol">Http11NioProtocol（即 NIO 模式）较其它模式效率更高</a></li>
<li><code>maxThreads</code> 指定当前可以同时处理的最大用户访问数</li>
<li><code>minSpareThreads</code>、<code>maxSpareThreads</code> 指定最小、最大空闲线程连接数，用于优化线程池</li>
<li><code>acceptCount</code> 指定当所有的线程已分配，仍然允许连接进来，但是处于等待状态的用户数。等待线程数 + 工作线程数 = 总的可最大连接数，如果超过此数，新的连接将不会被接受，并且将会产生一个 http 错误</li>
<li><code>enableLookups</code> 指定是否允许 DNS 反查，如果为 true，request.getRemoteHost 会执行 DNS 查找，反向解析 ip 对应域名或主机名，当没有这样需要的时候，可以将这个功能关闭，在一定程度上提高了 Tomcat 服务器的性能</li>
</ul>
</blockquote>
</li>
</ol>
</li>
<li><p>性能优化：使用 APR 提高可伸缩性和性能</p>
</li>
<li><p>性能优化：<a href="http://tomcat.apache.org/tomcat-8.0-doc/logging.html#Using-Log4j">使用 log4j 管理 Tomcat 日志，并实现日志分割、备份清理</a></p>
<ol>
<li><p>下载 log4j-1.2.17.jar<br> <code>curl -O https://mirrors.tuna.tsinghua.edu.cn/apache/logging/log4j/1.2.17/log4j-1.2.17.tar.gz &amp;&amp; tar zxvf log4j-1.2.17.tar.gz apache-log4j-1.2.17/log4j-1.2.17.jar</code><br> 将 log4j-1.2.17.jar 复制到 $CATALINA_HOME/lib 目录中<br> <code>cp apache-log4j-1.2.17/log4j-1.2.17.jar $CATALINA_HOME/lib</code></p>
</li>
<li><p>下载 tomcat-juli-adapters.jar<br> <code>curl -O http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.0.52/bin/extras/tomcat-juli-adapters.jar</code><br> 将 tomcat-juli-adapters.jar 复制到 $CATALINA_HOME/lib 目录中<br> <code>cp tomcat-juli-adapters.jar $CATALINA_HOME/lib</code><br> 下载 tomcat-juli.jar<br> <code>curl -O http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.0.52/bin/extras/tomcat-juli.jar</code><br> 将 tomcat-juli.jar 复制并替换到 $CATALINA_HOME/bin 目录中<br> <code>cp -f tomcat-juli.jar $CATALINA_HOME/bin</code></p>
</li>
<li><p>在 $CATALINA_HOME/lib 目录下创建配置文件 log4j.properties<br> <code>vi $CATALINA_HOME/lib/log4j.properties</code><br> 编辑配置内容如下</p>
<pre><code class="ini">log4j.rootLogger = INFO, CATALINA
# log4j.rootLogger = INFO, CATALINA, CONSOLE

# Define catalina appender
log4j.appender.CATALINA = org.apache.log4j.RollingFileAppender
log4j.appender.CATALINA.File = $&#123;catalina.base&#125;/logs/catalina.out
log4j.appender.CATALINA.Append = true
log4j.appender.CATALINA.Encoding = UTF-8
log4j.appender.CATALINA.MaxFileSize = 10MB
log4j.appender.CATALINA.MaxBackupIndex = 10
log4j.appender.CATALINA.layout = org.apache.log4j.PatternLayout
log4j.appender.CATALINA.layout.ConversionPattern = %d [%t] %-5p %c- %m%n

# Define catalina appender
log4j.appender.LOCALHOST = org.apache.log4j.RollingFileAppender
log4j.appender.LOCALHOST.File = $&#123;catalina.base&#125;/logs/localhost.log
log4j.appender.LOCALHOST.Append = true
log4j.appender.LOCALHOST.Encoding = UTF-8
log4j.appender.LOCALHOST.MaxFileSize = 10MB
log4j.appender.LOCALHOST.MaxBackupIndex = 10
log4j.appender.LOCALHOST.layout = org.apache.log4j.PatternLayout
log4j.appender.LOCALHOST.layout.ConversionPattern = %d [%t] %-5p %c- %m%n

# Define console appender
log4j.appender.CONSOLE = org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Encoding = UTF-8
log4j.appender.CONSOLE.layout = org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.ConversionPattern = %d [%t] %-5p %c- %m%n

# Configure which loggers log to which appenders
log4j.logger.org.apache.catalina.core.ContainerBase.[Catalina].[localhost] = INFO, LOCALHOST
</code></pre>
</li>
<li><p>删除配置文件 logging.properties<br> <code>rm $CATALINA_HOME/conf/logging.properties</code></p>
</li>
<li><p>启动/重启 Tomcat</p>
</li>
</ol>
</li>
</ul>
</details>

<details>
<summary>常用第三方 war 应用</summary>

<ul>
<li><p><span id="setup-jenkins">使用 Jenkins 搭建持续集成环境</span></p>
<ol>
<li>下载<br> <code>wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war</code></li>
<li>部署至 tomcat 中<br> <code>mv jenkins.war $CATALINA_HOME/webapps/</code><blockquote>
<p>Jenkins 将会在 user.home 目录下，即 ~/ 目录下创建 .jenkins 目录。可通过修改启动参数来指定 user.home，如<br><code>SET CATALINA_OPTS=-Duser.home=&quot;E:\apache-tomcat-8.0.47\temp&quot;</code></p>
</blockquote>
</li>
</ol>
</li>
<li><p>使用 <a href="https://github.com/psi-probe/psi-probe">Probe</a> <a href="http://www.cnblogs.com/dancser/p/4450963.html">监控 Tomcat</a></p>
<ol>
<li>下载 probe.war<br> <code>curl -L https://oss.sonatype.org/content/repositories/snapshots/com/github/psi-probe/psi-probe-web/3.0.0-SNAPSHOT/psi-probe-web-3.0.0-20180326.001732-103.war -o probe.war</code></li>
<li>将 probe.war 复制到 webapps 目录下<br> <code>mv probe.war $CATALINA_HOME/webapps/</code></li>
<li>添加用户账号<br> 编辑 $CATALINA_HOME/conf/tomcat-users.xml，在 <code>/tomcat</code> 节点下添加用户配置如下<pre><code class="xml">&lt;role rolename=&quot;manager&quot; /&gt;
&lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;manager&quot; /&gt;
</code></pre>
</li>
</ol>
</li>
</ul>
</details>

<ul>
<li>参考<blockquote>
<p><a href="https://www.cnblogs.com/kismetv/p/7228274.html#title3-1">详解 Tomcat 配置文件 server.xml</a></p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>WebAssembly</title>
    <url>/2025/03/22/webassembly/</url>
    <content><![CDATA[<h1 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a><a href="https://www.wasm.com.cn/">WebAssembly</a></h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ol>
<li><p>安装依赖</p>
<pre><code class="bash">apt-get update
apt-get -y install git build-essential python pip
</code></pre>
</li>
<li><p>获取 emsdk</p>
<pre><code class="bash"># Get the emsdk repo
git clone https://github.com/emscripten-core/emsdk.git
</code></pre>
</li>
<li><p>安装配置 Emscripten</p>
<pre><code class="bash"># Enter that directory
cd emsdk

# Fetch the latest registry of available tools.
# ./emsdk update

# Download and install the latest SDK tools. Need install Python first. 
./emsdk install latest

# Make the &quot;latest&quot; SDK &quot;active&quot; for the current user. (writes ~/.emscripten file)
./emsdk activate latest

# Activate PATH and other environment variables in the current terminal
source ./emsdk_env.sh

# Verifying Emscripten
emcc -v
</code></pre>
</li>
<li><p>创建 hello.c</p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main() &#123;
    printf(&quot;hello, world!\n&quot;);
    return 0;
&#125;
</code></pre>
</li>
<li><p>编译</p>
<pre><code class="bash"># 生成 a.out.js, a.out.wasm
emcc hello.c

# 生成 hello.js
emcc hello.c -o hello.js

# 生成 hello.html 和 hello.js
emcc hello.c -o hello.html
</code></pre>
</li>
<li><p>运行</p>
<pre><code class="bash">node a.out.js
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>webassembly</category>
      </categories>
      <tags>
        <tag>webassembly</tag>
      </tags>
  </entry>
</search>
